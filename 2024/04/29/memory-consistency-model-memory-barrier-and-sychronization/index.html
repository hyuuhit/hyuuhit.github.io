<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="huyu's blog | Linux"><title>内存一致性模型、内存屏障与同步 | 属乌鸦的</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-129648993-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '85d80db9310fa34ab2f7d34beeff589b';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">内存一致性模型、内存屏障与同步</h1><a id="logo" href="/.">属乌鸦的</a><p class="description">无知 &amp; 聒噪</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">内存一致性模型、内存屏障与同步</h1><div class="post-meta">Apr 29, 2024</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一些概念"><span class="toc-number">1.</span> <span class="toc-text">一些概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存一致性（Cache-Coherence）"><span class="toc-number">1.1.</span> <span class="toc-text">缓存一致性（Cache Coherence）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存一致性（Memory-Consistency）"><span class="toc-number">1.2.</span> <span class="toc-text">内存一致性（Memory Consistency）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多拷贝原子性（Multicopy-Atomicity）"><span class="toc-number">1.3.</span> <span class="toc-text">多拷贝原子性（Multicopy Atomicity）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#other-multicopy-atomicity"><span class="toc-number">1.4.</span> <span class="toc-text">other multicopy atomicity</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存屏障是什么？"><span class="toc-number">2.</span> <span class="toc-text">内存屏障是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么会出现内存访问顺序与程序顺序不一致？"><span class="toc-number">3.</span> <span class="toc-text">为什么会出现内存访问顺序与程序顺序不一致？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么内存访问顺序重排可以提供更好的性能？"><span class="toc-number">4.</span> <span class="toc-text">为什么内存访问顺序重排可以提供更好的性能？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存访问重排是如何做到的？"><span class="toc-number">5.</span> <span class="toc-text">内存访问重排是如何做到的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#写缓冲区会导致什么？"><span class="toc-number">5.1.</span> <span class="toc-text">写缓冲区会导致什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#失效队列会导致什么？"><span class="toc-number">5.2.</span> <span class="toc-text">失效队列会导致什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#都有哪些内存访问重排类型？"><span class="toc-number">6.</span> <span class="toc-text">都有哪些内存访问重排类型？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#都有哪些内存一致性模型？"><span class="toc-number">7.</span> <span class="toc-text">都有哪些内存一致性模型？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编译屏障"><span class="toc-number">8.</span> <span class="toc-text">编译屏障</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile"><span class="toc-number">8.1.</span> <span class="toc-text">volatile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#barrier"><span class="toc-number">8.2.</span> <span class="toc-text">barrier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#READ-ONCE-WRITE-ONCE"><span class="toc-number">8.3.</span> <span class="toc-text">READ_ONCE / WRITE_ONCE</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存屏障-memory-barrier"><span class="toc-number">9.</span> <span class="toc-text">内存屏障 memory barrier</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内存屏障不能保证什么？"><span class="toc-number">9.1.</span> <span class="toc-text">内存屏障不能保证什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#同步操作"><span class="toc-number">10.</span> <span class="toc-text">同步操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原子操作"><span class="toc-number">10.1.</span> <span class="toc-text">原子操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#锁操作"><span class="toc-number">10.2.</span> <span class="toc-text">锁操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他"><span class="toc-number">11.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么一些环境中printk能起到内存屏障一样的影响？"><span class="toc-number">11.1.</span> <span class="toc-text">为什么一些环境中printk能起到内存屏障一样的影响？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#精确中断："><span class="toc-number">11.2.</span> <span class="toc-text">精确中断：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cpu-relax："><span class="toc-number">11.3.</span> <span class="toc-text">cpu_relax：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">12.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="post-content"><p>本文记录个人对于内存一致性、内存屏障和一些同步操作以及它们之间关系的理解，并列举linux内核中对应的部分实现。</p>
<a id="more"></a>
<p>参考内核版本 4.18.0-193.el8.x86_64</p>
<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><h3 id="缓存一致性（Cache-Coherence）"><a href="#缓存一致性（Cache-Coherence）" class="headerlink" title="缓存一致性（Cache Coherence）"></a>缓存一致性（Cache Coherence）</h3><p>缓存一致性可以看作同一地址上的多个写操作被所有CPU观测到的顺序的维护。<br>具备以下两个条件的系统，可以认为缓存具有一致性（具备缓存一致性的系统，可以将缓存看作是透明的）</p>
<ol>
<li>任何CPU所发出的访存操作被存储器所观察到的顺序必须与CPU发出操作的顺序相同</li>
<li>每个读操作所返回的值必须是最后一次对该存储位置的写操作的值</li>
</ol>
<p>MESI协议及其变种可以被用于实现缓存一致性。（总线嗅探、总线仲裁，使多核间事务可以串行化。在此基础上MESI协议及其变种使用状态和消息确保缓存一致性）</p>
<h3 id="内存一致性（Memory-Consistency）"><a href="#内存一致性（Memory-Consistency）" class="headerlink" title="内存一致性（Memory Consistency）"></a>内存一致性（Memory Consistency）</h3><p>memory consistency可以看作多个地址的访存操作被所有CPU观测到的顺序的维护。<br>不同内存一致性模型定义了该模型允许的读写操作的重排行为。</p>
<h3 id="多拷贝原子性（Multicopy-Atomicity）"><a href="#多拷贝原子性（Multicopy-Atomicity）" class="headerlink" title="多拷贝原子性（Multicopy Atomicity）"></a>多拷贝原子性（Multicopy Atomicity）</h3><p>需要满足两个条件：</p>
<ol>
<li>多个CPU对一个地址的写操作是串行的，这些写操作被所有观察者以相同的顺序观察到，允许观察者观测不到所有的写值。</li>
<li>某个CPU对一个地址的读操作可以返回某一个写操作写入的值，只有当这个写入操作可以被所有观察者观测到时，这里的所有包含自身CPU。</li>
</ol>
<p>由于第二个条件对CPU性能优化影响过大，一般CPU应该都不具备多拷贝原子性。<br>这个东西影响的主要是一个写操作对多个CPU是不是同时可见。可以理解为一个写操作需要拷贝到多个CPU，这拷贝多份的原子性。<br>这个东西与内存一致性是相互独立的，也就是说哪怕真的存在顺序一致性内存模型的CPU也允许非多拷贝原子性。</p>
<h3 id="other-multicopy-atomicity"><a href="#other-multicopy-atomicity" class="headerlink" title="other multicopy atomicity"></a>other multicopy atomicity</h3><p>由于multicopy atomicity对于CPU性能影响过大，又有一个弱化版的概念other multicopy atomicity，也就是一个写操作对其他所有CPU同时可见。linux内核文档里将这个概念简化称呼为multicopy atomicity。linux内核中可以使用通用屏障额外确保other multicopy atomicity。</p>
<p>比如下面的CPU2使用的通用屏障补全了缺失的other multicopy atomicity。</p>
<figure class="highlight plain"><figcaption><span>other multicopy atomicity</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CPU 1                   CPU 2                   CPU 3</span><br><span class="line">======================= ======================= =======================</span><br><span class="line">&#123; X = 0, Y = 0 &#125;</span><br><span class="line">STORE X=1               r1=LOAD X (reads 1)     LOAD Y (reads 1)</span><br><span class="line">                        &lt;general barrier&gt;       &lt;read barrier&gt;</span><br><span class="line">                        STORE Y=r1              LOAD X</span><br></pre></td></tr></table></figure>
<h2 id="内存屏障是什么？"><a href="#内存屏障是什么？" class="headerlink" title="内存屏障是什么？"></a>内存屏障是什么？</h2><p>内存屏障用于在一些场景（比如同步原语）保证特定的内存访问顺序与程序顺序一致。</p>
<h2 id="为什么会出现内存访问顺序与程序顺序不一致？"><a href="#为什么会出现内存访问顺序与程序顺序不一致？" class="headerlink" title="为什么会出现内存访问顺序与程序顺序不一致？"></a>为什么会出现内存访问顺序与程序顺序不一致？</h2><p>内存访问顺序的重排可以提供更好的性能。</p>
<h2 id="为什么内存访问顺序重排可以提供更好的性能？"><a href="#为什么内存访问顺序重排可以提供更好的性能？" class="headerlink" title="为什么内存访问顺序重排可以提供更好的性能？"></a>为什么内存访问顺序重排可以提供更好的性能？</h2><p>现代CPU指令执行速度比内存访问速度快几个数量级，为了提升访存速度为CPU增加了比内存更快的缓存，为了使每个CPU的写操作不会影响所有CPU缓存数据一致而使用缓存一致性协议（比如MESI协议），这使所有CPU的缓存数据看起来与内存是一体的，或者说是透明的。<br>但是这种情况下有些无条件的写操作还需要等待其他CPU响应以获取缓存行的E状态，这种等待时间是没有价值的。解决这种问题的方式可以是引入新的层，同时将对缓存的操作异步化，使普通的读写指令不需要做非必要的等待。异步操作的代价就是不同地址的数据修改操作被各个CPU观测到的顺序不完全相同。</p>
<h2 id="内存访问重排是如何做到的？"><a href="#内存访问重排是如何做到的？" class="headerlink" title="内存访问重排是如何做到的？"></a>内存访问重排是如何做到的？</h2><p>假设有这样一个架构，多核CPU，每个CPU和内存中间有缓存（cache）。</p>
<p>总线嗅探、总线仲裁，使得多核间可以事务串行化。在此基础上MESI协议使用状态和消息确保缓存的数据一致，操作缓存数据也是同步操作，此状态下缓存数据和内存数据可以看作是一体的，CPU对缓存的修改可以被其他CPU同步观测到，缓存可以看作是透明的。</p>
<p>这时CPU对本地有效的缓存行的读性能很好。</p>
<p>但是，写缓存还是同步操作，当缓存行不是E或M状态时需要先与其他CPU交互通信才能执行写操作。</p>
<p>为了提升写操作性能，增加写缓冲区（store buffer）。写指令放入到写缓冲区同时向其他CPU发出RFO请求（Request For Ownership），不等待ack就直接返回继续执行后续指令。ack消息返回后再写进缓存。读取数据时也会在写缓冲区中搜索。</p>
<h3 id="写缓冲区会导致什么？"><a href="#写缓冲区会导致什么？" class="headerlink" title="写缓冲区会导致什么？"></a>写缓冲区会导致什么？</h3><p>会导致写乱序。需要等待RFO ACK的写操作延迟生效到内存，后执行的对已经处于排他状态内存地址的写操作不需要RFO可能先生效到内存，就是StoreStore重排。后执行的读操作同理。这就StoreLoad重排。<br>如果强制写操作必须都进入Store Buffer做FIFO排队，就能避免StoreStore重排。</p>
<figure class="highlight plain"><figcaption><span>StoreLoad重排的例子。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x和y初始均为0</span><br><span class="line">cpu0执行x=1；读y；</span><br><span class="line">cpu1执行y=1；读x；</span><br><span class="line">如果y的缓存行在cpu0，x的缓存行在cpu1。可能发生读到的x和均为0</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>StoreStore重排的例子。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x和y初始均为0</span><br><span class="line">cpu0执行x=1；y=1；</span><br><span class="line">cpu1循环读y，直到y==1；读x；</span><br><span class="line">如果cpu0对两个写操作不强制做FIFO要求，可能出现y的新值先写入cache（比如y已经在缓存中），被cpu1读到，cpu1继续读取到x旧值0</span><br></pre></td></tr></table></figure>
<p>写缓冲区容量有限，等待ack的操作填满写缓冲区后，写操作依然要等待。</p>
<p>继续增加失效队列（invalidation queue），接收方收到RFO请求后将消息放入失效队列并直接响应ack。失效队列中的消息排队等待CPU处理。失效队列中的消息并不会被CPU读取数据时观测到。</p>
<h3 id="失效队列会导致什么？"><a href="#失效队列会导致什么？" class="headerlink" title="失效队列会导致什么？"></a>失效队列会导致什么？</h3><p>会导致读乱序。本地已经缓存的数据旧值时间延长，先执行的读取未缓存数据的指令可能读到更新的值。（可以看到这个效果甚至不满足PSO部分存储定序模型，也就是说X86中均不会有此种效果的实现）</p>
<p>写缓冲区和失效队列，导致多个CPU对多个内存地址的读写预期顺序不再一致，或者说看起来表现为指令重排序。</p>
<p>当然CPU实际上要复杂得多，这里的描述只是一个更有利于直观理解的假设的架构，实际软件开发中是不应该依赖这种简单不准确的描述。</p>
<p>操作系统开发人员应该关注的是每种CPU允许的重排类型，提供合适的内存屏障、原子操作及其他类型同步工具api的封装。<br>驱动开发人员应该关注于正确理解这些工具api的语义，并正确使用这些封装后的api（假定运行的CPU均为Alpha架构）。</p>
<h2 id="都有哪些内存访问重排类型？"><a href="#都有哪些内存访问重排类型？" class="headerlink" title="都有哪些内存访问重排类型？"></a>都有哪些内存访问重排类型？</h2><p>参考下图。其中Incoherent instruction cache/pipeline，个人理解应该是指令和数据使用不同的缓存，因此self-modifying code修改指令内存后需要特定的指令刷新指令缓存。</p>
<p><img src="//blog-image.hyuuhit.com/2024/04/memory_ordering.png" alt="memory ordering in some architectures"></p>
<h2 id="都有哪些内存一致性模型？"><a href="#都有哪些内存一致性模型？" class="headerlink" title="都有哪些内存一致性模型？"></a>都有哪些内存一致性模型？</h2><p>不同架构CPU因为硬件设计不同，允许的重排类型不同。内存一致性模型定义了该模型下允许的重排类型，几个典型的内存一致性模型如下：</p>
<ul>
<li>顺序一致性（Sequential Consistency）模型。完全不允许重排。</li>
<li>完全存储定序（Total Store Order）模型。允许对StoreLoad重排。（可以简单理解为增加了Store Buffer，且限制写操作必须经Store Buffer做FIFO。X86使用该模型）</li>
<li>部分存储定序（Part Store Order）模型。允许对StoreLoad和StoreStore重排。（可以简单理解为增加了Store Buffer，未做FIFO限制）</li>
<li>宽松存储定序（Relax Memory Order）模型。允许任意无依赖关系的指令重排。（ARM64使用该模型）</li>
</ul>
<p>Alpha处理器允许有依赖关系的读操作重排，不属于上面4个模型。<br>从可移植性考虑开发中不应该依赖具体的模型，而应该规范使用内存屏障（也就是假定均为Alpha架构）。</p>
<h2 id="编译屏障"><a href="#编译屏障" class="headerlink" title="编译屏障"></a>编译屏障</h2><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>阻止编译器对变量做任何优化。<br>在内核模块开发中这个关键字是不应该存在的，如果使用了该关键字，需要十分仔细确认是否达成了特定的目标。这个关键字可以用于内存映射的IO寄存器，但是此种情况一般使用封装过的函数进行访问。在内核模块开发中对于并发访问的场景，不应该期望该关键字提供有效的保护措施，而应该正确使用编译屏障、内存屏障、锁、rcu等其他手段。</p>
<h3 id="barrier"><a href="#barrier" class="headerlink" title="barrier"></a>barrier</h3><p>阻止编译器对barrier前后代码重排，强制编译器在循环中每次重新读取条件变量。</p>
<h3 id="READ-ONCE-WRITE-ONCE"><a href="#READ-ONCE-WRITE-ONCE" class="headerlink" title="READ_ONCE / WRITE_ONCE"></a>READ_ONCE / WRITE_ONCE</h3><p>可以看作barrier的弱化，只对使用该api的访存操作生效。（循环条件中的优化种类很多）<br>普通单指令不能完成的非地址对齐的访存操作，可以用READ_ONCE/WRITE_ONCE单步完成。<br>编译器可以移动READ_ONCE/WRITE_ONCE保护的操作跨越不包含READ_ONCE/WRITE_ONCE/barrier的代码。<br>并行共享的变量，就都不要用普通读写操作就对了。（volatile修饰的变量不需要，这玩意同样阻止编译器对变量的优化）</p>
<h2 id="内存屏障-memory-barrier"><a href="#内存屏障-memory-barrier" class="headerlink" title="内存屏障 memory barrier"></a>内存屏障 memory barrier</h2><p>linux提供抽象的内存屏障函数，可以阻止访存重排和cpu指令执行重排，同时也包含了barrier编译屏障的功能（地址依赖屏障不包含编译屏障，编译器会根据该依赖关系不会做重排）。</p>
<p>linux有7个基本类型内存屏障函数。强制内存屏障用于MMIO场景（即使是单核），普通SMP并行场景不需要使用强制内存屏障。</p>
<figure class="highlight plain"><figcaption><span>基本类型内存屏障</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TYPE                    强制内存屏障     SMP内存屏障</span><br><span class="line">======================= =============== ===============</span><br><span class="line">GENERAL                 mb()            smp_mb()</span><br><span class="line">WRITE                   wmb()           smp_wmb()</span><br><span class="line">READ                    rmb()           smp_rmb()</span><br><span class="line">ADDRESS DEPENDENCY                      READ_ONCE()</span><br></pre></td></tr></table></figure>
<ul>
<li>写屏障（smp_wmb），在内存的视角看屏障前后的写操作都无法跨越屏障。但是不保证屏障前的写操作都对内存立即可见。</li>
<li>读屏障（smp_rmb），在内存的视角看屏障前后的读操作都无法跨越屏障。但是不保证屏障后的读操作一定读到内存当前状态。</li>
<li>通用屏障（smp_mb），不只是写屏障与读屏障的和。在内存视角看屏障前后的读写操作都无法跨越屏障，通用屏障还保证了other multicopy atomicity。但是不保证屏障指令执行时本地缓存与内存同步。</li>
<li>地址依赖屏障（smp_read_barrier_depends），对应场景是先读一个地址，再读该地址存储的数据。目前看只针对Alpha架构允许的有依赖关系的读操作重排，非常反直觉，其他任何架构都不允许此种排重。4.18内核的READ_ONCE内包含了该屏障，rcu_dereference使用了READ_ONCE。内核一些难以理解的操作与这个地址依赖屏障有关。</li>
</ul>
<p>还有一些相对不常用的。</p>
<ul>
<li>smp_store_mb</li>
<li>smp_mb__before_atomic</li>
<li>smp_mb__after_atomic</li>
<li>dma_wmb</li>
<li>dma_rmb</li>
<li>dma_mb</li>
<li>pmem_wmb</li>
<li>io_stop_wc</li>
</ul>
<p>linux内核中各种锁操作也包含隐式内存屏障，比如自旋锁、读写自旋锁、mutex、信号量、读写信号量等，均包含ACQUIRE / RELEASE语义</p>
<ul>
<li><p>ACQUIRE<br>这类似一个单向渗透屏障。ACQUIRE之后的访存操作一定生效在ACQUIRE之后，之前的访存操作可以生效在ACQUIRE之后。一个ACQUIRE操作一定在后运行的ACQUIRE或RELEASE之前完成。<br>包括锁操作和smp_load_acquire、smp_cond_load_acquire</p>
</li>
<li><p>RELEASE<br>这类似一个单向渗透屏障。RELEASE之前的访存操作一定生效在RELEASE之前，之后的访存操作可以生效在RELEASE之前。<br>包括解锁操作和smp_store_release</p>
</li>
</ul>
<p>ACQUIRE / RELEASE重点是单向渗透，临界区外的指令可能在临界区中执行，ACQUIRE+RELEASE一起使用不等于一个通用屏障。<br>锁原语的临界区用于保护数据，需要并行访问数据的所有位置配套使用锁原语临界区。</p>
<p>linux调度器包含通用内存屏障，保证了一个task在调度到另一个CPU运行前，在之前CPU的所有内存操作均对新CPU可以见。</p>
<h3 id="内存屏障不能保证什么？"><a href="#内存屏障不能保证什么？" class="headerlink" title="内存屏障不能保证什么？"></a>内存屏障不能保证什么？</h3><ul>
<li>内存屏障前的任何访存操作不能保证在内存屏障指令完成时生效到内存。内存屏障只可以限制该CPU上访存操作生效的部分相对顺序。</li>
<li>一个CPU上的内存屏障不会对其他CPU和设备的访存操作产生直接影响，其他CPU只有使用配对合适的内存屏障才能保证观测到第一个CPU上访存操作的正确顺序。</li>
<li>无法保证与CPU交互的其他硬件设备不会做访存重排。</li>
</ul>
<h2 id="同步操作"><a href="#同步操作" class="headerlink" title="同步操作"></a>同步操作</h2><p>内存屏障仅保证内存访问操作顺序性，不保证多核间的同步，因此还需要其他同步机制</p>
<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>linux内核提供了原子类型及对应的原子操作api，可以分为RMW（read、modify、write）及非RMW两类。</p>
<ul>
<li>非RMW操作比较简单，比如atomic_read、atomic_set，不涉及同步。</li>
<li>RMW操作，比如atomic_add、atomic_xchg之类，这类api保证了原子操作，这必然需要多CPU同步，其实现依赖各架构提供的不同指令。</li>
</ul>
<p>以x86下atomic_add为例，可以看到其依赖lock指令实现同步。<br>lock修饰的指令操作的内存只能由当前CPU使用。附带有通用屏障效果。<br>这个实现可以是锁总线也可以是通过缓存一致性协议锁定缓存行（比如先通过MESI协议获取并保持缓存行的E或M状态再进行独占的RMW操作，直到RMW操作完成才允许释放M状态）。</p>
<p>LOCK_PREFIX宏的作用是将所有lock指令地址保存在.smp_locks段。smp编译的内核运行在单核环境时，可以将lock指令替换成nop以降低性能损耗，cpu hotplug时又可以恢复lock。</p>
<figure class="highlight c"><figcaption><span>x86下atomic_add的实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Alternative inline assembly for SMP.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The LOCK_PREFIX macro defined here replaces the LOCK and</span></span><br><span class="line"><span class="comment"> * LOCK_PREFIX macros used everywhere in the source tree.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * SMP alternatives use the same data structures as the other</span></span><br><span class="line"><span class="comment"> * alternatives and the X86_FEATURE_UP flag to indicate the case of a</span></span><br><span class="line"><span class="comment"> * UP system running a SMP kernel.  The existing apply_alternatives()</span></span><br><span class="line"><span class="comment"> * works fine for patching a SMP kernel for UP.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The SMP alternative tables can be kept after boot and contain both</span></span><br><span class="line"><span class="comment"> * UP and SMP versions of the instructions to allow switching back to</span></span><br><span class="line"><span class="comment"> * SMP at runtime, when hotplugging in a new CPU, which is especially</span></span><br><span class="line"><span class="comment"> * useful in virtualized environments.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The very common lock prefix is handled as special case in a</span></span><br><span class="line"><span class="comment"> * separate table which is a pure address list without replacement ptr</span></span><br><span class="line"><span class="comment"> * and size information.  That keeps the table sizes small.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_PREFIX_HERE \</span></span><br><span class="line">        <span class="string">".pushsection .smp_locks,\"a\"\n"</span>   \</span><br><span class="line">        <span class="string">".balign 4\n"</span>               \</span><br><span class="line">        <span class="string">".long 671f - .\n"</span> <span class="comment">/* offset */</span>     \</span><br><span class="line">        <span class="string">".popsection\n"</span>             \</span><br><span class="line">        <span class="string">"671:"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_PREFIX LOCK_PREFIX_HERE <span class="meta-string">"\n\tlock; "</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* ! CONFIG_SMP */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_PREFIX_HERE <span class="meta-string">""</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_PREFIX <span class="meta-string">""</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * arch_atomic_add - add integer to atomic variable</span></span><br><span class="line"><span class="comment">  * @i: integer value to add</span></span><br><span class="line"><span class="comment">  * @v: pointer of type atomic_t</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * Atomically adds @i to @v.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">void</span> <span class="title">arch_atomic_add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">atomic_t</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(LOCK_PREFIX <span class="string">"addl %1,%0"</span></span></span></span><br><span class="line"><span class="function"><span class="params">            : <span class="string">"+m"</span> (v-&gt;counter)</span></span></span><br><span class="line">            : "ir" (i) : "memory");</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">void</span> <span class="title">atomic_add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">atomic_t</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kasan_check_write(v, <span class="keyword">sizeof</span>(*v));</span><br><span class="line">    arch_atomic_add(i, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="锁操作"><a href="#锁操作" class="headerlink" title="锁操作"></a>锁操作</h3><p>原子操作也是各种锁实现的基础，以spin_lock为例，其实现代码中可以看到依赖的是原子操作以及内存屏障。<br>其中<code>pv_lock_ops.queued_spin_lock_slowpath</code>可能的函数符号</p>
<ul>
<li>esxi虚拟机下为<code>native_queued_spin_lock_slowpath</code></li>
<li>在kvm虚拟机下为<code>__pv_queued_spin_lock_slowpath</code></li>
</ul>
<p>这两个函数的实现均是kernel/locking/qspinlock.c中的<code>queued_spin_lock_slowpath</code>，该文件前部分先通过宏替换定义出函数<code>native_queued_spin_lock_slowpath</code>，最后再通过更改部分宏定义并include自身文件的方式再次使用同样的代码定义出函数<code>__pv_queued_spin_lock_slowpath</code>，区别在于两个函数内<code>pv_enabled()</code>及一些其他宏的值不同。</p>
<figure class="highlight c"><figcaption><span>x86下spin_lock的实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">void</span> <span class="title">pv_queued_spin_lock_slowpath</span><span class="params">(struct qspinlock *lock,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    u32 val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PVOP_VCALL2(pv_lock_ops.queued_spin_lock_slowpath, lock, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">queued_spin_lock_slowpath</span><span class="params">(struct qspinlock *lock, u32 val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pv_queued_spin_lock_slowpath(lock, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * queued_spin_lock - acquire a queued spinlock</span></span><br><span class="line"><span class="comment">  * @lock: Pointer to queued spinlock structure</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">void</span> <span class="title">queued_spin_lock</span><span class="params">(struct qspinlock *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u32 val;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    val = atomic_cmpxchg_acquire(&amp;lock-&gt;val, <span class="number">0</span>, _Q_LOCKED_VAL);</span><br><span class="line">    <span class="keyword">if</span> (likely(val == <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    queued_spin_lock_slowpath(lock, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arch_spin_lock(l)       queued_spin_lock(l)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We are now relying on the NMI watchdog to detect lockup instead of doing</span></span><br><span class="line"><span class="comment"> * the detection here with an unfair lock which can cause problem of its own.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_raw_spin_lock</span><span class="params">(<span class="keyword">raw_spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    debug_spin_lock_before(lock);</span><br><span class="line">    arch_spin_lock(&amp;lock-&gt;raw_lock);</span><br><span class="line">    mmiowb_spin_lock();</span><br><span class="line">    debug_spin_lock_after(lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 典型配置下就只是做了do_raw_spin_lock</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __raw_spin_lock(<span class="keyword">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">    preempt_disable();</span><br><span class="line">    spin_acquire(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line">    LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_INLINE_SPIN_LOCK</span></span><br><span class="line"><span class="keyword">void</span> __lockfunc _raw_spin_lock(<span class="keyword">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">    __raw_spin_lock(lock);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(_raw_spin_lock);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">void</span> <span class="title">spin_lock</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    raw_spin_lock(&amp;lock-&gt;rlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="为什么一些环境中printk能起到内存屏障一样的影响？"><a href="#为什么一些环境中printk能起到内存屏障一样的影响？" class="headerlink" title="为什么一些环境中printk能起到内存屏障一样的影响？"></a>为什么一些环境中printk能起到内存屏障一样的影响？</h3><p>printk内部实现中调用了<code>raw_spin_lock</code>和<code>raw_spin_unlock</code>，以x86架构为例内部包含lock指令，具备通用屏障效果，但这种x86架构下raw_spin_lock提供内存屏障的能力是依赖具体实现的，本身并不在spinlock自身语义中，因此是不可以依赖的，需要内存屏障的场景还是应该使用内存屏障命令。printk的该副作用也会影响一些场景的bug复现及调试。</p>
<h3 id="精确中断："><a href="#精确中断：" class="headerlink" title="精确中断："></a>精确中断：</h3><p>中断前的指令都执行完成，中断后的指令都没有执行。确保中断发生时刻正在运行的代码不被CPU乱序和内存一致性问题影响，可以看到一个顺序一致的内存状态。</p>
<h3 id="cpu-relax："><a href="#cpu-relax：" class="headerlink" title="cpu_relax："></a>cpu_relax：</h3><p>用于忙等待，在cpu支持情况下，具备内存屏障、降低功耗和让位同核超线程能力。x86下为rep;nop，其编译结果应该与pause等价（f390）。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.kernel.org/doc/Documentation/memory-barriers.txt" target="_blank" rel="noopener">Linux 内核文档 memory barriers</a><br><a href="http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.07.23a.pdf" target="_blank" rel="noopener">Memory Barriers: a Hardware View for Software Hackers</a><br><a href="https://github.com/kaitoukito/A-Primer-on-Memory-Consistency-and-Cache-Coherence" target="_blank" rel="noopener">A Primer on Memory Consistency and Cache Coherence</a></p>
</div><div class="tags"><a href="/tags/linux/">linux</a></div><div class="post-nav"><a class="pre" href="/2024/05/13/elrepo-not-for-production-use/">为什么生产环境服务器不应该使用ELRepo内核</a><a class="next" href="/2024/04/11/rcu-usage/">抢占式RCU与RCU使用</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://www.hyuuhit.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/libvirt/">libvirt</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/suricata/">suricata</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/vmware/" style="font-size: 15px;">vmware</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/04/07/cn-proc-example/">cn_proc 进程事件连接器</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/04/executable-shared-library/">可执行的动态链接库</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/05/26/dirpro-bug-analysis/">一次无源码Linux内核模块bug分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/05/13/elrepo-not-for-production-use/">为什么生产环境服务器不应该使用ELRepo内核</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/04/29/memory-consistency-model-memory-barrier-and-sychronization/">内存一致性模型、内存屏障与同步</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/04/11/rcu-usage/">抢占式RCU与RCU使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/09/16/tc-tbf-qdisc/">tc tbf qdisc 令牌桶过滤器限速队列</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/08/function-call-stack/">gdb查看寄存器及内存数据与函数调用栈分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/16/libpcap-cutoff-captured-packet/">libpcap在libvirt虚拟化环境下捕获数据包不完整的一种情况分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/27/bash-audit/">一种简单的bash审计方法</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">属乌鸦的.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>