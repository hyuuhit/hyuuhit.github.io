<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="huyu's blog | Linux"><title>Linux network namespace 简单解读 | 属乌鸦的</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-129648993-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '85d80db9310fa34ab2f7d34beeff589b';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Linux network namespace 简单解读</h1><a id="logo" href="/.">属乌鸦的</a><p class="description">无知 &amp; 聒噪</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Linux network namespace 简单解读</h1><div class="post-meta">Mar 23, 2019</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#netns-相关内核结构"><span class="toc-number">1.</span> <span class="toc-text">netns 相关内核结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#net-结构"><span class="toc-number">1.1.</span> <span class="toc-text">net 结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#与进程关系"><span class="toc-number">1.2.</span> <span class="toc-text">与进程关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#与网络设备关系"><span class="toc-number">1.3.</span> <span class="toc-text">与网络设备关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#netns-模块初始化"><span class="toc-number">2.</span> <span class="toc-text">netns 模块初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#netns-相关系统调用"><span class="toc-number">3.</span> <span class="toc-text">netns 相关系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#clone"><span class="toc-number">3.1.</span> <span class="toc-text">clone</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unshare"><span class="toc-number">3.2.</span> <span class="toc-text">unshare</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setns"><span class="toc-number">3.3.</span> <span class="toc-text">setns</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#netns-操作"><span class="toc-number">4.</span> <span class="toc-text">netns 操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#netns-创建"><span class="toc-number">4.1.</span> <span class="toc-text">netns 创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netns-中执行进程"><span class="toc-number">4.2.</span> <span class="toc-text">netns 中执行进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netns-中添加网络设备"><span class="toc-number">4.3.</span> <span class="toc-text">netns 中添加网络设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netns-删除"><span class="toc-number">4.4.</span> <span class="toc-text">netns 删除</span></a></li></ol></li></ol></div></div><div class="post-content"><p>一个network namespace是网络栈的一个逻辑拷贝，它包含了自有的路由表、防火墙规则和网络设备。</p>
<p>首先假定已经基本了解network namespace（网络命名空间）并熟悉使用iproute2工具包的ip命令操作netns。本文主要记录相关操作命令的实现逻辑，比如netns的名字是如何设定的、netns在内核中是如何存在的、用户态进程是如何与netns关联的。</p>
<a id="more"></a>
<p>本文运行环境：</p>
<ul>
<li>操作系统 CentOS Linux release 7.5.1804</li>
<li>内核版本 3.10.0-862.el7.x86_64</li>
</ul>
<h2 id="netns-相关内核结构"><a href="#netns-相关内核结构" class="headerlink" title="netns 相关内核结构"></a>netns 相关内核结构</h2><p>netns相关结构体这里介绍三个，分别为</p>
<ul>
<li><code>struct net</code><br>netns网络命名空间自身。</li>
<li><code>struct nsproxy</code><br>每个进程所属的所有命名空间整合在该结构体中，体现了namespace与进程的关系。</li>
<li><code>struct net_device</code><br>网络接口设备结构体，体现了netns与网络设备的关系。</li>
</ul>
<h3 id="net-结构"><a href="#net-结构" class="headerlink" title="net 结构"></a>net 结构</h3><p><code>struct net</code>结构是网络命名空间自身的结构体。这里简单说明一下几个比较重要的成员</p>
<ul>
<li><code>list</code><br>所有netns通过其成员<code>list</code>串联成一个链表，链表头是全局变量<code>net_namespace_list</code>。</li>
<li><code>user_ns</code><br>为了管理netns的权限，有一个<code>struct user_namespace</code>指针成员<code>user_ns</code>负责管控权限。</li>
<li><code>loopback_dev</code><br>为每个netns中的回环网络设备。</li>
<li><code>rtnl</code>/<code>genl_sock</code><br>之前关于<a href="/2018/08/22/netlink/">netlink</a>和<a href="/2018/09/18/generic-netlink/">genetlink</a>的介绍中有提到过netlink socket是与netns关联的，这里的成员<code>rtnl</code>和<code>genl_sock</code>就分别是该netns中rtnetlink和genetlink的指针，其他类型的netlink也有对应成员。</li>
<li><code>proc_inum</code><br>该netns在proc文件系统中对应的inode号，可以考虑在内核模块输出调试信息时用于唯一标记该netns，相比输出net结构体地址更友好一些。</li>
</ul>
<p>这里说一下netns本身是没有名字的，使用ip命令时赋予和操作的名字仅仅是ip命令内部为了便于区分netns在文件系统中创建的与netns对应的文件的文件名，文件所在目录为/var/run/netns/，这样可以使用户态程序更简单的区分和操作netns，<a href="#netns-操作">netns 操作</a>部分可以看到ip命令对该名字的实现机制。</p>
<p>初始netns有一个全局变量<code>init_net</code>，全局变量定义于文件net/core/net_namespace.c。</p>
<figure class="highlight c"><figcaption><span>struct net 结构部分成员。定义于include/net/net_namespace.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net</span> &#123;</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span>   *<span class="title">user_ns</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>            proc_inum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span>             *<span class="title">rtnl</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span>             *<span class="title">genl_sock</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span>       *<span class="title">lookback_dev</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    /* ... */</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="与进程关系"><a href="#与进程关系" class="headerlink" title="与进程关系"></a>与进程关系</h3><p>Linux中namespace机制的目的是资源隔离，资源的生效体现在进程中，netns是namespace的一种，因此一定会与代表进程的结构体<code>task_struct</code>有关联。实际上<code>task_struct</code>中有一个<code>struct nsproxy</code>指针类型的成员<code>nsproxy</code>保存了进程所关联的所有namespace，也包括netns。</p>
<p>nsproxy与netns类似也有一个全局变量<code>init_nsproxy</code>作为初始的nsproxy。</p>
<figure class="highlight c"><figcaption><span>struct task_struct结构，定义位于include/linux/sched.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/* ...... */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* namespaces */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> *<span class="title">nsproxy</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ...... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>struct nsproxy结构。定义位于include/linux/nsproxy.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A structure to contain pointers to all per-process</span></span><br><span class="line"><span class="comment"> * namespaces - fs (mount), uts, network, sysvipc, etc.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 'count' is the number of tasks holding a reference.</span></span><br><span class="line"><span class="comment"> * The count for each namespace, then, will be the number</span></span><br><span class="line"><span class="comment"> * of nsproxies pointing to it, not the number of tasks.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The nsproxy is shared by tasks which share all namespaces.</span></span><br><span class="line"><span class="comment"> * As soon as a single namespace is cloned or unshared, the</span></span><br><span class="line"><span class="comment"> * nsproxy is copied.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> &#123;</span></span><br><span class="line">    <span class="keyword">atomic_t</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uts_namespace</span> *<span class="title">uts_ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ipc_ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">mnt_ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">pid_ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net</span>       *<span class="title">net_ns</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> <span class="title">init_nsproxy</span>;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>init_nsproxy，定义位于kernel/nsproxy.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> <span class="title">init_nsproxy</span> = &#123;</span></span><br><span class="line">    .count  = ATOMIC_INIT(<span class="number">1</span>),</span><br><span class="line">    .uts_ns = &amp;init_uts_ns,</span><br><span class="line">#<span class="keyword">if</span> defined(CONFIG_POSIX_MQUEUE) || defined(CONFIG_SYSVIPC)</span><br><span class="line">    .ipc_ns = &amp;init_ipc_ns,</span><br><span class="line">#endif</span><br><span class="line">    .mnt_ns = <span class="literal">NULL</span>,</span><br><span class="line">    .pid_ns = &amp;init_pid_ns,</span><br><span class="line">#ifdef CONFIG_NET</span><br><span class="line">    .net_ns = &amp;init_net,</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="与网络设备关系"><a href="#与网络设备关系" class="headerlink" title="与网络设备关系"></a>与网络设备关系</h3><p>Linux中每个网络设备都归属一个netns，直接体现在网络设备对应的结构体中。</p>
<figure class="highlight c"><figcaption><span>struct net_device，定义位于include/linux/netdevice.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This is the first field of the "visible" part of this structure</span></span><br><span class="line"><span class="comment">     * (i.e. as seen by users in the "Space.c" file).  It is the name</span></span><br><span class="line"><span class="comment">     * of the interface.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>            name[IFNAMSIZ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* device name hash chain, please keep it close to name[] */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>   <span class="title">name_hlist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* snmp alias */</span></span><br><span class="line">    <span class="keyword">char</span>            *ifalias;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ...... */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Network namespace this network device is inside */</span></span><br><span class="line">    <span class="keyword">possible_net_t</span>          nd_net;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ...... */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中netns为<code>possible_net_t</code>类型成员<code>nd_net</code>，在本文参考内核源码中定义为：</p>
<p><code>#define possible_net_t  struct net *</code></p>
<p>好奇翻了一下内核提交记录，<code>possible_net_t</code>类型在原始Linux内核中定义于rhel内核并不相同。</p>
<p>在最初，并不存在<code>possible_net_t</code>类型，在netns引入之初，所有需要<code>struct net</code>指针成员的结构体都需要用如下方式引入该成员：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_NET_NS</span><br><span class="line">    struct net      *nd_net;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>同时用配置<code>CONFIG_NET_NS</code>编译时选择不同的方式实现<code>read_pnet</code>和<code>write_pnet</code>。</p>
<p>2015年一位同学不爽这种冗余且容易出错的方式，因此引入了<code>possible_net_t</code>，具体参考<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=0c5c9fb55106333e773de8c9dd321fa8240caeb3" target="_blank" rel="noopener">提交记录</a>，这时内核版本已经是4了，而且定义与本文参考的内核源码并不相同，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NET_NS</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">possible_net_t</span>;</span><br></pre></td></tr></table></figure>
<p>同时配合修改了<code>read_pnet</code>和<code>write_pnet</code>。</p>
<p>这样需要netns的结构体中直接加入<code>possible_net_t</code>类型成员就可以了，不需要在结构体定义中考虑编译配置<code>CONFIG_NET_NS</code>。直到当前最新（2019年3月）的内核源码中，该定义仍没有变化。</p>
<p>由于我没有找到可以简单查看rhel内核源码修改记录的方式，因此没有查到具体rhel引入该类型的历史如何，但可以想见，rhel内核将Linux内核版本4的该修改引入到更早的版本3中，同时引入该修改的工程师更喜欢另一种实现方式，也就是在这里看到的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> possible_net_t  struct net *</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write_pnet</span><span class="params">(<span class="keyword">possible_net_t</span> *pnet, struct net *net)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NET_NS</span></span><br><span class="line">    *pnet = net;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct net *<span class="title">read_pnet</span><span class="params">(<span class="keyword">possible_net_t</span> <span class="keyword">const</span> *pnet)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NET_NS</span></span><br><span class="line">    <span class="keyword">return</span> *pnet;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> &amp;init_net;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="netns-模块初始化"><a href="#netns-模块初始化" class="headerlink" title="netns 模块初始化"></a>netns 模块初始化</h2><p>netns模块由<code>pure_initcall(net_ns_init);</code>注册了系统启动时运行函数<code>net_ns_init</code>。<code>init_net</code>就是在这里初始化的。这里还通过<code>register_pernet_subsys</code>函数注册了<code>net_ns_ops</code>，也就是每个netns在创建时将会分配proc文件系统的inode号赋予给成员<code>proc_inum</code>，在netns销毁时释放。</p>
<figure class="highlight c"><figcaption><span>net_ns_ops</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __<span class="function">net_init <span class="keyword">int</span> <span class="title">net_ns_net_init</span><span class="params">(struct net *net)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> proc_alloc_inum(&amp;net-&gt;proc_inum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __<span class="function">net_exit <span class="keyword">void</span> <span class="title">net_ns_net_exit</span><span class="params">(struct net *net)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    proc_free_inum(net-&gt;proc_inum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pernet_operations</span> __<span class="title">net_initdata</span> <span class="title">net_ns_ops</span> = &#123;</span></span><br><span class="line">    .init = net_ns_net_init,</span><br><span class="line">    .<span class="built_in">exit</span> = net_ns_net_exit,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>struct pernet_operations</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pernet_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="keyword">int</span> (*init)(struct net *net);</span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">exit</span>)(struct net *net);</span><br><span class="line">    <span class="keyword">void</span> (*exit_batch)(struct list_head *net_exit_list);</span><br><span class="line">    <span class="keyword">int</span> *id;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>函数<code>register_pernet_subsys</code>的作用就是将<code>struct pernet_operations</code>类型变量加入到一个链表中，而且对已经存在的netns运行<code>init</code>函数指针，每个新的netns创建后也会遍历执行该链表中的函数指针。netns销毁或<code>struct pernet_operations</code>类型变量调用<code>unregister_pernet_subsys</code>时同理执行<code>exit</code>函数指针。</p>
<h2 id="netns-相关系统调用"><a href="#netns-相关系统调用" class="headerlink" title="netns 相关系统调用"></a>netns 相关系统调用</h2><p>命名空间是对进程访问资源的隔离，对进程命名空间的修改也就是操作<code>task_struct</code>成员<code>nsproxy</code>。相关系统调用如下。</p>
<h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><p>clone系统调用用于创建一个新的process（可以是进程，也可以是线程）。glibs对该系统调用的包装函数为：</p>
<p><code>long clone(unsigned long flags, void *child_stack, void *ptid, void *ctid, struct pt_regs *regs);</code></p>
<p>其中flags用于控制新process各项属性，如果包含<code>CLONE_NEWNET</code>将会为新process创建一个新的netns。</p>
<p>函数细节参考<code>man 2 clone</code></p>
<h3 id="unshare"><a href="#unshare" class="headerlink" title="unshare"></a>unshare</h3><p>unshare系统调用用于将当前进程的一部分执行上下文（与其他进程共享的上下文）解除关联。glibc对该系统调用的包装函数为：</p>
<p><code>int unshare(int flags);</code></p>
<p>其中flags用于设置需要解除关联的上下文类型，如果包含<code>CLONE_NEWNET</code>将会为当前进程创建一个新的netns。</p>
<p>unshare与clone在对netns操作上的区别在于，unshare操作的是当前进程，而且不会有新的process被创建。</p>
<p>函数细节参考<code>man 2 unshare</code></p>
<h3 id="setns"><a href="#setns" class="headerlink" title="setns"></a>setns</h3><p>setns系统调用用于将当前线程与一个指定的命名空间关联。glibc对该系统调用的包装函数为：</p>
<p><code>int setns(int fd, int nstype);</code></p>
<p>其中nstype用于设置需要关联的命名空间类型，比如<code>CLONE_NEWNET</code>标识设置的是网络命名空间，该参数需要与fd对应的命名空间文件匹配。。fd是与命名空间关联的文件的文件描述符，与命名空间关联的文件的典型位置为<code>/proc/[pid]/ns/</code>目录，proc文件系统中对应命名空间的文件可以通过绑定挂载（bind mounting）的方式挂载到文件系统的其他位置以达到该命名空间内所有进程都关闭后仍然可以保持命名空间存在的目的（<code>ip netns</code>使用该特性保持其创建的netns存在）。如果没有绑定挂载和保持打开的文件描述符，那么命名空间内所有进程退出后该命名空间将被释放。</p>
<p>proc文件系统部分参考<code>man 5 proc</code></p>
<p>setns函数细节参考<code>man 2 setns</code></p>
<h2 id="netns-操作"><a href="#netns-操作" class="headerlink" title="netns 操作"></a>netns 操作</h2><p>这里参考iproute2工具包源码，用简化的实例代码的形式，演示network namespace是如何操作的。</p>
<h3 id="netns-创建"><a href="#netns-创建" class="headerlink" title="netns 创建"></a>netns 创建</h3><p>在当前目录创建与新netns关联的文件，文件名作为标识。</p>
<figure class="highlight c"><figcaption><span>netns_add.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mount.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *name = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: %s netns_name\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用unshare将进程的network namespace剥离，创建一个新的network namespace</span></span><br><span class="line">    <span class="keyword">if</span> (unshare(CLONE_NEWNET) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to create a new network namespace \"%s\": %s\n"</span>,</span><br><span class="line">                name, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = open(name, O_RDONLY|O_CREAT|O_EXCL, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Cannot create namespace file \"%s\": %s\n"</span>,</span><br><span class="line">                name, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用绑定挂载保持新network namespace在进程退出后依然存在，</span></span><br><span class="line">    <span class="comment">// 并使用文件名作为该network namespace的标识。</span></span><br><span class="line">    <span class="comment">// 为什么绑定挂载可以达到这个目的，可能与proc文件系统中ns实现有关，这里不做关注</span></span><br><span class="line">    <span class="keyword">if</span> (mount(<span class="string">"/proc/self/ns/net"</span>, name, <span class="string">"none"</span>, MS_BIND, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Bind /proc/self/ns/net -&gt; %s failed: %s\n"</span>,</span><br><span class="line">                name, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="netns-中执行进程"><a href="#netns-中执行进程" class="headerlink" title="netns 中执行进程"></a>netns 中执行进程</h3><p>以当前目录与netns关联的文件为目标，在其netns中执行参数指定的命令。</p>
<figure class="highlight c"><figcaption><span>netns_exec.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">netns_switch</span><span class="params">(<span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> netns;</span><br><span class="line"></span><br><span class="line">    netns = open(name, O_RDONLY | O_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (netns &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Cannot open network namespace \"%s\": %s\n"</span>,</span><br><span class="line">                name, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用setns切换到指定的network namespace</span></span><br><span class="line">    <span class="keyword">if</span> (setns(netns, CLONE_NEWNET) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"setting the network namespace \"%s\" failed: %s\n"</span>,</span><br><span class="line">                name, strerror(errno));</span><br><span class="line">        close(netns);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(netns);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理mount</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理/etc下配置文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: %s netns_name cmd\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用setns切换到指定的network namespace</span></span><br><span class="line">    <span class="keyword">if</span> (netns_switch(argv[<span class="number">1</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进程已经切换到指定network namespace，执行参数指定的可执行程序</span></span><br><span class="line">    <span class="keyword">if</span> (execvp(argv[<span class="number">2</span>], &amp;argv[<span class="number">2</span>])  &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"exec of \"%s\" failed: %s\n"</span>,</span><br><span class="line">                argv[<span class="number">2</span>], strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="netns-中添加网络设备"><a href="#netns-中添加网络设备" class="headerlink" title="netns 中添加网络设备"></a>netns 中添加网络设备</h3><p>这里代码的功能参考<code>ip li set DEV netns NETNS</code>命令。</p>
<p>与前面单纯操作netns不同，这里操作的对象是网络设备，不再使用前面介绍的3个系统调用，而是使用rtnetlink的方式设定网络设备的netns。可以参考前面写过的<a href="/2018/04/05/network-device-list/">获取网卡列表的几种方式</a>和<a href="/2018/08/22/netlink/">Linux netlink socket 内核通信</a>。使用的属性<code>IFLA_NET_NS_FD</code>在man文档有没有看到，查看iproute2具体源码得到该使用方式。</p>
<figure class="highlight c"><figcaption><span>netns_set.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/rtnetlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NLMSG_TAIL(nmsg) \</span></span><br><span class="line">    ((struct rtattr *) (((<span class="keyword">void</span> *) (nmsg)) + NLMSG_ALIGN((nmsg)-&gt;nlmsg_len)))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iplink_req</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span>     <span class="title">n</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifinfomsg</span>    <span class="title">i</span>;</span></span><br><span class="line">    <span class="keyword">char</span>            buf[<span class="number">1024</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addattr_l</span><span class="params">(struct nlmsghdr *n, <span class="keyword">int</span> maxlen, <span class="keyword">int</span> type, <span class="keyword">const</span> <span class="keyword">void</span> *data,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> alen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = RTA_LENGTH(alen);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtattr</span> *<span class="title">rta</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (NLMSG_ALIGN(n-&gt;nlmsg_len) + RTA_ALIGN(len) &gt; maxlen) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">                <span class="string">"addattr_l ERROR: message exceeded bound of %d\n"</span>,</span><br><span class="line">                maxlen);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rta = NLMSG_TAIL(n);</span><br><span class="line">    rta-&gt;rta_type = type;</span><br><span class="line">    rta-&gt;rta_len = len;</span><br><span class="line">    <span class="keyword">if</span> (alen)</span><br><span class="line">        <span class="built_in">memcpy</span>(RTA_DATA(rta), data, alen);</span><br><span class="line">    n-&gt;nlmsg_len = NLMSG_ALIGN(n-&gt;nlmsg_len) + RTA_ALIGN(len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *nsname;</span><br><span class="line">    <span class="keyword">char</span> *devname;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iplink_req</span> <span class="title">req</span> = &#123;</span></span><br><span class="line">        .n.nlmsg_len = NLMSG_LENGTH(<span class="keyword">sizeof</span>(struct ifinfomsg)),</span><br><span class="line">        .n.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK,</span><br><span class="line">        .n.nlmsg_type = RTM_NEWLINK,</span><br><span class="line">        .i.ifi_family = AF_UNSPEC,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模仿ip命令，可以是文件fd，也可以是进程pid</span></span><br><span class="line">    <span class="keyword">int</span> netns;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: %s dev_name netns_name\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    devname = argv[<span class="number">1</span>];</span><br><span class="line">    nsname = argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充netns，可以是文件fd，也可以是进程pid</span></span><br><span class="line">    netns = open(nsname, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (netns &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        addattr_l(&amp;req.n, <span class="keyword">sizeof</span>(req), IFLA_NET_NS_FD, &amp;netns, <span class="number">4</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nsname[<span class="number">0</span>] &gt;= <span class="string">'0'</span> &amp;&amp; nsname[<span class="number">0</span>] &lt;= <span class="string">'1'</span>) &#123;</span><br><span class="line">        <span class="comment">// 当做进程pid处理，实例代码不做完善校验</span></span><br><span class="line">        netns = atoi(nsname);</span><br><span class="line">        addattr_l(&amp;req.n, <span class="keyword">sizeof</span>(req), IFLA_NET_NS_PID, &amp;netns, <span class="number">4</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Invalid netns value \"%s\"\n"</span>, nsname);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充网络设备索引号</span></span><br><span class="line">    req.i.ifi_index = if_nametoindex(devname);</span><br><span class="line">    <span class="keyword">if</span> (req.i.ifi_index == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Cannot find device \"%s\", %s\n"</span>, devname, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送请求</span></span><br><span class="line">    fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"socket failed, %s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = send(fd, &amp;req, req.n.nlmsg_len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"send failed, %s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收请求结果</span></span><br><span class="line">    ret = recv(fd, &amp;req, <span class="keyword">sizeof</span>(req), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"recv failed, %s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (req.n.nlmsg_type == NLMSG_ERROR) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">nlmsgerr</span> *<span class="title">err</span>;</span></span><br><span class="line">        err = NLMSG_DATA(&amp;req.n);</span><br><span class="line">        <span class="keyword">if</span> (err-&gt;error != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, strerror(-err-&gt;error));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"unknown nlmsg_type %hu\n"</span>, req.n.nlmsg_type);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="netns-删除"><a href="#netns-删除" class="headerlink" title="netns 删除"></a>netns 删除</h3><figure class="highlight c"><figcaption><span>netns_del.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mount.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *name = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: %s netns_name\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于绑定挂载的文件，需要先umount</span></span><br><span class="line">    <span class="keyword">if</span> (umount2(name, MNT_DETACH)) &#123;</span><br><span class="line">        <span class="comment">// 出错不影响继续</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// umount该文件与network namespace不再有关系，删除</span></span><br><span class="line">    <span class="keyword">if</span> (unlink(name) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Cannot remove namespace file \"%s\": %s\n"</span>,</span><br><span class="line">                name, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/linux/">linux</a></div><div class="post-nav"><a class="pre" href="/2019/04/20/libyaml/">libyaml 解析配置文件</a><a class="next" href="/2019/01/11/af-packet-bpf/">AF_PACKET &amp; BPF 伪造arp响应</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://www.hyuuhit.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/libvirt/">libvirt</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/suricata/">suricata</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/vmware/" style="font-size: 15px;">vmware</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/09/21/program-crash-caused-by-wrong-return-value-type/">函数返回值类型不符导致的崩溃</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/06/08/screen-windows-auto-title/">gnu screen 自动修改窗口标题</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/06/02/stop-machine/">stop_machine 实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/05/05/static-key-jump-label/">static key & jump label</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/30/initcall/">initcall 机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/07/cn-proc-example/">cn_proc 进程事件连接器</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/04/executable-shared-library/">可执行的动态链接库</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/05/26/dirpro-bug-analysis/">一次无源码Linux内核模块bug分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/05/13/elrepo-not-for-production-use/">为什么生产环境服务器不应该使用ELRepo内核</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/04/29/memory-consistency-model-memory-barrier-and-sychronization/">内存一致性模型、内存屏障与同步</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">属乌鸦的.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>