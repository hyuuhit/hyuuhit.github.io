<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="hu yu's blog | Android | 服务端"><title>一种简单的bash审计方法 | 属乌鸦的</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-129648993-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '85d80db9310fa34ab2f7d34beeff589b';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">一种简单的bash审计方法</h1><a id="logo" href="/.">属乌鸦的</a><p class="description">无知 &amp; 聒噪</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">一种简单的bash审计方法</h1><div class="post-meta">Aug 27, 2019</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#交互式bash记录命令"><span class="toc-number">1.</span> <span class="toc-text">交互式bash记录命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#非交互式bash记录命令"><span class="toc-number">2.</span> <span class="toc-text">非交互式bash记录命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bash函数内部记录命令"><span class="toc-number">3.</span> <span class="toc-text">bash函数内部记录命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#将sh切换为bash"><span class="toc-number">4.</span> <span class="toc-text">将sh切换为bash</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#白名单"><span class="toc-number">5.</span> <span class="toc-text">白名单</span></a></li></ol></div></div><div class="post-content"><p>在高交互蜜罐环境中，ssh服务允许攻击者成功由ssh登录并获取到一个可进行各种操作的真实shell，同时需要记录shell中所有操作。严谨的方案是在bash源码及内核模块中做审计记录。这里给出另一种娱乐性质的方案，简单而tricky的方式达成该目标的基本功能，当然这种方案在了解的人面前很容易被绕过。</p>
<a id="more"></a>
<p>本文参考环境为centos 7.5 1804</p>
<p>这里记录shell执行命令的核心是bash内建的trap命令，trap可以看作bash的信号处理，同时有一些虚拟信号，这里要使用的是DEBUG信号。<code>trap arg DEBUG</code>执行后，arg命令将在每一个命令执行前被执行，同时可以从变量BASH_COMMAND中读取到将要执行的命令。参考<code>man trap</code>，<code>man bash</code>。</p>
<h2 id="交互式bash记录命令"><a href="#交互式bash记录命令" class="headerlink" title="交互式bash记录命令"></a>交互式bash记录命令</h2><p>先看一下例子，<code>log_command</code>中可以替换为其他脚本，将记录到的命令发送到远程服务器并保存。这里仅简单保存日志文件。</p>
<figure class="highlight shell"><figcaption><span>/etc/bash_logger.sh</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function log_command()</span><br><span class="line">&#123;</span><br><span class="line">    echo $(date) $USER $$ $PPID $PWD \"$BASH_COMMAND\" &gt;&gt; /tmp/bash_logger.log</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trap 'log_command' DEBUG</span><br></pre></td></tr></table></figure>
<p>试验一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[huyu@localhost ~]$ source /etc/bash_logger.sh</span><br><span class="line">[huyu@localhost ~]$ ps uxf</span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">huyu      1684  0.0  0.0 154724  2452 ?        S    19:57   0:00 sshd: huyu@notty</span><br><span class="line">huyu      1685  0.0  0.0  72164  2900 ?        Ss   19:57   0:00  \_ /usr/libexec/openssh/sftp-server</span><br><span class="line">huyu      1565  0.0  0.0 154588  2436 ?        S    19:50   0:00 sshd: huyu@pts/0</span><br><span class="line">huyu      1566  0.0  0.0 115440  2036 pts/0    Ss   19:50   0:00  \_ -bash</span><br><span class="line">huyu      1722  0.0  0.0 127636  1180 pts/0    S+   19:59   0:00      \_ screen -r</span><br><span class="line">huyu      1589  0.0  0.0 128520  2292 ?        Ss   19:50   0:00 SCREEN</span><br><span class="line">huyu      1590  0.0  0.0 115440  1904 pts/1    Ss+  19:50   0:00  \_ /bin/bash</span><br><span class="line">huyu     11916  0.0  0.0 115440  2084 pts/3    Ss   20:25   0:00  \_ /bin/bash</span><br><span class="line">huyu     11991  0.0  0.0 107992   616 pts/3    S+   20:27   0:00  |   \_ tail -n0 -f /tmp/bash_logger.log</span><br><span class="line">huyu     11973  0.0  0.0 115440  2092 pts/2    Ss   20:27   0:00  \_ /bin/bash</span><br><span class="line">huyu     11994  0.0  0.0 155324  1848 pts/2    R+   20:27   0:00      \_ ps uxf</span><br></pre></td></tr></table></figure>
<p>看看输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[huyu@localhost ~]$ tail -n0 -f /tmp/bash_logger.log</span><br><span class="line">Mon Aug 26 20:27:29 CST 2019 huyu 11973 1589 /home/huyu &quot;ps uxf&quot;</span><br><span class="line">Mon Aug 26 20:27:29 CST 2019 huyu 11973 1589 /home/huyu &quot;printf &quot;\033]0;%s@%s:%s\007&quot; &quot;$&#123;USER&#125;&quot; &quot;$&#123;HOSTNAME%%.*&#125;&quot; &quot;$&#123;PWD/#$HOME/~&#125;&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>可以看到在期望的命令记录之外又多了一条，这是由于变量<code>PROMPT_COMMAND</code>的影响，在提示符之前会执行该变量指定的命令，这个命令被trap捕获了。把它unset掉就可以了。</p>
<figure class="highlight shell"><figcaption><span>增加 unset PROMPT_COMMAND</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function log_command()</span><br><span class="line">&#123;</span><br><span class="line">    echo $(date) $USER $$ $PPID $PWD \"$BASH_COMMAND\" &gt;&gt; /tmp/bash_logger.log</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unset PROMPT_COMMAND</span><br><span class="line"></span><br><span class="line">trap 'log_command' DEBUG</span><br></pre></td></tr></table></figure>
<p>为了让每个bash都能生效，在<code>/etc/bashrc</code>文件末尾增加一行<code>. /etc/bash_logger.sh</code>，这样在默认配置下每一个交互式bash都会加载新增的文件（除非通过参数指定bash不加载配置文件）。</p>
<ul>
<li>login bash的加载路径是<code>~/.bash_profile</code> 加载 <code>~/.bashrc</code> 加载 <code>/etc/bashrc</code>。</li>
<li>non-login bash的加载路径是<code>~/bashrc</code> 加载 <code>/etc/bashrc</code>。</li>
</ul>
<h2 id="非交互式bash记录命令"><a href="#非交互式bash记录命令" class="headerlink" title="非交互式bash记录命令"></a>非交互式bash记录命令</h2><p>上一个例子里可以记录到交互式bash中调用的命令，那么再试一下通过bash执行的脚本文件是否可以记录到脚本文件内调用的命令，结果是无法记录。因为trap只能影响到当前bash，通过<code>bash SCRIPT_NAME</code>和<code>bash -c COMMAND</code>会启动一个子进程，执行非交互式bash，不会加载之前准备的配置文件。</p>
<p><a href="/2019/08/20/bash-invocation/#配置加载">之前</a>说过非交互式bash会检查环境变量<code>BASH_ENV</code>并尝试加载其指定的文件。因此在配置文件中再增加<code>BASH_ENV</code>环境变量。</p>
<figure class="highlight shell"><figcaption><span>增加 BASH_ENV 环境变量</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function log_command()</span><br><span class="line">&#123;</span><br><span class="line">    echo $(date) $USER $$ $PPID $PWD \"$BASH_COMMAND\" &gt;&gt; /tmp/bash_logger.log</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unset PROMPT_COMMAND</span><br><span class="line">export BASH_ENV="/etc/bash_logger.sh"</span><br><span class="line"></span><br><span class="line">trap 'log_command' DEBUG</span><br></pre></td></tr></table></figure>
<p>重启一个bash，验证一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[huyu@localhost ~]$ cat t.sh</span><br><span class="line">echo 1</span><br><span class="line">echo 2</span><br><span class="line">[huyu@localhost ~]$ bash t.sh</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">[huyu@localhost ~]$</span><br></pre></td></tr></table></figure>
<p>看看日志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[huyu@localhost ~]$ tail -n0 -f /tmp/bash_logger.log</span><br><span class="line">Mon Aug 26 20:58:55 CST 2019 huyu 12358 1589 /home/huyu &quot;cat t.sh&quot;</span><br><span class="line">Mon Aug 26 20:58:56 CST 2019 huyu 12358 1589 /home/huyu &quot;bash t.sh&quot;</span><br><span class="line">Mon Aug 26 20:58:56 CST 2019 huyu 12456 12358 /home/huyu &quot;echo 1&quot;</span><br><span class="line">Mon Aug 26 20:58:56 CST 2019 huyu 12456 12358 /home/huyu &quot;echo 2&quot;</span><br></pre></td></tr></table></figure>
<h2 id="bash函数内部记录命令"><a href="#bash函数内部记录命令" class="headerlink" title="bash函数内部记录命令"></a>bash函数内部记录命令</h2><p>修改一下之前的脚本<code>t.sh</code>，再执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[huyu@localhost ~]$ cat t.sh</span><br><span class="line">function echo_more()</span><br><span class="line">&#123;</span><br><span class="line">    echo 1</span><br><span class="line">    echo 2</span><br><span class="line">&#125;</span><br><span class="line">echo_more</span><br><span class="line">[huyu@localhost ~]$ bash t.sh</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>日志中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[huyu@localhost ~]$ tail -n0 -f /tmp/bash_logger.log</span><br><span class="line">Tue Aug 26 21:33:53 CST 2019 huyu 13457 1589 /home/huyu &quot;cat t.sh&quot;</span><br><span class="line">Tue Aug 26 21:33:59 CST 2019 huyu 13457 1589 /home/huyu &quot;bash t.sh&quot;</span><br><span class="line">Tue Aug 26 21:33:59 CST 2019 huyu 13496 13457 /home/huyu &quot;echo_more&quot;</span><br></pre></td></tr></table></figure>
<p>可以看到没有函数内部的调用记录。想要这部分记录也很简单，在配置文件中增加一行<code>set -o functrace</code>，参考<code>man set</code>，<code>man bash</code>。</p>
<figure class="highlight shell"><figcaption><span>最终/etc/bash_logger.sh</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function log_command()</span><br><span class="line">&#123;</span><br><span class="line">    echo $(date) $USER $$ $PPID $PWD \"$BASH_COMMAND\" &gt;&gt; /tmp/bash_logger.log</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unset PROMPT_COMMAND</span><br><span class="line">export BASH_ENV=/etc/bash_logger.sh</span><br><span class="line"></span><br><span class="line">set -o functrace</span><br><span class="line"></span><br><span class="line">trap 'log_command' DEBUG</span><br></pre></td></tr></table></figure>
<h2 id="将sh切换为bash"><a href="#将sh切换为bash" class="headerlink" title="将sh切换为bash"></a>将sh切换为bash</h2><p>到现在bash的命令记录基本完成了，但如果调用sh开启一个新shell或通过sh执行一个脚本，还是无法记录到后续命令。这里不想关心sh的配置加载和trap相关了，把sh替换为bash就可以了，但centos 7.5下sh本身就是bash的软链，通过启动的命令参数判断执行逻辑。因此需要做的稍微多一点。</p>
<p>准备一段代码</p>
<figure class="highlight c"><figcaption><span>main.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *login_bash = <span class="string">"-bash"</span>;</span><br><span class="line">    <span class="keyword">char</span> *nologin_bash = <span class="string">"bash"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">        argv[<span class="number">0</span>] = login_bash;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        argv[<span class="number">0</span>] = nologin_bash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    execve(<span class="string">"/usr/bin/bash"</span>, argv, envp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译，<code>gcc main.c</code></p>
<p>删除sh的软链，替换为刚编译生成的可执行文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rm /bin/sh</span><br><span class="line">sudo cp a.out /bin/sh</span><br></pre></td></tr></table></figure>
<p>现在sh也不是问题了。</p>
<h2 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h2><p>经过上面的步骤，已经可以记录bash和sh调用的所有命令了，但是由于linux中大量使用shell做一些辅助工作，因此很多时候会有大量冗余的调用记录。比如执行一下<code>man bash</code>，就会在日志文件中看到数十行调用记录，这里可以通过增加白名单的方式把明显无害的调用排除出记录范围。</p>
</div><div class="tags"><a href="/tags/linux/">linux</a></div><div class="post-nav"><a class="pre" href="/2019/11/16/libpcap-cutoff-captured-packet/">libpcap在libvirt虚拟化环境下捕获数据包不完整的一种情况分析</a><a class="next" href="/2019/08/20/bash-invocation/">bash 调用方式与配置文件</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://www.hyuuhit.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/libvirt/">libvirt</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/suricata/">suricata</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/vmware/" style="font-size: 15px;">vmware</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2024/04/29/memory-consistency-model-memory-barrier-and-sychronization/">内存一致性模型、内存屏障与同步</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/04/11/rcu-usage/">抢占式RCU与RCU使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/09/16/tc-tbf-qdisc/">tc tbf qdisc</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/08/function-call-stack/">gdb查看寄存器及内存数据与函数调用栈分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/16/libpcap-cutoff-captured-packet/">libpcap在libvirt虚拟化环境下捕获数据包不完整的一种情况分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/27/bash-audit/">一种简单的bash审计方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/20/bash-invocation/">bash 调用方式与配置文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/17/uriparser/">uriparser 解析处理URI</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/06/noblock-rabbitmq-c/">rabbitmq-c 非阻塞订阅</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/20/libyaml/">libyaml 解析配置文件</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">属乌鸦的.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>