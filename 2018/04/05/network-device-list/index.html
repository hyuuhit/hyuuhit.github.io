<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="hu yu's blog | Android | 服务端"><title>获取网卡列表的几种方式 | 属乌鸦的</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-129648993-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '85d80db9310fa34ab2f7d34beeff589b';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">获取网卡列表的几种方式</h1><a id="logo" href="/.">属乌鸦的</a><p class="description">无知 &amp; 聒噪</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">获取网卡列表的几种方式</h1><div class="post-meta">Apr 5, 2018</div><div class="post-content"><p>这里介绍可以列举网卡设备的三种方式:</p>
<ul>
<li>ioctl<br>通过ioctl系统调用的SIOCGIFCONF请求获取网卡名，通过SIOCGIFINDEX请求获取网卡唯一索引。</li>
<li>getifaddrs<br>这个函数可以返回网卡的信息和地址，区分协议族，也就是每个网卡名在返回数据中可能存在多次。这个函数的实现上依赖rtnetlink。</li>
<li>rtnetlink<br>通过netlink与内核交互，功能强大且多样，获取网卡信息只是其非常小的一个功能，参考iproute2工具包的代码实现。</li>
</ul>
<h2 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h2><p>linux支持一些标准ioctl系统调用配置网卡设备。可以通过任意socket文件描述符使用这种方式以配置网卡设备，与socket的协议族和类型无关。以下内容参考<code>man netdevice</code>。</p>
<p>通过ioctl操作网卡设备需要认识两个数据结构。</p>
<figure class="highlight c"><figcaption><span>更多内容参考 man page</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ifr_name[IFNAMSIZ]; <span class="comment">/* Interface name */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">ifr_addr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">ifr_dstaddr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">ifr_broadaddr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">ifr_netmask</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">ifr_hwaddr</span>;</span></span><br><span class="line">        <span class="keyword">short</span>           ifr_flags;</span><br><span class="line">        <span class="keyword">int</span>             ifr_ifindex;</span><br><span class="line">        <span class="keyword">int</span>             ifr_metric;</span><br><span class="line">        <span class="keyword">int</span>             ifr_mtu;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ifmap</span>    <span class="title">ifr_map</span>;</span></span><br><span class="line">        <span class="keyword">char</span>            ifr_slave[IFNAMSIZ];</span><br><span class="line">        <span class="keyword">char</span>            ifr_newname[IFNAMSIZ];</span><br><span class="line">        <span class="keyword">char</span>           *ifr_data;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   ifreq结构是调用参数的主要结构，大部分请求填充ifr_name以标识需要操作的网卡。</span></span><br><span class="line"><span class="comment">   其他成员是一个联合体共享内存空间，每次只有一个有意义，通过请求类型决定使用的成员。</span></span><br><span class="line"><span class="comment">   特殊情况是SIOCGIFNAME请求，这个请求填充ifr_index，由内核填充ifr_name并返回。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ifconf</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>                 ifc_len; <span class="comment">/* size of buffer */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">char</span>           *ifc_buf; <span class="comment">/* buffer address */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span>   *<span class="title">ifc_req</span>;</span> <span class="comment">/* array of structures */</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   ifconf结构用在SIOCGIFCONF请求，这个请求的作用是获取网卡地址的列表，同时会填充网卡名。</span></span><br><span class="line"><span class="comment">   ifc_buf和ifc_req实际上指向的是同一个地址，只是省去了类型转换。</span></span><br><span class="line"><span class="comment">   ifc_len标识了可用的ifc_buf的字节长度，请求返回后ifc_len标识了内核填充的有效的字节长度。</span></span><br><span class="line"><span class="comment">   SIOCGIFCONF请求的局限性在于，只能够获取具有ipv4地址的网卡。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>通过ioctl获取网卡名和唯一索引的示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifconf</span> <span class="title">ifc</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">10240</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> *<span class="title">ifr</span>;</span></span><br><span class="line"></span><br><span class="line">    fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"socket failed, %s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bzero(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    ifc.ifc_len = <span class="keyword">sizeof</span>(buf);</span><br><span class="line">    ifc.ifc_req= (<span class="keyword">void</span> *)&amp;buf;</span><br><span class="line"></span><br><span class="line">    ret = ioctl(fd, SIOCGIFCONF, &amp;ifc);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"SIOCGIFCONF failed, %s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ifc.ifc_len == <span class="keyword">sizeof</span>(buf)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"buf overflow\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ifr = ifc.ifc_req;</span><br><span class="line">    <span class="keyword">while</span>((<span class="keyword">char</span> *)ifr &lt; buf + ifc.ifc_len) &#123;</span><br><span class="line"></span><br><span class="line">        ret = ioctl(fd, SIOCGIFINDEX, ifr);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"SIOCGIFINDEX failed, %s\n"</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s index %d\n"</span>, ifr-&gt;ifr_name, ifr-&gt;ifr_ifindex);</span><br><span class="line">        ifr ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我的测试环境输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lo index 1</span><br><span class="line">eno16780032 index 2</span><br></pre></td></tr></table></figure></p>
<h2 id="getifaddrs"><a href="#getifaddrs" class="headerlink" title="getifaddrs"></a>getifaddrs</h2><p>这个函数使用上很简单，通过输入一个二级指针，函数内部会调用rtnetlink获取网卡数据并分配内存组织数据，将输入指针指向分配的内存，因此在使用结束后需要手动调用freeifaddrs以释放内存。参考<code>man getifaddrs</code>。</p>
<figure class="highlight c"><figcaption><span>函数原型及结构体</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getifaddrs</span><span class="params">(struct ifaddrs **ifap)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeifaddrs</span><span class="params">(struct ifaddrs *ifa)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ifaddrs</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifaddrs</span>  *<span class="title">ifa_next</span>;</span>    <span class="comment">/* Next item in list */</span></span><br><span class="line">    <span class="keyword">char</span>            *ifa_name;    <span class="comment">/* Name of interface */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>     ifa_flags;   <span class="comment">/* Flags from SIOCGIFFLAGS */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">ifa_addr</span>;</span>    <span class="comment">/* Address of interface */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">ifa_netmask</span>;</span> <span class="comment">/* Netmask of interface */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">ifu_broadaddr</span>;</span></span><br><span class="line">        <span class="comment">/* Broadcast address of interface */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">ifu_dstaddr</span>;</span></span><br><span class="line">        <span class="comment">/* Point-to-point destination address */</span></span><br><span class="line">    &#125; ifa_ifu;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>              ifa_broadaddr ifa_ifu.ifu_broadaddr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>              ifa_dstaddr   ifa_ifu.ifu_dstaddr</span></span><br><span class="line">    <span class="keyword">void</span>            *ifa_data;    <span class="comment">/* Address-specific data */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   ifa_next 填充数据是一个链表，通过ifa_next成员链接。</span></span><br><span class="line"><span class="comment">   ifa_name 网卡名</span></span><br><span class="line"><span class="comment">   ifa_addr 通用的网络地址类型，可以通过读取sa_family判断地址类型再转换为对应</span></span><br><span class="line"><span class="comment">            结构体类型后读取详细信息，比如AF_INET对应sockaddr_in，AF_PACKET对应sockaddr_ll。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>示例代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ifaddrs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifaddrs</span> *<span class="title">ifa</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifaddrs</span> *<span class="title">ifap</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">addr</span>;</span></span><br><span class="line"></span><br><span class="line">    ret = getifaddrs(&amp;ifa);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"getifaddrs failed, %s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ifap = ifa;</span><br><span class="line"></span><br><span class="line">    fd = socket(AF_INET, SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"socket failed, %s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (ifap != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        addr = ifap-&gt;ifa_addr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">strcpy</span>(ifr.ifr_name, ifap-&gt;ifa_name);</span><br><span class="line">        ret = ioctl(fd, SIOCGIFINDEX, &amp;ifr);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"SIOCGIFINDEX failed, %s\n"</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%20s    sa_family %4u, index %d\n"</span>, ifap-&gt;ifa_name, addr-&gt;sa_family, ifr.ifr_ifindex);</span><br><span class="line"></span><br><span class="line">        ifap = ifap-&gt;ifa_next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    freeifaddrs(ifa);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我测测试环境输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">         lo    sa_family   17, index 1</span><br><span class="line">eno16780032    sa_family   17, index 2</span><br><span class="line">eno33559296    sa_family   17, index 3</span><br><span class="line">         lo    sa_family    2, index 1</span><br><span class="line">eno16780032    sa_family    2, index 2</span><br><span class="line">         lo    sa_family   10, index 1</span><br><span class="line">eno16780032    sa_family   10, index 2</span><br><span class="line">eno33559296    sa_family   10, index 3</span><br></pre></td></tr></table></figure></p>
<h2 id="rtnetlink"><a href="#rtnetlink" class="headerlink" title="rtnetlink"></a>rtnetlink</h2><p>rtnetlink是一种socket，是netlink的一个族，用于处理读写路由相关操作、网卡相关操作、以及其他操作，具体参考<code>man 7 rtnetlink</code>。</p>
<p>netlink是一种socket，用于内核和用户空间交互，创建一个netlink socket的方式是<code>netlink_socket = socket(AF_NETLINK, socket_type, netlink_family);</code>，更多信息参考<code>man 7 netlink</code>。</p>
<ul>
<li>AF_NETLINK<br>个人觉得更应该使用PF_NETLINK，表示使用netlink协议族。由于在实现上每个协议族仅对应一个地址族，这里PF_NETLINK值等于AF_NETLINK，因此两个在值上可以互换使用。</li>
<li>socket_type<br>可以使用SOCK_RAW和SOCK_DGRAM，这两者在netlink协议使用上无任何区别。</li>
<li>netlink_family<br>有一组可以取的值，使用NETLINK_ROUTE将创建一个rtnetlink。</li>
</ul>
<p>每个netlink消息都包含一个或多个消息头和载荷<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* netlink消息头结构体 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> &#123;</span></span><br><span class="line">    __u32 nlmsg_len;    <span class="comment">/* Length of message including header. */</span></span><br><span class="line">    __u16 nlmsg_type;   <span class="comment">/* Type of message content. */</span></span><br><span class="line">    __u16 nlmsg_flags;  <span class="comment">/* Additional flags. */</span></span><br><span class="line">    __u32 nlmsg_seq;    <span class="comment">/* Sequence number. */</span></span><br><span class="line">    __u32 nlmsg_pid;    <span class="comment">/* Sender port ID. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对netlink消息的访问要求使用几个特定的宏，可在/usr/include/linux/netlink.h中查看其实现 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Round the length of a netlink message up to align it properly.</span></span><br><span class="line"><span class="comment">   将netlink消息向上对齐到一个合适的值。可以不直接使用这个宏。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NLMSG_ALIGN</span><span class="params">(<span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Given the payload length, len, this macro returns the aligned length to store </span></span><br><span class="line"><span class="comment">   in the nlmsg_len field of the nlmsghdr.</span></span><br><span class="line"><span class="comment">   输入载荷的大小，返回可以填入nsmsg_len的大小（因为消息头需要做对齐）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NLMSG_LENGTH</span><span class="params">(<span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the number of bytes that a netlink message with payload of len would occupy.</span></span><br><span class="line"><span class="comment">   输入载荷的大小，返回整个netlink消息需要占据的空间大小（因为消息头和整个消息都需要做对齐）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NLMSG_SPACE</span><span class="params">(<span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return a pointer to the payload associated with the passed nlmsghdr.</span></span><br><span class="line"><span class="comment">   输入消息头，返回载荷数据开始位置的指针（因为消息头需要对齐）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">NLMSG_DATA</span><span class="params">(struct nlmsghdr *nlh)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the next nlmsghdr in a multipart message.  The caller must check if the current nlmsghdr </span></span><br><span class="line"><span class="comment">   didn't have the NLMSG_DONE set—this function doesn't return NULL on end.</span></span><br><span class="line"><span class="comment">   The len argument is an lvalue containing the remaining length of the message buffer.  </span></span><br><span class="line"><span class="comment">   This macro decrements it by the length of the message header.</span></span><br><span class="line"><span class="comment">   输入当前消息头和记录剩余缓冲区长度的变量，返回下一个消息头的指针。（这里需要检查当前消息头的</span></span><br><span class="line"><span class="comment">   nlmsg_type是不是NLMSG_DONE，如果是的话表示这个消息是结束消息，自身及后续都不再存在有效载荷。</span></span><br><span class="line"><span class="comment">   输入的第二个变量将由此宏减去适当的值，不需要人为再修改该变量）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function">struct nlmsghdr *<span class="title">NLMSG_NEXT</span><span class="params">(struct nlmsghdr *nlh, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return true if the netlink message is not truncated and is in a form suitable for parsing.</span></span><br><span class="line"><span class="comment">   输入当前消息头和记录剩余缓冲区的长度，如果消息没有被截断将返回true表示可以被正确解析</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NLMSG_OK</span><span class="params">(struct nlmsghdr *nlh, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the length of the payload associated with the nlmsghdr.</span></span><br><span class="line"><span class="comment">   由于nlmsghdr后根据不同的请求类型会跟随一个不同的结构体，真正的载荷在两层结构体后。</span></span><br><span class="line"><span class="comment">   因此这个宏用于封装其他的宏，比如</span></span><br><span class="line"><span class="comment">   #define IFLA_RTA(r)  ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct ifinfomsg))))</span></span><br><span class="line"><span class="comment">   #define IFLA_PAYLOAD(n) NLMSG_PAYLOAD(n,sizeof(struct ifinfomsg))</span></span><br><span class="line"><span class="comment">   结合后面的内容就容易理解IFLA_PAYLOAD这个宏拿到了后续载荷的长度，IFLA这个宏拿到了后续载荷的指针</span></span><br><span class="line"><span class="comment">   （其中r是后面介绍的ifinfomsg结构的指针）。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NLMSG_PAYLOAD</span><span class="params">(struct nlmsghdr *nlh, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#define NLMSG_ALIGNTO   4U</span></span><br><span class="line"><span class="comment">#define NLMSG_ALIGN(len) ( ((len)+NLMSG_ALIGNTO-1) &amp; ~(NLMSG_ALIGNTO-1) )</span></span><br><span class="line"><span class="comment">#define NLMSG_HDRLEN     ((int) NLMSG_ALIGN(sizeof(struct nlmsghdr)))</span></span><br><span class="line"><span class="comment">#define NLMSG_LENGTH(len) ((len) + NLMSG_HDRLEN)</span></span><br><span class="line"><span class="comment">#define NLMSG_SPACE(len) NLMSG_ALIGN(NLMSG_LENGTH(len))</span></span><br><span class="line"><span class="comment">#define NLMSG_DATA(nlh)  ((void*)(((char*)nlh) + NLMSG_LENGTH(0)))</span></span><br><span class="line"><span class="comment">#define NLMSG_NEXT(nlh,len)  ((len) -= NLMSG_ALIGN((nlh)-&gt;nlmsg_len), \</span></span><br><span class="line"><span class="comment">    (struct nlmsghdr*)(((char*)(nlh)) + NLMSG_ALIGN((nlh)-&gt;nlmsg_len)))</span></span><br><span class="line"><span class="comment">#define NLMSG_OK(nlh,len) ((len) &gt;= (int)sizeof(struct nlmsghdr) &amp;&amp; \</span></span><br><span class="line"><span class="comment">    (nlh)-&gt;nlmsg_len &gt;= sizeof(struct nlmsghdr) &amp;&amp; \</span></span><br><span class="line"><span class="comment">    (nlh)-&gt;nlmsg_len &lt;= (len))</span></span><br><span class="line"><span class="comment">#define NLMSG_PAYLOAD(nlh,len) ((nlh)-&gt;nlmsg_len - NLMSG_SPACE((len)))</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<p>struct nlmsghdr结构体成员如下：</p>
<ul>
<li>nlmsg_len<br>包含了netlink消息头和数据载荷的长度。但是并不等于整个消息所占用的空间，因为整个消息占据的空间需要做对齐。</li>
<li>nlmsg_type<br>netlink消息的类型，可能是标准netlink消息，比如NLMSG_DONE表示结束、NLMSG_ERROR表示出错、NLMSG_NOOP可以忽略，也可以根据创建socket时最后一个参数可能使用该族所定义的消息类型，比如rtnetlink会使用RTM_NEWLINK、RTM_DELLINK、RTM_GETLINK。</li>
<li><p>nlmsg_flags</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Standard flag bits in nlmsg_flags</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────</span><br><span class="line">NLM_F_REQUEST   Must be set on all request messages.</span><br><span class="line">NLM_F_MULTI     The message is part  of  a  multipart  message  terminated  by</span><br><span class="line">NLMSG_DONE.</span><br><span class="line">NLM_F_ACK       Request for an acknowledgment on success.</span><br><span class="line">NLM_F_ECHO      Echo this request.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Additional flag bits for GET requests</span><br><span class="line">───────────────────────────────────────────────────────────────────────────</span><br><span class="line">NLM_F_ROOT     Return the complete table instead of a single entry.</span><br><span class="line">NLM_F_MATCH    Return all entries matching criteria passed in message con‐</span><br><span class="line">tent.  Not implemented yet.</span><br><span class="line">NLM_F_ATOMIC   Return an atomic snapshot of the table.</span><br><span class="line">NLM_F_DUMP     Convenience macro; equivalent to (NLM_F_ROOT|NLM_F_MATCH).</span><br><span class="line"></span><br><span class="line">Note that NLM_F_ATOMIC requires the CAP_NET_ADMIN capability or an effective UID of 0.</span><br><span class="line"></span><br><span class="line">Additional flag bits for NEW requests</span><br><span class="line">────────────────────────────────────────────────────────────</span><br><span class="line">NLM_F_REPLACE   Replace existing matching object.</span><br><span class="line">NLM_F_EXCL      Don&apos;t replace if the object already exists.</span><br><span class="line">NLM_F_CREATE    Create object if it doesn&apos;t already exist.</span><br><span class="line">NLM_F_APPEND    Add to the end of the object list.</span><br></pre></td></tr></table></figure>
</li>
<li><p>nlmsg_seq<br>用于追踪消息，细节参考<code>man 7 netlink</code></p>
</li>
<li>nlmsg_pid<br>用于追踪消息，细节参考<code>man 7 netlink</code></li>
</ul>
<figure class="highlight c"><figcaption><span>在一些api中需要使用sockaddr结构指针，可将netlink地址结构体指针做强制类型转换，如下</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>     nl_family;  <span class="comment">/* AF_NETLINK */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  nl_pad;     <span class="comment">/* Zero. */</span></span><br><span class="line">    <span class="keyword">pid_t</span>           nl_pid;     <span class="comment">/* Port ID. */</span></span><br><span class="line">    __u32           nl_groups;  <span class="comment">/* Multicast groups mask. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里我们的目的是获取网卡信息，因此发送请求的nlmsg_type设置为RTM_GETLINK，接收到的消息在nlmsghdr的载荷头部将是一个<code>struct ifinfomsg</code>的结构体，这个结构体后面是一组<code>struct rtattr</code>结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ifinfomsg</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>  ifi_family; <span class="comment">/* AF_UNSPEC */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> ifi_type;   <span class="comment">/* Device type */</span></span><br><span class="line">    <span class="keyword">int</span>            ifi_index;  <span class="comment">/* Interface index */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>   ifi_flags;  <span class="comment">/* Device flags  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>   ifi_change; <span class="comment">/* change mask */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   ifi_type     标识了设备的类型，类型记录在/usr/include/linux/if_arp.h中，</span></span><br><span class="line"><span class="comment">                比如ARPHRD_ETHER值为1，ARPHRD_LOOPBACK值为772。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   ifi_index    网卡设备的唯一索引号。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   ifi_flags    标识了网卡设备的状态，各状态定义在/usr/include/linux/if.h中，</span></span><br><span class="line"><span class="comment">                比如IFF_UP为1&lt;&lt;0，IFF_LOOPBACK为1&lt;&lt;3。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>rtattr结构体记录了rtnetlink的属性信息。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtattr</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> rta_len;    <span class="comment">/* Length of option */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> rta_type;   <span class="comment">/* Type of option */</span></span><br><span class="line">    <span class="comment">/* Data follows */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   rta_type     标识了网卡设备的某种类型属性，定义在/usr/include/linux/if_link.h中，</span></span><br><span class="line"><span class="comment">                比如IFLA_IFNAME表示网卡接口名。</span></span><br><span class="line"><span class="comment">   */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>rtattr结构体需要通过这些宏来操作，参考 man 3 rtnetlink。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   returns true if rta points to a valid routing attribute; attrlen is </span></span><br><span class="line"><span class="comment">   the running length of the attribute buffer.  </span></span><br><span class="line"><span class="comment">   When not true then you must assume there are no more attributes </span></span><br><span class="line"><span class="comment">   in the message, even if attrlen is nonzero.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RTA_OK</span><span class="params">(struct rtattr *rta, <span class="keyword">int</span> rtabuflen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   returns a pointer to the start of this attribute's data.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">RTA_DATA</span><span class="params">(struct rtattr *rta)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   returns the length of this attribute's data.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">RTA_PAYLOAD</span><span class="params">(struct rtattr *rta)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   gets the next attribute after rta.  Calling this macro will update attrlen.</span></span><br><span class="line"><span class="comment">   You should use RTA_OK to check the validity of the returned pointer.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function">struct rtattr *<span class="title">RTA_NEXT</span><span class="params">(struct rtattr *rta, <span class="keyword">unsigned</span> <span class="keyword">int</span> rtabuflen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   returns the length which is required for len bytes of data plus the header.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">RTA_LENGTH</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   returns the amount of space which will be needed in a message with len bytes of data.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">RTA_SPACE</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   这些宏在/usr/include/linux/rtnetlink.h</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#define RTA_ALIGNTO 4</span></span><br><span class="line"><span class="comment">#define RTA_ALIGN(len) ( ((len)+RTA_ALIGNTO-1) &amp; ~(RTA_ALIGNTO-1) )</span></span><br><span class="line"><span class="comment">#define RTA_OK(rta,len) ((len) &gt;= (int)sizeof(struct rtattr) &amp;&amp; \</span></span><br><span class="line"><span class="comment">    (rta)-&gt;rta_len &gt;= sizeof(struct rtattr) &amp;&amp; \</span></span><br><span class="line"><span class="comment">    (rta)-&gt;rta_len &lt;= (len))</span></span><br><span class="line"><span class="comment">#define RTA_NEXT(rta,attrlen)   ((attrlen) -= RTA_ALIGN((rta)-&gt;rta_len), \</span></span><br><span class="line"><span class="comment">    (struct rtattr*)(((char*)(rta)) + RTA_ALIGN((rta)-&gt;rta_len)))</span></span><br><span class="line"><span class="comment">#define RTA_LENGTH(len) (RTA_ALIGN(sizeof(struct rtattr)) + (len))</span></span><br><span class="line"><span class="comment">#define RTA_SPACE(len)  RTA_ALIGN(RTA_LENGTH(len))</span></span><br><span class="line"><span class="comment">#define RTA_DATA(rta)   ((void*)(((char*)(rta)) + RTA_LENGTH(0)))</span></span><br><span class="line"><span class="comment">#define RTA_PAYLOAD(rta) ((int)((rta)-&gt;rta_len) - RTA_LENGTH(0))</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>标准输出打印网卡名和唯一索引号的例子代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/rtnetlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">testreq</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> if_family;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">20480</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1048576</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> <span class="title">nh</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ifinfomsg</span> <span class="title">msg</span>;</span></span><br><span class="line">    &#125; req;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line">    fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"socket failed, %s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &amp;len, <span class="keyword">sizeof</span>(len));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"setsockopt failed, %s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    addr.nl_family = AF_NETLINK;</span><br><span class="line">    ret = bind(fd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"bind failed, %s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bzero(&amp;ret, <span class="keyword">sizeof</span>(ret));</span><br><span class="line">    req.nh.nlmsg_len = NLMSG_ALIGN(<span class="keyword">sizeof</span>(req));</span><br><span class="line">    req.nh.nlmsg_type = RTM_GETLINK;</span><br><span class="line">    req.nh.nlmsg_flags = NLM_F_ROOT | NLM_F_REQUEST;</span><br><span class="line">    req.nh.nlmsg_pid = <span class="number">0</span>;</span><br><span class="line">    req.nh.nlmsg_seq = <span class="number">0</span>;</span><br><span class="line">    req.msg.ifi_family = AF_UNSPEC;</span><br><span class="line"></span><br><span class="line">    ret = send(fd, &amp;req, <span class="keyword">sizeof</span>(req), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"send failed, %s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    iov.iov_base = buf;</span><br><span class="line">    iov.iov_len = <span class="keyword">sizeof</span>(buf);</span><br><span class="line">    msg.msg_name = &amp;addr;</span><br><span class="line">    msg.msg_namelen = <span class="keyword">sizeof</span>(addr);</span><br><span class="line">    msg.msg_iov = &amp;iov;</span><br><span class="line">    msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> found = <span class="number">0</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nh</span>;</span></span><br><span class="line">        ret = recvmsg(fd, &amp;msg, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR || errno == EAGAIN)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"recvmsg failed, %s\n"</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"recv EOF\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nh = (struct nlmsghdr *)buf;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(NLMSG_OK(nh, ret)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nh-&gt;nlmsg_type == NLMSG_DONE) &#123;</span><br><span class="line">                found = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nh-&gt;nlmsg_type == NLMSG_ERROR) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"NLMSG_ERROR\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printf("nlmsg type %hu, seq %u, pid %u\n", nh-&gt;nlmsg_type, nh-&gt;nlmsg_seq, nh-&gt;nlmsg_pid);</span></span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ifinfomsg</span> *<span class="title">ifi</span> = <span class="title">NLMSG_DATA</span>(<span class="title">nh</span>);</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">rtattr</span> *<span class="title">rta</span> = <span class="title">IFLA_RTA</span>(<span class="title">ifi</span>);</span></span><br><span class="line">            <span class="keyword">int</span> payload_len = IFLA_PAYLOAD(nh);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            printf("ifi_family %u\n", ifi-&gt;ifi_family);</span></span><br><span class="line"><span class="comment">            printf("ifi_type   %u\n", ifi-&gt;ifi_type);</span></span><br><span class="line"><span class="comment">            printf("ifi_index  %d\n", ifi-&gt;ifi_index);</span></span><br><span class="line"><span class="comment">            printf("ifi_flags  %x\n", ifi-&gt;ifi_flags);</span></span><br><span class="line"><span class="comment">            printf("ifi_change %x\n", ifi-&gt;ifi_change);</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(RTA_OK(rta, payload_len)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rta-&gt;rta_type == IFLA_IFNAME) &#123;</span><br><span class="line">                    <span class="keyword">char</span> *ifname = RTA_DATA(rta);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%s    index %d\n"</span>, ifname, ifi-&gt;ifi_index);</span><br><span class="line">                &#125;</span><br><span class="line">                rta = RTA_NEXT(rta, payload_len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nh = NLMSG_NEXT(nh, ret);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (found) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我的测试环境输出如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lo    index 1</span><br><span class="line">eno16780032    index 2</span><br><span class="line">eno33559296    index 3</span><br></pre></td></tr></table></figure></p>
</div><div class="tags"><a href="/tags/linux/">linux</a></div><div class="post-nav"><a class="pre" href="/2018/04/16/suricata-4-0-3-receive-decode/">suricata 4.0.3 收包解码</a><a class="next" href="/2018/03/22/suricata-4-0-3-thread-model/">suricata 4.0.3 线程模型</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://www.hyuuhit.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/libvirt/">libvirt</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/suricata/">suricata</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/vmware/" style="font-size: 15px;">vmware</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2024/05/26/dirpro-bug-analysis/">一次无源码Linux内核模块bug分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/05/13/elrepo-not-for-production-use/">为什么生产环境服务器不应该使用ELRepo内核</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/04/29/memory-consistency-model-memory-barrier-and-sychronization/">内存一致性模型、内存屏障与同步</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/04/11/rcu-usage/">抢占式RCU与RCU使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/09/16/tc-tbf-qdisc/">tc tbf qdisc 令牌桶过滤器限速队列</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/08/function-call-stack/">gdb查看寄存器及内存数据与函数调用栈分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/16/libpcap-cutoff-captured-packet/">libpcap在libvirt虚拟化环境下捕获数据包不完整的一种情况分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/27/bash-audit/">一种简单的bash审计方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/20/bash-invocation/">bash 调用方式与配置文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/17/uriparser/">uriparser 解析处理URI</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">属乌鸦的.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>