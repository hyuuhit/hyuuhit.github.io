<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="huyu's blog | Linux"><title>Linux timer 内核软件定时器 | 属乌鸦的</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-129648993-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '85d80db9310fa34ab2f7d34beeff589b';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Linux timer 内核软件定时器</h1><a id="logo" href="/.">属乌鸦的</a><p class="description">无知 &amp; 聒噪</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Linux timer 内核软件定时器</h1><div class="post-meta">Oct 17, 2018</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#timer-例子"><span class="toc-number">1.</span> <span class="toc-text">timer 例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#timer-原理"><span class="toc-number">2.</span> <span class="toc-text">timer 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#硬件定时器初始化"><span class="toc-number">2.1.</span> <span class="toc-text">硬件定时器初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#timer-初始化"><span class="toc-number">2.2.</span> <span class="toc-text">timer 初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#timer-结构体"><span class="toc-number">2.3.</span> <span class="toc-text">timer 结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tvec-base"><span class="toc-number">2.3.1.</span> <span class="toc-text">tvec_base</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#timer-list"><span class="toc-number">2.3.2.</span> <span class="toc-text">timer_list</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#timer-插入"><span class="toc-number">2.4.</span> <span class="toc-text">timer 插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#timer-激活"><span class="toc-number">2.5.</span> <span class="toc-text">timer 激活</span></a></li></ol></li></ol></div></div><div class="post-content"><p>Linux内核中提供有timer软件定时器，可配置精度为1/HZ。同时还提供有高精度软件定时器hrtimer。本文记录低精度软件定时器timer的使用及原理。</p>
<a id="more"></a>
<p>本文内容参考内核版本 3.10.0-862.el7.x86_64</p>
<h2 id="timer-例子"><a href="#timer-例子" class="headerlink" title="timer 例子"></a>timer 例子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"Hu Yu &lt;hyuuhit@gmail.com&gt;"</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"lkm test"</span>);</span><br><span class="line">MODULE_VERSION(<span class="string">"0.1"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">test_timer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timer_handler</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> timer_first = <span class="number">1</span>;</span><br><span class="line">    pr_info(<span class="string">"timer handler cpu: %d\n"</span>, smp_processor_id());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timer_first) &#123;</span><br><span class="line">        pr_info(<span class="string">"in_interrupt       %lu\n"</span>, in_interrupt());</span><br><span class="line">        pr_info(<span class="string">"in_irq             %lu\n"</span>, in_irq());</span><br><span class="line">        pr_info(<span class="string">"in_softirq         %lu\n"</span>, in_softirq());</span><br><span class="line">        pr_info(<span class="string">"in_serving_softirq %lu\n"</span>, in_serving_softirq());</span><br><span class="line">        pr_info(<span class="string">"in_atomic          %d\n"</span>, in_atomic());</span><br><span class="line"></span><br><span class="line">        dump_stack();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timer_first = <span class="number">0</span>;</span><br><span class="line">    mod_timer(&amp;test_timer, jiffies + HZ * <span class="number">1.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">my_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pr_info(<span class="string">"my init.\n"</span>);</span><br><span class="line">    pr_info(<span class="string">"smp_processor_id %d\n"</span>, smp_processor_id());</span><br><span class="line"></span><br><span class="line">    init_timer(&amp;test_timer);</span><br><span class="line"></span><br><span class="line">    test_timer.function = timer_handler;</span><br><span class="line">    <span class="comment">// 2.5秒后到期</span></span><br><span class="line">    test_timer.expires = jiffies + HZ * <span class="number">2.5</span>;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">"expires before add: %lu\n"</span>, test_timer.expires);</span><br><span class="line">    add_timer(&amp;test_timer);</span><br><span class="line">    pr_info(<span class="string">"expires after add : %lu\n"</span>, test_timer.expires);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">my_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pr_info(<span class="string">"smp_processor_id %d\n"</span>, smp_processor_id());</span><br><span class="line">    del_timer_sync(&amp;test_timer);</span><br><span class="line">    pr_info(<span class="string">"my exit.\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_init);</span><br><span class="line">module_exit(my_exit);</span><br></pre></td></tr></table></figure>
<p>更多api参考include/linux/timer.h</p>
<h2 id="timer-原理"><a href="#timer-原理" class="headerlink" title="timer 原理"></a>timer 原理</h2><p>linux内核中timer激活过程如下：</p>
<ol>
<li>每个CPU上发生本地定时器中断</li>
<li>中断服务例程调用per cpu变量时钟事件设备的event_handler函数</li>
<li>event_handler中会激活TIMER_SOFTIRQ软中断</li>
<li>软中断处理函数检查并调用到期定时器</li>
</ol>
<p>先看一下系统启动时的配置是如何将这个过程联系起来的。</p>
<h3 id="硬件定时器初始化"><a href="#硬件定时器初始化" class="headerlink" title="硬件定时器初始化"></a>硬件定时器初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">+------------+</span><br><span class="line">|start_kernel|</span><br><span class="line">+-----+------+</span><br><span class="line">      |</span><br><span class="line">      |</span><br><span class="line">      +--&gt; blabla...</span><br><span class="line">      |</span><br><span class="line">      |   +----------+</span><br><span class="line">      +---+setup_arch|</span><br><span class="line">      |   +----------+</span><br><span class="line">      |    这里与时钟相关的是调用register_refined_jiffies注册了一个时钟源refined_jiffies。</span><br><span class="line">      |</span><br><span class="line">      +--&gt; blabla...</span><br><span class="line">      |</span><br><span class="line">      |   +--------------+</span><br><span class="line">      +---+tick_nohz_init|</span><br><span class="line">      |   +--------------+</span><br><span class="line">      |    为nohz模式做初始化配置，比如分配nohz模式和housekeeping模式的cpu位图，</span><br><span class="line">      |    配置cpu donw的回调函数（比如nohz模式下负责定时器的cpu不能down）。</span><br><span class="line">      |</span><br><span class="line">      +--&gt; blabla...</span><br><span class="line">      |</span><br><span class="line">      |   +--------+</span><br><span class="line">      +---+init_IRQ|</span><br><span class="line">      |   +-+------+</span><br><span class="line">      |     |</span><br><span class="line">      |     +--&gt; blabla...</span><br><span class="line">      |     |</span><br><span class="line">      |     |   +-------------------------+</span><br><span class="line">      |     +---+ x86_init.irqs.intr_init |</span><br><span class="line">      |     |   |实际调用为native_init_IRQ|</span><br><span class="line">      |     |   +--+----------------------+</span><br><span class="line">      |     |      |</span><br><span class="line">      |     |      |    blabla...</span><br><span class="line">      |     |      |</span><br><span class="line">      |     |      |   +--------------+</span><br><span class="line">      |     |      |---+apic_intr_init|</span><br><span class="line">      |     |      |   +--------------+</span><br><span class="line">      |     |      |    为LOCAL_TIMER_VECTOR中断服务例程为apic_timer_interrupt</span><br><span class="line">      |     |      |    实际为smp_apic_timer_interrupt</span><br><span class="line">      |     |      |    这个是cpu本地定时器中断，TIMER_SOFTIRQ由这个中断激活。</span><br><span class="line">      |     |      |</span><br><span class="line">      |     |      |    blabla...</span><br><span class="line">      |     |&lt;-----+</span><br><span class="line">      |&lt;----+</span><br><span class="line">      |</span><br><span class="line">      |   +---------+</span><br><span class="line">      +---+tick_init|</span><br><span class="line">      |   +---------+</span><br><span class="line">      |    调用tick_broadcast_init分配了6个tick broadcast相关的位图。</span><br><span class="line">      |</span><br><span class="line">      |</span><br><span class="line">      |   +-------------+</span><br><span class="line">      |   |             |</span><br><span class="line">      +---+ init_timers |</span><br><span class="line">      |   |             |</span><br><span class="line">      |   +-------------+</span><br><span class="line">      |    timer软件定时器数据结构的初始化，后面详细介绍。</span><br><span class="line">      |</span><br><span class="line">      |</span><br><span class="line">      +--&gt; blabla...</span><br><span class="line">      |</span><br><span class="line">      |   +---------+</span><br><span class="line">      +---+time_init|</span><br><span class="line">      |   +---------+</span><br><span class="line">      |    体系结构相关，x86下只是把late_time_init函数指针设置为x86_late_time_init。</span><br><span class="line">      |</span><br><span class="line">      +--&gt; blabla...</span><br><span class="line">      |</span><br><span class="line">      |   +--------------+</span><br><span class="line">      +---+late_time_init|</span><br><span class="line">      |   +--+-----------+</span><br><span class="line">      |      | 实际调用函数为x86_late_time_init</span><br><span class="line">      |      |</span><br><span class="line">      |      |    +--------------------------+</span><br><span class="line">      |      +----+x86_init.timers.timer_init|</span><br><span class="line">      |      |    +--------------------------+</span><br><span class="line">      |      |     x86_init定义位于arch/x86/kernel/x86_init.c</span><br><span class="line">      |      |     实际调用函数为hpet_time_init</span><br><span class="line">      |      |     启用hpet作为时钟事件设备，并作为时钟源（global_clock_event指针设置为hpet_clockevent）。</span><br><span class="line">      |      |         如果失败的话启用精度较低的pit作为时钟事件设备。</span><br><span class="line">      |      |     启用hpet过程中hpet_clockevent-&gt;event_handler设置为tick_handle_periodic。</span><br><span class="line">      |      |     设置0号中断（定时器中断）的处理函数为timer_interrupt。</span><br><span class="line">      |      |</span><br><span class="line">      |      |    +--------+</span><br><span class="line">      |      +----+tsc_init|</span><br><span class="line">      |      |    +--------+</span><br><span class="line">      |      |     启用tsc时钟源。</span><br><span class="line">      |      |</span><br><span class="line">      |&lt;-----+</span><br><span class="line">      |      </span><br><span class="line">      +--&gt; blabla...</span><br><span class="line">      |      </span><br><span class="line">      |   +---------+</span><br><span class="line">      +---+rest_init| </span><br><span class="line">      |   +--+------+</span><br><span class="line">      |      |</span><br><span class="line">      |      |   +-----------------------+</span><br><span class="line">      |      +---|kernel_init 1号内核线程|</span><br><span class="line">      |      |   +-----------------------+</span><br><span class="line">      |      |      |</span><br><span class="line">      |      |      |   +--------------------+</span><br><span class="line">      |      |      +---+kernel_init_freeable|</span><br><span class="line">      |      |      |   +--+-----------------+</span><br><span class="line">      |      |      |      |</span><br><span class="line">      |      |      |      |    blabla...</span><br><span class="line">      |      |      |      |</span><br><span class="line">      |      |      |      |   +---------------------------------------------+</span><br><span class="line">      |      |      |      |   |smp_prepare_cpu包装了smp_ops.smp_prepare_cpus|</span><br><span class="line">      |      |      |      |   |实际调用为native_smp_prepare_cpus            |</span><br><span class="line">      |      |      |      |   +--+------------------------------------------+</span><br><span class="line">      |      |      |      |      |</span><br><span class="line">      |      |      |      |      |    blabla...</span><br><span class="line">      |      |      |      |      |</span><br><span class="line">      |      |      |      |      |   +------------------------------------+</span><br><span class="line">      |      |      |      |      +---+x86_init.timers.setup_percpu_clockev|</span><br><span class="line">      |      |      |      |      |   |  实际调用为setup_boot_APIC_clock   |</span><br><span class="line">      |      |      |      |      |   +--+---------------------------------+</span><br><span class="line">      |      |      |      |      |      |</span><br><span class="line">      |      |      |      |      |      |    blabla...</span><br><span class="line">      |      |      |      |      |      |</span><br><span class="line">      |      |      |      |      |      |   +------------------+</span><br><span class="line">      |      |      |      |      |      |   |                  |</span><br><span class="line">      |      |      |      |      |      |   | setup_APIC_timer |</span><br><span class="line">      |      |      |      |      |      |   |                  |</span><br><span class="line">      |      |      |      |      |      |   +------------------+</span><br><span class="line">      |      |      |      |      |      |    设置了当前cpu的per cpu变量lapic_events内容为lapic_clockevent</span><br><span class="line">      |      |      |      |      |      |    并注册该时钟事件设备，这里会设置event_handler为tick_handle_periodic</span><br><span class="line">      |      |      |      |      |      |</span><br><span class="line">      |      |      |      |      |      |    blabla...</span><br><span class="line">      |      |      |      |      |      |</span><br><span class="line">      |      |      |      |      |&lt;-----+</span><br><span class="line">      |      |      |      |&lt;-----+</span><br><span class="line">      |      |      |      |</span><br><span class="line">      |      |      |      |    blabla...</span><br><span class="line">      |      |      |      |</span><br><span class="line">      |      |      |      |   +--------+</span><br><span class="line">      |      |      |      +---+smp_init|</span><br><span class="line">      |      |      |      |   +--------+</span><br><span class="line">      |      |      |      |    这个流程比较长，直接列主要的调用栈吧。</span><br><span class="line">      |      |      |      |    smp_init-&gt;cpu_up(for each present cpu)-&gt;_cpu_up-&gt;__cpu_up-&gt;</span><br><span class="line">      |      |      |      |    -&gt;smp_ops.cpu_up(实际为native_cpu_up)-&gt;do_boot_cpu-&gt;</span><br><span class="line">      |      |      |      |    -&gt;wakeup_cpu_via_init_nmi(实际这里有个分支判断，暂且就当是这个吧)-&gt;</span><br><span class="line">      |      |      |      |    -&gt;wakeup_cpu_via_init-&gt;通过startup_ipi_hook调用start_secondary(没看懂，就当是吧)-&gt;</span><br><span class="line">      |      |      |      |    -&gt;x86_cpuinit.setup_percpu_clockev(实际为setup_secondary_APIC_clock)-&gt;</span><br><span class="line">      |      |      |      |</span><br><span class="line">      |      |      |      |    -&gt;setup_APIC_timer</span><br><span class="line">      |      |      |      |      又到这个函数了，解释见上文</span><br><span class="line">      |      |      |      |</span><br><span class="line">      |      |      |&lt;-----+</span><br><span class="line">      |      |      |</span><br><span class="line">      |      |      |    blabla...</span><br><span class="line">      |      |      |</span><br><span class="line">      |&lt;-----+      |</span><br><span class="line">      |             |</span><br><span class="line">      |             |</span><br><span class="line">     END         1号线程</span><br></pre></td></tr></table></figure>
<p><code>LOCAL_TIMER_VECTOR</code>（这是cpu的本地定时器中断，每个cpu都会接收）中断服务例程实际为<code>smp_apic_timer_interrupt</code>，这里我们关心的调用栈为：</p>
<p>smp_apic_timer_interrupt -&gt; local_apic_timer_interrupt -&gt; per cpu变量lapic_events成员event_handler（我们知道这是tick_handle_periodic）<br>tick_handle_periodic -&gt; tick_periodic -&gt; update_process_times -&gt; run_local_timers</p>
<p>这里激活了<code>TIMER_SOFTIRQ</code>软中断。</p>
<h3 id="timer-初始化"><a href="#timer-初始化" class="headerlink" title="timer 初始化"></a>timer 初始化</h3><p>继续看<code>init_timers</code>函数，包含了定时器相关结构的配置和软中断处理函数设置。</p>
<figure class="highlight c"><figcaption><span>init_timers</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> <span class="title">timers_nb</span> = &#123;</span></span><br><span class="line">    .notifier_call  = timer_cpu_notify,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __<span class="function">init <span class="title">init_timers</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ensure there are enough low bits for flags in timer-&gt;base pointer */</span></span><br><span class="line">    BUILD_BUG_ON(__alignof__(struct tvec_base) &amp; TIMER_FLAG_MASK);</span><br><span class="line"></span><br><span class="line">    err = timer_cpu_notify(&amp;timers_nb, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)CPU_UP_PREPARE,</span><br><span class="line">            (<span class="keyword">void</span> *)(<span class="keyword">long</span>)smp_processor_id());</span><br><span class="line">    init_timer_stats();</span><br><span class="line"></span><br><span class="line">    BUG_ON(err != NOTIFY_OK);</span><br><span class="line">    register_cpu_notifier(&amp;timers_nb);</span><br><span class="line">    open_softirq(TIMER_SOFTIRQ, run_timer_softirq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>timer_cpu_notify</code>函数第一次运行会调用<code>timer_cpu_notify</code>，并在cpu通知链上注册回调函数（依然是<code>timer_cpu_notify</code>），最后注册了<code>TIMER_SOFTIRQ</code>定时器软中断的处理函数<code>run_timer_softirq</code>。其中timer相关结构配置在<code>timer_cpu_notify</code>中，timer的运行在<code>run_timer_softirq</code>中。</p>
<figure class="highlight c"><figcaption><span>timer_cpu_notify</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">timer_cpu_notify</span><span class="params">(struct notifier_block *self,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">long</span> action, <span class="keyword">void</span> *hcpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> cpu = (<span class="keyword">long</span>)hcpu;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(action) &#123;</span><br><span class="line">        <span class="keyword">case</span> CPU_UP_PREPARE:</span><br><span class="line">        <span class="keyword">case</span> CPU_UP_PREPARE_FROZEN:</span><br><span class="line">            err = init_timers_cpu(cpu);</span><br><span class="line">            <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> notifier_from_errno(err);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HOTPLUG_CPU</span></span><br><span class="line">        <span class="keyword">case</span> CPU_DEAD:</span><br><span class="line">        <span class="keyword">case</span> CPU_DEAD_FROZEN:</span><br><span class="line">            migrate_timers(cpu);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NOTIFY_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>timer_cpu_notify</code>中，对cpu拔除通知调用函数<code>migrate_timers</code>（这个函数的作用是将拔除的cpu上的timer迁移到当前cpu上），对cpu up事件调用函数<code>init_timers_cpu</code></p>
<figure class="highlight c"><figcaption><span>init_timers_cpu</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">init_timers_cpu</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tvec_base</span> *<span class="title">base</span>;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> tvec_base_done[NR_CPUS];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!tvec_base_done[cpu]) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">char</span> boot_done;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (boot_done) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * The APs use this path later in boot</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            base = kmalloc_node(<span class="keyword">sizeof</span>(*base),</span><br><span class="line">                    GFP_KERNEL | __GFP_ZERO,</span><br><span class="line">                    cpu_to_node(cpu));</span><br><span class="line">            <span class="keyword">if</span> (!base)</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Make sure that tvec_base is 2 byte aligned */</span></span><br><span class="line">            <span class="keyword">if</span> (tbase_get_deferrable(base)) &#123;</span><br><span class="line">                WARN_ON(<span class="number">1</span>);</span><br><span class="line">                kfree(base);</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">            &#125;</span><br><span class="line">            per_cpu(tvec_bases, cpu) = base;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This is for the boot CPU - we use compile-time</span></span><br><span class="line"><span class="comment">             * static initialisation because per-cpu memory isn't</span></span><br><span class="line"><span class="comment">             * ready yet and because the memory allocators are not</span></span><br><span class="line"><span class="comment">             * initialised either.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            boot_done = <span class="number">1</span>;</span><br><span class="line">            base = &amp;boot_tvec_bases;</span><br><span class="line">        &#125;</span><br><span class="line">        spin_lock_init(&amp;base-&gt;lock);</span><br><span class="line">        tvec_base_done[cpu] = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        base = per_cpu(tvec_bases, cpu);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; TVN_SIZE; j++) &#123;</span><br><span class="line">        INIT_LIST_HEAD(base-&gt;tv5.vec + j);</span><br><span class="line">        INIT_LIST_HEAD(base-&gt;tv4.vec + j);</span><br><span class="line">        INIT_LIST_HEAD(base-&gt;tv3.vec + j);</span><br><span class="line">        INIT_LIST_HEAD(base-&gt;tv2.vec + j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; TVR_SIZE; j++)</span><br><span class="line">        INIT_LIST_HEAD(base-&gt;tv1.vec + j);</span><br><span class="line"></span><br><span class="line">    base-&gt;timer_jiffies = jiffies;</span><br><span class="line">    base-&gt;next_timer = base-&gt;timer_jiffies;</span><br><span class="line">    base-&gt;active_timers = <span class="number">0</span>;</span><br><span class="line">    base-&gt;all_timers = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中涉及两个变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tvec_base</span> <span class="title">boot_tvec_bases</span>;</span></span><br><span class="line">EXPORT_SYMBOL(boot_tvec_bases);</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_PER_CPU</span><span class="params">(struct tvec_base *, tvec_bases)</span> </span>= &amp;boot_tvec_bases;</span><br></pre></td></tr></table></figure>
<p>这里的<code>struct tvec_base</code>结构是timer定时器的挂载点，timer的生效必须要挂载到一个<code>struct tvec_base</code>上，这个结构是每个cpu独立分配一个的，这种方式避免了smp下多cpu竞争timer的情况。这个结构涉及两个变量：</p>
<ul>
<li>boot_tvec_bases<br>struct tvec_base类型的结构体，其地址也是tvec_bases指向的默认地址。</li>
<li>tvec_bases<br>struct tvec_base指针类型，这是一个per cpu变量，上面挂载了该cpu上所有等待的timer_list。由于其静态初始化为boot_tvec_bases的地址，因此在未重新赋值前，每个cpu对应的值都为该地址。简单的说，per cpu的变量自身有一个地址，但是对应多个cpu实际有多块内存区域，每块区域对应一个cpu，通过cpu id查找到对应区域的偏移量，来确定该cpu对应的变量内存，因此重要的是该变量的地址，per cpu变量自身的值只在静态初始化时有意义，一旦每个cpu的值重新修改过，该变量自身的值不再有意义。</li>
</ul>
<p><code>init_timers_cpu</code>主要作用的对传入的cpu id对应的特定cpu的tvec_bases变量做初始化。在做初始化之前首先需要确定该cpu的tvec_bases对应的地址。对于启动阶段的cpu，直接使用boot_tvec_bases的地址，其内存是在编译时静态分配的，也被静态赋值给了tvec_bases，因为启动阶段per cpu的内存并没有准备好，而且内存分配器也没有初始化完成。对于后续通知链通知的可以使用的cpu，动态分配同一numa node上的内存，并赋值给该cpu对应的tvec_bases。对于已经分配过内存的cpu，拔除cpu再上线的情况，由于使用了静态标识数组对每一个cpu的初始化做记录，只会重新初始化结构体成员，不会多次分配内存。</p>
<p>初始化部分到这里就完成了。</p>
<h3 id="timer-结构体"><a href="#timer-结构体" class="headerlink" title="timer 结构体"></a>timer 结构体</h3><p>timer定时器中，主要涉及两个结构体</p>
<ul>
<li>struct tvec_base</li>
<li>struct timer_list</li>
</ul>
<h4 id="tvec-base"><a href="#tvec-base" class="headerlink" title="tvec_base"></a>tvec_base</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * per-CPU timer vector definitions:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TVN_BITS (CONFIG_BASE_SMALL ? 4 : 6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TVR_BITS (CONFIG_BASE_SMALL ? 6 : 8)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TVN_SIZE (1 &lt;&lt; TVN_BITS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TVR_SIZE (1 &lt;&lt; TVR_BITS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TVN_MASK (TVN_SIZE - 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TVR_MASK (TVR_SIZE - 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TVAL ((unsigned long)((1ULL &lt;&lt; (TVR_BITS + 4*TVN_BITS)) - 1))</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tvec</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">vec</span>[<span class="title">TVN_SIZE</span>];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tvec_root</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">vec</span>[<span class="title">TVR_SIZE</span>];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tvec_base</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> lock;</span><br><span class="line">    <span class="comment">// 标识当前处于运行状态的定时器，在修改或删除定时器时会检查。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> *<span class="title">running_timer</span>;</span></span><br><span class="line">    <span class="comment">// 下次激活需要检查的tv1槽位由该值确定，每检查一个槽位增一，直到追上全局jiffies。</span></span><br><span class="line">    <span class="comment">// 这样可以适应timer中断间跳过多个tick的情况。</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> timer_jiffies;</span><br><span class="line">    <span class="comment">// 下面两个成员与TIMER_DEFERRABLE有关，应该与cpu睡眠省电有关，暂不关注。</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> next_timer;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> active_timers;</span><br><span class="line">    <span class="comment">// 下面5个不同层级的定时器轮。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tvec_root</span> <span class="title">tv1</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tvec</span> <span class="title">tv2</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tvec</span> <span class="title">tv3</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tvec</span> <span class="title">tv4</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tvec</span> <span class="title">tv5</span>;</span></span><br><span class="line">    RH_KABI_EXTEND(<span class="keyword">unsigned</span> <span class="keyword">long</span> all_timers)</span><br><span class="line">&#125; ____cacheline_aligned;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tvec_base</span> <span class="title">boot_tvec_bases</span>;</span></span><br><span class="line">EXPORT_SYMBOL(boot_tvec_bases);</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_PER_CPU</span><span class="params">(struct tvec_base *, tvec_bases)</span> </span>= &amp;boot_tvec_bases;</span><br></pre></td></tr></table></figure>
<p>前面说过这个结构体用于per cpu变量，每个cpu使用该结构体挂载关联的timer_list。此定时器的设计称为定时器轮（timer wheel），最近的内核中已经更改了该设计，但是本文参考的内核版本依然使用该定时器轮。</p>
<p>定时器轮在默认编译配置下对32位tick时间做分割，分为最低的8位和依次向上的4个6位，在结构体上体现就是256个哈希槽的tv1和64个哈希槽的tv2~tv5，tv1存储到期时间距离当前时间在256个tick以内的timer，tv2存储超越了tv1时间但在高6位tick时间以内到期的timer，tv3~tv5依次递增，tv5特殊一点在于如果到期时间距今超出了MAX_TVAL则依然存储在tv5中。这里tick时间体现为全局变量jiffies，这个变量记录了系统硬件定时器的tick变化，由特定的cpu负责在本地定时器中断服务例程中被更新，更新先于软件定时器timer的检查激活。</p>
<p>插入时使用到期时间距离当前时间的tick差值选择定时器轮中具体哪个轮，之后使用到期时间tick值在该轮对应位的值选择使用该轮的哪个槽位。比如</p>
<ul>
<li>假设当前tick为1000，timer到期时间为1200。距离超时还有200tick，因此选择tv1轮。1200在低8位的值为176，因此选择槽位176。</li>
<li>假设当前tick为1000，timer到期时间为1300。距离超时还有300tick，因此选择tv2轮。1300在tv2对应的6位的值为5（这里右移tv1的8位，然后用6位做掩码），因此选择槽位5。</li>
<li>假设当前tick为1000，timer到期时间为32768。距离超时还有31768tick，因此选择tv3轮。32768在tv3对应的6位的值为2（这里右移tv1的8位，再右移tv2的6位，然后用6位做掩码），因此选择槽位2。</li>
<li>有一个特殊情况是插入timer的到期时间比当前时间小，则插入到tv1中，使用成员timer_jiffies选择槽位，这样可以在最近的中断后被激活。</li>
<li>另一个特殊情况是插入timer的到期时间距离当前时间超过了MAX_TVAL，插入tv5，槽位做了一些处理，不管了。</li>
</ul>
<p>在运行时，使用成员timer_jiffies与TVR_MASK（也就是tv1对应的低8位）选择tv1的槽位，只激活tv1中对应槽位的timer。tv1中的256个槽位轮转一圈后，从tv2中选择一个槽位的timer做重新插入，这将使这些timer重新插入到tv1相应槽位中。tv2轮转一圈后，从tv3中用同样的方式选择一个槽位的timer重新插入tv1中。从上一层级级联下降插入的时机为当前层级轮转到0号槽位。这个运行模式也就是定时器轮的命名原因。</p>
<h4 id="timer-list"><a href="#timer-list" class="headerlink" title="timer_list"></a>timer_list</h4><figure class="highlight c"><figcaption><span>include/linux/timer.h中部分代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个暂不关注。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMER_DEFERRABLE        0x1LU</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这个标识记录定时器是否可以在中断中被修改或删除。</span></span><br><span class="line"><span class="comment"> * 如果这个标记存在于定时器中，表示这个定时器可能在中断中被修改或删除，</span></span><br><span class="line"><span class="comment"> * 这样在定时器函数被回调时，将保持中断关闭状态。</span></span><br><span class="line"><span class="comment"> * 如果没有这个标记，表示定时器不会再中断中被操作，这样定时器函数被回调时将会开启中断，</span></span><br><span class="line"><span class="comment"> * 这种情况如果错误的在中断中操作了定时器，可能会有引起死锁。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMER_IRQSAFE           0x2LU</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于前两个标记是借用了tvec_base地址的低二位，因此要取得正确的地址，需要将低二位掩掉。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMER_FLAG_MASK         0x3LU</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * All fields that change during normal runtime grouped to the</span></span><br><span class="line"><span class="comment">     * same cacheline</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 用于插入到tvec_base。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">    <span class="comment">// 定时器到期tick时间。</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> expires;</span><br><span class="line">    <span class="comment">// 标识归属的tvec_base，也就是对应了cpu。</span></span><br><span class="line">    <span class="comment">// 由于tvec_base做了4字节对齐，因此可以使用低2位做标记</span></span><br><span class="line">    <span class="comment">// TIMER_DEFERRABLE 和 TIMER_IRQSAFE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tvec_base</span> *<span class="title">base</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*function)(<span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录该定时器可以允许的宽限延迟tick数，如果为-1则系统会自动按比例设置允许的延迟范围做聚集。</span></span><br><span class="line">    <span class="keyword">int</span> slack;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TIMER_STATS</span></span><br><span class="line">    <span class="keyword">int</span> start_pid;</span><br><span class="line">    <span class="keyword">void</span> *start_site;</span><br><span class="line">    <span class="keyword">char</span> start_comm[<span class="number">16</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="timer-插入"><a href="#timer-插入" class="headerlink" title="timer 插入"></a>timer 插入</h3><p>以<code>add_timer</code>为例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * add_timer - start a timer</span></span><br><span class="line"><span class="comment"> * @timer: the timer to be added</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The kernel will do a -&gt;function(-&gt;data) callback from the</span></span><br><span class="line"><span class="comment"> * timer interrupt at the -&gt;expires point in the future. The</span></span><br><span class="line"><span class="comment"> * current time is 'jiffies'.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The timer's -&gt;expires, -&gt;function (and if the handler uses it, -&gt;data)</span></span><br><span class="line"><span class="comment"> * fields must be set prior calling this function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Timers with an -&gt;expires field in the past will be executed in the next</span></span><br><span class="line"><span class="comment"> * timer tick.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_timer</span><span class="params">(struct timer_list *timer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BUG_ON(timer_pending(timer));</span><br><span class="line">    mod_timer(timer, timer-&gt;expires);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(add_timer);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mod_timer - modify a timer's timeout</span></span><br><span class="line"><span class="comment"> * @timer: the timer to be modified</span></span><br><span class="line"><span class="comment"> * @expires: new timeout in jiffies</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * mod_timer() is a more efficient way to update the expire field of an</span></span><br><span class="line"><span class="comment"> * active timer (if the timer is inactive it will be activated)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * mod_timer(timer, expires) is equivalent to:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     del_timer(timer); timer-&gt;expires = expires; add_timer(timer);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that if there are multiple unserialized concurrent users of the</span></span><br><span class="line"><span class="comment"> * same timer, then mod_timer() is the only safe way to modify the timeout,</span></span><br><span class="line"><span class="comment"> * since add_timer() cannot modify an already running timer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns whether it has modified a pending timer or not.</span></span><br><span class="line"><span class="comment"> * (ie. mod_timer() of an inactive timer returns 0, mod_timer() of an</span></span><br><span class="line"><span class="comment"> * active timer returns 1.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mod_timer</span><span class="params">(struct timer_list *timer, <span class="keyword">unsigned</span> <span class="keyword">long</span> expires)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    expires = apply_slack(timer, expires);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This is a common optimization triggered by the</span></span><br><span class="line"><span class="comment">     * networking code - if the timer is re-modified</span></span><br><span class="line"><span class="comment">     * to be the same thing then just return:</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (timer_pending(timer) &amp;&amp; timer-&gt;expires == expires)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> __mod_timer(timer, expires, <span class="literal">false</span>, TIMER_NOT_PINNED);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(mod_timer);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Decide where to put the timer while taking the slack into account</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Algorithm:</span></span><br><span class="line"><span class="comment"> *   1) calculate the maximum (absolute) time</span></span><br><span class="line"><span class="comment"> *   2) calculate the highest bit where the expires and new max are different</span></span><br><span class="line"><span class="comment"> *   3) use this bit to make a mask</span></span><br><span class="line"><span class="comment"> *   4) use the bitmask to round down the maximum time, so that all last</span></span><br><span class="line"><span class="comment"> *      bits are zeros</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">inline</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">apply_slack</span><span class="params">(struct timer_list *timer, <span class="keyword">unsigned</span> <span class="keyword">long</span> expires)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> expires_limit, mask;</span><br><span class="line">    <span class="keyword">int</span> bit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timer-&gt;slack &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        expires_limit = expires + timer-&gt;slack;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> delta = expires - jiffies;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">256</span>)</span><br><span class="line">            <span class="keyword">return</span> expires;</span><br><span class="line"></span><br><span class="line">        expires_limit = expires + delta / <span class="number">256</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mask = expires ^ expires_limit;</span><br><span class="line">    <span class="keyword">if</span> (mask == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> expires;</span><br><span class="line"></span><br><span class="line">    bit = find_last_bit(&amp;mask, BITS_PER_LONG);</span><br><span class="line"></span><br><span class="line">    mask = (<span class="number">1U</span>L &lt;&lt; bit) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    expires_limit = expires_limit &amp; ~(mask);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> expires_limit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>mod_timer</code>时，调用了<code>apply_slack</code>对定时器的到期时间做了一定程度的延迟聚集。这个延迟聚集只有在<code>apply_timer</code>和<code>mod_timer</code>这两个函数中发生，其他的设置定时器的函数并不会做此操作。修改过到期时间后，其他的插入操作参考源码就很容易理解了，不做更多说明。</p>
<h3 id="timer-激活"><a href="#timer-激活" class="headerlink" title="timer 激活"></a>timer 激活</h3><p>timer在<code>TIMER_SOFTIRQ</code>软中断处理函数<code>run_timer_softirq</code>中被检查并激活，仅处理当前CPU上的timer，运行逻辑在<a href="./#tvec-base">tvec_base结构</a>中有说明。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function runs timers and the timer-tq in bottom half context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run_timer_softirq</span><span class="params">(struct softirq_action *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tvec_base</span> *<span class="title">base</span> = __<span class="title">this_cpu_read</span>(<span class="title">tvec_bases</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (time_after_eq(jiffies, base-&gt;timer_jiffies))</span><br><span class="line">        __run_timers(base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/linux/">linux</a></div><div class="post-nav"><a class="pre" href="/2018/11/08/rcu/">Linux RCU 内核同步机制</a><a class="next" href="/2018/09/18/generic-netlink/">Linux generic netlink 自定义内核通信</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://www.hyuuhit.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/libvirt/">libvirt</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/suricata/">suricata</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/vmware/" style="font-size: 15px;">vmware</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/04/04/executable-shared-library/">可执行的动态链接库</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/05/26/dirpro-bug-analysis/">一次无源码Linux内核模块bug分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/05/13/elrepo-not-for-production-use/">为什么生产环境服务器不应该使用ELRepo内核</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/04/29/memory-consistency-model-memory-barrier-and-sychronization/">内存一致性模型、内存屏障与同步</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/04/11/rcu-usage/">抢占式RCU与RCU使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/09/16/tc-tbf-qdisc/">tc tbf qdisc 令牌桶过滤器限速队列</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/08/function-call-stack/">gdb查看寄存器及内存数据与函数调用栈分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/16/libpcap-cutoff-captured-packet/">libpcap在libvirt虚拟化环境下捕获数据包不完整的一种情况分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/27/bash-audit/">一种简单的bash审计方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/20/bash-invocation/">bash 调用方式与配置文件</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">属乌鸦的.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>