<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="huyu's blog | Linux"><title>Netfilter 内核数据包过滤框架 | 属乌鸦的</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-129648993-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '85d80db9310fa34ab2f7d34beeff589b';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Netfilter 内核数据包过滤框架</h1><a id="logo" href="/.">属乌鸦的</a><p class="description">无知 &amp; 聒噪</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Netfilter 内核数据包过滤框架</h1><div class="post-meta">Jul 15, 2018</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#协议族"><span class="toc-number">1.</span> <span class="toc-text">协议族</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hook点"><span class="toc-number">2.</span> <span class="toc-text">hook点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#裁决值"><span class="toc-number">3.</span> <span class="toc-text">裁决值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#例子"><span class="toc-number">4.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现原理"><span class="toc-number">5.</span> <span class="toc-text">实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#注册回调函数"><span class="toc-number">5.1.</span> <span class="toc-text">注册回调函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#执行回调函数"><span class="toc-number">5.2.</span> <span class="toc-text">执行回调函数</span></a></li></ol></li></ol></div></div><div class="post-content"><p>Netfilter是linux内核中的数据包过滤框架，2.4版本及其后的内核包含该框架，该框架使数据包过滤、网络地址转换（NAT）和其他数据包修改功能成为可能。Netfilter框架由之前的ipfwadm和ipchains系统改进并重新设计而来，iptables工具与其紧密关联并依赖其在内核完成相应功能。</p>
<p>Netfilter框架由一组内核中的hook点组成，内核模块可以在网络栈的这些hook点上注册回调函数，当数据包穿过网络栈上相应的hook点时注册的回调函数将被调用，回调函数可以对参数中的数据包做需要的处理并裁决数据包后续的处理方式。</p>
<h2 id="协议族"><a href="#协议族" class="headerlink" title="协议族"></a>协议族</h2><p>netfilter是一个通用的数据包过滤框架，支持多种协议族的数据包过滤。本文后续只关注IPV4协议。</p>
<p>ps：本文参考3.10.0-862.el7.x86_64版本内核代码。</p>
<p>本文参考的内核版本中对<code>NFPROTO_INET</code>看起来没有具体使用，未来版本可能会将对NFPROTO_INET的hook同时生效到IPV4与IPV6两个协议族上，也就是注册一个回调函数同时过滤两个协议族的数据包。从支持的协议族所对应的数字可以看到兼容了<code>include/linux/socket.h</code>中各个协议族的定义，对开发者更友好，比如<code>NFPROTO_IPV4 == PF_INET</code>、<code>NFPROTO_IPV6 == PF_INET6</code>，开发时混用也不会出错。</p>
<figure class="highlight c"><figcaption><span>定义在include/uapi/linux/netfilter.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    NFPROTO_UNSPEC =  <span class="number">0</span>,</span><br><span class="line">    NFPROTO_INET   =  <span class="number">1</span>,</span><br><span class="line">    NFPROTO_IPV4   =  <span class="number">2</span>,</span><br><span class="line">    NFPROTO_ARP    =  <span class="number">3</span>,</span><br><span class="line">    NFPROTO_BRIDGE =  <span class="number">7</span>,</span><br><span class="line">    NFPROTO_IPV6   = <span class="number">10</span>,</span><br><span class="line">    NFPROTO_DECNET = <span class="number">12</span>,</span><br><span class="line">    NFPROTO_NUMPROTO,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="hook点"><a href="#hook点" class="headerlink" title="hook点"></a>hook点</h2><p>我没有关注其他协议族的情况，IPV4下共5个hook点，但是hook点的定义比较有趣。比如：</p>
<ul>
<li><code>include/uapi/linux/netfilter_ipv4.h</code>文件中定义有<code>NF_IP_PRE_ROUTING</code></li>
<li><code>include/uapi/linux/netfilter.h</code>文件中定义有<code>NF_INET_PRE_ROUTING</code></li>
</ul>
<p>其他几个hook点定义同样值相同。但是netfilter在内核IPV4与IPV6协议栈中调用回调函数时只使用了<code>NF_INET_PRE_ROUTING</code>这一组。不确定其他协议栈是否也是这5个hook点。</p>
<p>各个hook点调用时机如下：</p>
<ul>
<li><code>NF_INET_PRE_ROUTING</code><br>刚刚进入网络层的数据包通过此hook点，此时还没有判断式数据包的接收者是本地还是转发给其他host。</li>
<li><code>NF_INET_FORWARD</code><br>通过pre_routing后，如果判断数据包应该转发给其他host，则会进一步通过forward点。</li>
<li><code>NF_INET_LOCAL_IN</code><br>通过pre_routing点后，如果判断数据包应该由本地接收，则会进一步通过input点。</li>
<li><code>NF_INET_LOCAL_OUT</code><br>本地向外发出的数据包会先经过output点。</li>
<li><code>NF_INET_POST_ROUTING</code><br>本地向外发出的数据包经过output点后会经过post_routing点，转发的数据包经过forward点后也会经过post_routing点。</li>
</ul>
<p><img src="//blog-image.hyuuhit.com/2018/07/netfilter.png" alt="netfilter hooks"></p>
<figure class="highlight c"><figcaption><span>定义在include/uapi/linux/netfilter.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> nf_inet_hooks &#123;</span><br><span class="line">    NF_INET_PRE_ROUTING,</span><br><span class="line">    NF_INET_LOCAL_IN,</span><br><span class="line">    NF_INET_FORWARD,</span><br><span class="line">    NF_INET_LOCAL_OUT,</span><br><span class="line">    NF_INET_POST_ROUTING,</span><br><span class="line">    NF_INET_NUMHOOKS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="裁决值"><a href="#裁决值" class="headerlink" title="裁决值"></a>裁决值</h2><ul>
<li><code>NF_DROP</code><br>netfilter框架将丢掉该数据包并释放相关资源。</li>
<li><code>NF_ACCEPT</code><br>回调函数放行了该数据包，将继续调用该hook点后续其他回调函数（如果有的话）或进入后续处理流程。</li>
<li><code>NF_STOLEN</code><br>数据包由该回调函数负责后续处理（包括资源释放），netfilter及协议栈将不再对该数据包做任何动作。</li>
<li><code>NF_QUEUE</code><br>数据包停止其他回调函数调用，由netfilter放入NFQUEUE队列中。参考<a href="/2018/07/13/nfqueue/" title="NFQUEUE 用户态数据包处理">NFQUEUE 用户态数据包处理</a>。</li>
<li><code>NF_REPEAT</code><br>数据包由netfilter再次调用刚刚返回<code>NF_REPEAT</code>值的回调函数，返回该值需要谨慎避免死循环。</li>
<li><code>NF_STOP</code><br>与<code>NF_ACCEPT</code>类似，但不再调用该hook点后续的任何回调函数（如果有的话）直接进入后续处理流程。</li>
</ul>
<ul>
<li><code>NF_VERDICT_MASK</code><br>裁决动作掩码。由于<code>NF_DROP</code>和<code>NF_QUEUE</code>在裁决动作之外可能需要额外的信息附带在返回值中，因此使用该掩码过滤掉其他信息只保留裁决动作。</li>
<li><code>NF_VERDICT_FLAG_QUEUE_BYPASS</code><br>该flag位用于标记NFQUEUE队列号不存在对应的队列时是否进行后续处理。如果没有该flag，队列不存在则将直接释放数据包资源。如果包含该flag，队列不存在将等同于<code>NF_ACCEPT</code>做后续处理。这个flag不对队列满的情况产生影响，队列配置的NFQA_CFG_F_FAIL_OPEN影响该情况。</li>
<li><code>NF_VERDICT_QMASK</code><br>该掩码记录了用于NFQUEUE队列号的bit位。</li>
<li><p><code>NF_VERDICT_QBITS</code><br>回调函数裁决<code>NF_QUEUE</code>时，返回值右移此尾数以取到NFQUEUE队列号。</p>
</li>
<li><p><code>NF_QUEUE_NR</code><br>一个辅助宏，输入NFQUEUE队列号，返回回调函数的合理返回值。</p>
</li>
<li><code>NF_DROP_ERR</code><br>一个辅助宏，输入<code>NF_DROP</code>附带的错误值，返回回调函数的合理返回值。</li>
</ul>
<figure class="highlight c"><figcaption><span>定义在include/uapi/linux/netfilter.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Responses from hook functions. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_DROP 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_ACCEPT 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_STOLEN 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_QUEUE 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_REPEAT 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_STOP 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_MAX_VERDICT NF_STOP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* we overload the higher bits for encoding auxiliary data such as the queue</span></span><br><span class="line"><span class="comment"> * number or errno values. Not nice, but better than additional function</span></span><br><span class="line"><span class="comment"> * arguments. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_VERDICT_MASK 0x000000ff</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extra verdict flags have mask 0x0000ff00 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_VERDICT_FLAG_QUEUE_BYPASS    0x00008000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* queue number (NF_QUEUE) or errno (NF_DROP) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_VERDICT_QMASK 0xffff0000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_VERDICT_QBITS 16</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_QUEUE_NR(x) ((((x) &lt;&lt; 16) &amp; NF_VERDICT_QMASK) | NF_QUEUE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_DROP_ERR(x) (((-x) &lt;&lt; 16) | NF_DROP)</span></span><br></pre></td></tr></table></figure>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>netfilter只能在内核态注册回调函数，因此需要编译为内核模块，参考<a href="/2018/07/09/a-simple-lkm/" title="Linux kernel module 内核模块">Linux kernel module 内核模块</a></p>
<p>这里贴一个例子，在IPV4协议栈的5个hook点都注册回调函数，udp端口包含10086的数据包在<code>NF_INET_POST_ROUTING</code>或<code>NF_INET_LOCAL_IN</code>阶段丢掉，udp端口包含10010的数据包在<code>NF_INET_POST_ROUTING</code>或<code>NF_INET_LOCAL_IN</code>阶段放入NFQUEUE队列10010中，其他数据包全部放行。这样也可以联动之前NFQUEUE的例子代码。</p>
<p>ps：注意这里要谨慎一些，因为内核IPV4的所有数据包都会经过该回调函数。</p>
<figure class="highlight c"><figcaption><span>netfilter_example.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netfilter_ipv4.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/udp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"Hu Yu &lt;hyuuhit@gmail.com&gt;"</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"netfilter example"</span>);</span><br><span class="line">MODULE_VERSION(<span class="string">"0.1"</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_QUEUE_NUM 10010</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">hook_name</span><span class="params">(<span class="keyword">int</span> hook)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (hook) &#123;</span><br><span class="line">        <span class="keyword">case</span> NF_INET_PRE_ROUTING:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"pre_routing"</span>;</span><br><span class="line">        <span class="keyword">case</span> NF_INET_LOCAL_IN:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"local_in"</span>;</span><br><span class="line">        <span class="keyword">case</span> NF_INET_FORWARD:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"forward"</span>;</span><br><span class="line">        <span class="keyword">case</span> NF_INET_LOCAL_OUT:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"local_out"</span>;</span><br><span class="line">        <span class="keyword">case</span> NF_INET_POST_ROUTING:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"post_routing"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">generic_hook</span><span class="params">(<span class="keyword">const</span> struct nf_hook_ops *ops, struct sk_buff *skb, <span class="keyword">const</span> struct net_device *in, <span class="keyword">const</span> struct net_device *out, <span class="keyword">const</span> struct nf_hook_state *state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span>    *<span class="title">iph</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">udphdr</span>   *<span class="title">udph</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">udphdr</span>   <span class="title">buf</span>;</span></span><br><span class="line"></span><br><span class="line">    iph         = ip_hdr(skb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iph-&gt;protocol != IPPROTO_UDP) &#123;</span><br><span class="line">        <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (skb-&gt;len &lt; iph-&gt;ihl * <span class="number">4</span> + <span class="keyword">sizeof</span>(*udph)) &#123;</span><br><span class="line">        <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (skb_headlen(skb) &lt; iph-&gt;ihl * <span class="number">4</span> + <span class="keyword">sizeof</span>(*udph)) &#123;</span><br><span class="line">        udph = (<span class="keyword">void</span> *)iph + iph-&gt;ihl * <span class="number">4</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        skb_copy_bits(skb, iph-&gt;ihl * <span class="number">4</span>, &amp;buf, <span class="keyword">sizeof</span>(*udph));</span><br><span class="line">        udph = &amp;buf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ntohs(udph-&gt;source) == <span class="number">10086</span> || ntohs(udph-&gt;dest) == <span class="number">10086</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ops-&gt;hooknum == NF_INET_POST_ROUTING || ops-&gt;hooknum == NF_INET_LOCAL_IN) &#123;</span><br><span class="line">            printk(<span class="string">"%-15s udp drop   %pI4:%d -&gt; %pI4:%d\n"</span>, hook_name(ops-&gt;hooknum), &amp;iph-&gt;saddr, ntohs(udph-&gt;source), &amp;iph-&gt;daddr, ntohs(udph-&gt;dest));</span><br><span class="line">            <span class="keyword">return</span> NF_DROP;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            printk(<span class="string">"%-15s udp accept %pI4:%d -&gt; %pI4:%d\n"</span>, hook_name(ops-&gt;hooknum), &amp;iph-&gt;saddr, ntohs(udph-&gt;source), &amp;iph-&gt;daddr, ntohs(udph-&gt;dest));</span><br><span class="line">            <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ntohs(udph-&gt;source) == <span class="number">10010</span> || ntohs(udph-&gt;dest) == <span class="number">10010</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ops-&gt;hooknum == NF_INET_POST_ROUTING || ops-&gt;hooknum == NF_INET_LOCAL_IN) &#123;</span><br><span class="line">            printk(<span class="string">"%-15s udp queue  %pI4:%d -&gt; %pI4:%d\n"</span>, hook_name(ops-&gt;hooknum), &amp;iph-&gt;saddr, ntohs(udph-&gt;source), &amp;iph-&gt;daddr, ntohs(udph-&gt;dest));</span><br><span class="line">            <span class="keyword">return</span> NF_QUEUE_NR(MY_QUEUE_NUM);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            printk(<span class="string">"%-15s udp accept %pI4:%d -&gt; %pI4:%d\n"</span>, hook_name(ops-&gt;hooknum), &amp;iph-&gt;saddr, ntohs(udph-&gt;source), &amp;iph-&gt;daddr, ntohs(udph-&gt;dest));</span><br><span class="line">            <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> <span class="title">my_hooks</span>[] = &#123;</span></span><br><span class="line">    &#123;</span><br><span class="line">        .hook   = generic_hook,</span><br><span class="line">        .owner  = THIS_MODULE,</span><br><span class="line">        .pf     = NFPROTO_IPV4,</span><br><span class="line">        .hooknum    = NF_INET_PRE_ROUTING,</span><br><span class="line">        .priority   = NF_IP_PRI_LAST,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .hook   = generic_hook,</span><br><span class="line">        .owner  = THIS_MODULE,</span><br><span class="line">        .pf     = NFPROTO_IPV4,</span><br><span class="line">        .hooknum    = NF_INET_LOCAL_IN,</span><br><span class="line">        .priority   = NF_IP_PRI_LAST,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .hook   = generic_hook,</span><br><span class="line">        .owner  = THIS_MODULE,</span><br><span class="line">        .pf     = NFPROTO_IPV4,</span><br><span class="line">        .hooknum    = NF_INET_FORWARD,</span><br><span class="line">        .priority   = NF_IP_PRI_LAST,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .hook   = generic_hook,</span><br><span class="line">        .owner  = THIS_MODULE,</span><br><span class="line">        .pf     = NFPROTO_IPV4,</span><br><span class="line">        .hooknum    = NF_INET_LOCAL_OUT,</span><br><span class="line">        .priority   = NF_IP_PRI_LAST,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .hook   = generic_hook,</span><br><span class="line">        .owner  = THIS_MODULE,</span><br><span class="line">        .pf     = NFPROTO_IPV4,</span><br><span class="line">        .hooknum    = NF_INET_POST_ROUTING,</span><br><span class="line">        .priority   = NF_IP_PRI_LAST,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">my_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">"my init.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> nf_register_hooks(my_hooks, ARRAY_SIZE(my_hooks));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">my_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">"my exit.\n"</span>);</span><br><span class="line">    nf_unregister_hooks(my_hooks, ARRAY_SIZE(my_hooks));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_init);</span><br><span class="line">module_exit(my_exit);</span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><figcaption><span>Makefile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">obj-m := netfilter_example.o</span><br><span class="line"></span><br><span class="line">PWD:=<span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line">KVER:=<span class="variable">$(<span class="built_in">shell</span> uname -r)</span></span><br><span class="line">KDIR:=/lib/modules/<span class="variable">$(KVER)</span>/build</span><br><span class="line"></span><br><span class="line">EXTRA_CFLAGS += -Wall -g</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>使用nc测试后的dmesg输出</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[  614.926634] my init.</span><br><span class="line">[  620.194403] local_out       udp accept 10.95.29.17:47690 -&gt; 10.95.29.15:10086</span><br><span class="line">[  620.194408] post_routing    udp drop   10.95.29.17:47690 -&gt; 10.95.29.15:10086</span><br><span class="line">[  623.164656] local_out       udp accept 10.95.29.17:44909 -&gt; 10.95.29.15:10010</span><br><span class="line">[  623.164662] post_routing    udp queue  10.95.29.17:44909 -&gt; 10.95.29.15:10010</span><br><span class="line">[  632.284199] pre_routing     udp accept 10.95.29.15:39701 -&gt; 10.95.29.17:10086</span><br><span class="line">[  632.284220] local_in        udp drop   10.95.29.15:39701 -&gt; 10.95.29.17:10086</span><br><span class="line">[  650.240826] pre_routing     udp accept 10.95.29.15:40502 -&gt; 10.95.29.17:10010</span><br><span class="line">[  650.240853] local_in        udp queue  10.95.29.15:40502 -&gt; 10.95.29.17:10010</span><br><span class="line">[  667.918573] my exit.</span><br></pre></td></tr></table></figure>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="注册回调函数"><a href="#注册回调函数" class="headerlink" title="注册回调函数"></a>注册回调函数</h3><p>注册回调函数需要nf_hook_ops结构体，里面定义了注册的回调函数、协议族、hook点和优先级（升序排列执行）。</p>
<figure class="highlight c"><figcaption><span>nf_hook_ops结构体定义在include/linux/netfilter.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* User fills in from here down. */</span></span><br><span class="line">    nf_hookfn   *hook;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span>   *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">void</span>        *priv;</span><br><span class="line">    <span class="keyword">u_int8_t</span>    pf;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    hooknum;</span><br><span class="line">    <span class="comment">/* Hooks are ordered in ascending priority. */</span></span><br><span class="line">    <span class="keyword">int</span>     priority;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Reserved for use in the future RHEL versions. Set to zero. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   __rht_reserved1;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   __rht_reserved2;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   __rht_reserved3;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   __rht_reserved4;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   __rht_reserved5;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>nf_hooks定义在net/netfilter/core.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">nf_hooks</span>[<span class="title">NFPROTO_NUMPROTO</span>][<span class="title">NF_MAX_HOOKS</span>] __<span class="title">read_mostly</span>;</span></span><br></pre></td></tr></table></figure>
<p>所有的回调函数都注册在二维数组全局变量<code>nf_hooks</code>中。<code>list_head</code>是linux内核中常用的双向链表结构，这里不关注。数组的第一个维度是注册回调函数的协议族，第二个维度是注册回调函数的hook点，也就是每一个协议族的每一个hook点都是一个双向链表连接的一组回调函数。<code>NF_MAX_HOOKS</code>值为8，不确定什么协议族有8个hook点。</p>
<p><code>nf_register_hook</code>根据协议族和hook点确定<code>nf_hooks</code>中的链表，遍历链表根据nf_hook_ops中的优先级插入到链表的合适位置。<code>nf_register_hooks</code>只是<code>nf_register_hook</code>的循环包装，</p>
<p>注销回调函数时只是将该<code>nf_hook_ops</code>结构从链表中移出。</p>
<h3 id="执行回调函数"><a href="#执行回调函数" class="headerlink" title="执行回调函数"></a>执行回调函数</h3><p>以IPV4协议族收包为例，在确定网络层协议为IPV4协议后，内核进入<code>ip_rcv</code>函数。经过一系列检查后，最后运行到NF_HOOK，选择<code>NFPROTO_IPV4</code>协议族、<code>NF_INET_PRE_ROUTING</code>hook点，同时设定协议栈下一步处理函数<code>ip_rcv_finish</code>（这个函数将在该hook点回调函数处理完毕并允许下一步逻辑执行时被调用，参考前文裁决值部分。</p>
<p>由<code>NF_HOOK</code>开始的netfilter框架执行代码贴在这里，可以看到代码简短逻辑清晰，但能够支持内核模块（比如ip_tables模块）通过注册各种回调函数完成复杂功能。netfilter作为内核数据包过滤框架，很好的体现了“提供机制，而不是策略”的设计思想。</p>
<figure class="highlight c"><figcaption><span>ip_rcv定义在net/ipv4/ip_input.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  Main IP Receive routine.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ip_rcv</span><span class="params">(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * ....................</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING, <span class="literal">NULL</span>, skb,</span><br><span class="line">            dev, <span class="literal">NULL</span>,</span><br><span class="line">            ip_rcv_finish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>include/linux/netfilter.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  nf_hook_thresh - call a netfilter hook</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Returns 1 if the hook has allowed the packet to pass.  The function</span></span><br><span class="line"><span class="comment"> *  okfn must be invoked by the caller in this case.  Any other return</span></span><br><span class="line"><span class="comment"> *  value indicates the packet has been consumed by the hook.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nf_hook_thresh</span><span class="params">(<span class="keyword">u_int8_t</span> pf, <span class="keyword">unsigned</span> <span class="keyword">int</span> hook,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct sock *sk,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct net_device *indev,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct net_device *outdev,</span></span></span><br><span class="line">        int (*okfn)(struct sock *, struct sk_buff *),</span><br><span class="line">        <span class="keyword">int</span> thresh)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (nf_hooks_active(pf, hook)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_state</span> <span class="title">state</span>;</span></span><br><span class="line"></span><br><span class="line">        nf_hook_state_init(&amp;state, hook, thresh, pf,</span><br><span class="line">                indev, outdev, sk, okfn);</span><br><span class="line">        <span class="keyword">return</span> nf_hook_slow(skb, &amp;state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span><br><span class="line">NF_HOOK_THRESH(<span class="keyword">uint8_t</span> pf, <span class="keyword">unsigned</span> <span class="keyword">int</span> hook, struct sock *sk,</span><br><span class="line">        struct sk_buff *skb, struct net_device *in,</span><br><span class="line">        struct net_device *out,</span><br><span class="line">        <span class="keyword">int</span> (*okfn)(struct sock *, struct sk_buff *), <span class="keyword">int</span> thresh)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = nf_hook_thresh(pf, hook, sk, skb, in, out, okfn, thresh);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">        ret = okfn(sk, skb);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span><br><span class="line">NF_HOOK(<span class="keyword">uint8_t</span> pf, <span class="keyword">unsigned</span> <span class="keyword">int</span> hook, struct sock *sk, struct sk_buff *skb,</span><br><span class="line">        struct net_device *in, struct net_device *out,</span><br><span class="line">        <span class="keyword">int</span> (*okfn)(struct sock *, struct sk_buff *))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> NF_HOOK_THRESH(pf, hook, sk, skb, in, out, okfn, INT_MIN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>net/netfilter/core.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">nf_iterate</span><span class="params">(struct list_head *head,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct nf_hook_state *state,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct nf_hook_ops **elemp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> verdict;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The caller must not block between calls to this</span></span><br><span class="line"><span class="comment">     * function because of risk of continuing from deleted element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    list_for_each_entry_continue_rcu((*elemp), head, <span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state-&gt;thresh &gt; (*elemp)-&gt;priority)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Optimization: we don't need to hold module</span></span><br><span class="line"><span class="comment">           reference here, since function can't sleep. --RR */</span></span><br><span class="line">repeat:</span><br><span class="line">        verdict = (*elemp)-&gt;hook(*elemp, skb, state-&gt;in, state-&gt;out,</span><br><span class="line">                state);</span><br><span class="line">        <span class="keyword">if</span> (verdict != NF_ACCEPT) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NETFILTER_DEBUG</span></span><br><span class="line">            <span class="keyword">if</span> (unlikely((verdict &amp; NF_VERDICT_MASK)</span><br><span class="line">                        &gt; NF_MAX_VERDICT)) &#123;</span><br><span class="line">                NFDEBUG(<span class="string">"Evil return from %p(%u).\n"</span>,</span><br><span class="line">                        (*elemp)-&gt;hook, state-&gt;hook);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">if</span> (verdict != NF_REPEAT)</span><br><span class="line">                <span class="keyword">return</span> verdict;</span><br><span class="line">            <span class="keyword">goto</span> repeat;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns 1 if okfn() needs to be executed by the caller,</span></span><br><span class="line"><span class="comment"> * -EPERM for NF_DROP, 0 otherwise. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nf_hook_slow</span><span class="params">(struct sk_buff *skb, struct nf_hook_state *state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> *<span class="title">elem</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> verdict;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We may already have this, but read-locks nest anyway */</span></span><br><span class="line">    rcu_read_lock();</span><br><span class="line"></span><br><span class="line">    elem = list_entry_rcu(&amp;nf_hooks[state-&gt;pf][state-&gt;hook],</span><br><span class="line">            struct nf_hook_ops, <span class="built_in">list</span>);</span><br><span class="line">next_hook:</span><br><span class="line">    verdict = nf_iterate(&amp;nf_hooks[state-&gt;pf][state-&gt;hook], skb, state,</span><br><span class="line">            &amp;elem);</span><br><span class="line">    <span class="keyword">if</span> (verdict == NF_ACCEPT || verdict == NF_STOP) &#123;</span><br><span class="line">        ret = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((verdict &amp; NF_VERDICT_MASK) == NF_DROP) &#123;</span><br><span class="line">        kfree_skb(skb);</span><br><span class="line">        ret = NF_DROP_GETERR(verdict);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">            ret = -EPERM;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((verdict &amp; NF_VERDICT_MASK) == NF_QUEUE) &#123;</span><br><span class="line">        <span class="keyword">int</span> err = nf_queue(skb, elem, state,</span><br><span class="line">                verdict &gt;&gt; NF_VERDICT_QBITS);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (err == -ECANCELED)</span><br><span class="line">                <span class="keyword">goto</span> next_hook;</span><br><span class="line">            <span class="keyword">if</span> (err == -ESRCH &amp;&amp;</span><br><span class="line">                    (verdict &amp; NF_VERDICT_FLAG_QUEUE_BYPASS))</span><br><span class="line">                <span class="keyword">goto</span> next_hook;</span><br><span class="line">            kfree_skb(skb);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/linux/">linux</a></div><div class="post-nav"><a class="pre" href="/2018/07/25/receive-packet/">Linux kernel 链路层帧接收</a><a class="next" href="/2018/07/13/nfqueue/">NFQUEUE 用户态数据包处理</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://www.hyuuhit.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/libvirt/">libvirt</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/suricata/">suricata</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/vmware/" style="font-size: 15px;">vmware</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/06/08/screen-windows-auto-title/">gnu screen 自动修改窗口标题</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/06/02/stop-machine/">stop_machine 实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/05/05/static-key-jump-label/">static key & jump label</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/30/initcall/">initcall 机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/07/cn-proc-example/">cn_proc 进程事件连接器</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/04/executable-shared-library/">可执行的动态链接库</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/05/26/dirpro-bug-analysis/">一次无源码Linux内核模块bug分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/05/13/elrepo-not-for-production-use/">为什么生产环境服务器不应该使用ELRepo内核</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/04/29/memory-consistency-model-memory-barrier-and-sychronization/">内存一致性模型、内存屏障与同步</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/04/11/rcu-usage/">抢占式RCU与RCU使用</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">属乌鸦的.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>