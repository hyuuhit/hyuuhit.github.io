<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="hu yu's blog | Android | 服务端"><title>BM字符串搜索算法 | 属乌鸦的</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-129648993-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '85d80db9310fa34ab2f7d34beeff589b';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">BM字符串搜索算法</h1><a id="logo" href="/.">属乌鸦的</a><p class="description">无知 &amp; 聒噪</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">BM字符串搜索算法</h1><div class="post-meta">Jun 23, 2018</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#主要特征"><span class="toc-number">1.</span> <span class="toc-text">主要特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#搜索"><span class="toc-number">2.</span> <span class="toc-text">搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#预处理"><span class="toc-number">3.</span> <span class="toc-text">预处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#坏字符"><span class="toc-number">3.1.</span> <span class="toc-text">坏字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#好后缀"><span class="toc-number">3.2.</span> <span class="toc-text">好后缀</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#case-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">case 1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#计算case-1"><span class="toc-number">3.2.2.</span> <span class="toc-text">计算case 1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#case-2"><span class="toc-number">3.2.3.</span> <span class="toc-text">case 2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#计算case-2"><span class="toc-number">3.2.4.</span> <span class="toc-text">计算case 2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#case-3"><span class="toc-number">3.2.5.</span> <span class="toc-text">case 3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#计算case-3"><span class="toc-number">3.2.6.</span> <span class="toc-text">计算case 3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#计算suff数组"><span class="toc-number">3.2.7.</span> <span class="toc-text">计算suff数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#整体代码"><span class="toc-number">4.</span> <span class="toc-text">整体代码</span></a></li></ol></div></div><div class="post-content"><p>BM（Boyer-Moore）字符串搜索算法是一种非常高效的字符串搜索算法。它由Bob Boyer和J Strother Moore设计于1977年。算法对将要搜索的字符串（模式）进行预处理，对文本不进行预处理操作。这个算法适用于模式远短于文本的场景，以及模式会被多次搜索的场景。BM算法在搜索时使用预处理阶段生成的信息以快速跳过文本中不匹配的部分，相比其他很多字符串搜索算法更快。</p>
<h2 id="主要特征"><a href="#主要特征" class="headerlink" title="主要特征"></a>主要特征</h2><ul>
<li>从右向左比较字符。</li>
<li>算法分为两个阶段：预处理阶段和搜索阶段。</li>
<li>预处理阶段时间复杂度空间复杂度均为$O(m+σ)$。$m$是模式长度$σ$是字符集大小，一般考虑为单字节8位共256种。</li>
<li>搜索阶段时间复杂度$O(mn)$。</li>
<li>当模式串是非周期性的，最坏情况下需要做$3n$次字符比较，$n$是文本长度。</li>
<li>最好情况下性能为$O(n/m)$，比如在文本串$b^n$中搜索模式串$a^{m-1}b$，只需要$n/m$次比较。</li>
</ul>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>基础的匹配算法移动模式串的时候是从左到右，而进行比较的时候也是从左到右的，基本框架是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">j = <span class="number">0</span>；</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(j &lt;= <span class="built_in">strlen</span>(text) - <span class="built_in">strlen</span>(pattern))&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(pattern) &amp;&amp; pattern[i] == text[i + j]; i++);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="built_in">strlen</span>(pattern)) &#123;</span><br><span class="line">        Match(j);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        j++；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BM算法在移动模式串的时候是从左到右，而进行比较的时候是从右到左的，基本框架是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">j = <span class="number">0</span>；</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>（j &lt;= <span class="built_in">strlen</span>(text) - <span class="built_in">strlen</span>(pattern)）&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="built_in">strlen</span>(pattern); i &gt;= <span class="number">0</span> &amp;&amp; pattern[i] == text[i + j]; i--);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        Match(j);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        j += BM()；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，BM算法的核心就是在遇到字符失配时模式串向右滑动的距离。在快速滑动这个思路上BM与KMP是一致的，区别在于滑动的距离具体如何计算。KMP中利用了已经匹配的部分计算滑动距离，并且预先计算成表，使得搜索阶段运行更快。BM中同样利用了已经匹配的部分计算滑动距离，同时还利用了文本中失配字符这一更多的信息，这两种信息的使用就是BM算法的核心。</p>
<h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>BM算法中关于失配后滑动距离的计算包含两个互相独立的方法。</p>
<ul>
<li>坏字符滑动（bad-character shift）</li>
<li>好后缀滑动（good-suffix shift）</li>
</ul>
<p>下文中<code>j</code>为文本串中与模式串对齐的首个字符的索引，<code>i</code>为模式串中失配字符的索引。</p>
<h3 id="坏字符"><a href="#坏字符" class="headerlink" title="坏字符"></a>坏字符</h3><p>坏字符顾名思义就是失配字符，在这个方法中不考虑坏字符右侧已经匹配的部分，也就是说坏字符出现的模式串的任何位置都无关这个方法的滑动距离计算。</p>
<p>以下图情况为例，<code>t[j+i]</code>位置上的字符<code>&#39;b&#39;</code>与<code>p[i]</code>位置上的字符<code>&#39;a&#39;</code>失配，这时模式串p需要向右滑动以选择一个可能使匹配完成的位置。不考虑失配字符左右的具体内容，由于有<code>t[j+i]</code>位置上的字符<code>&#39;b&#39;</code>存在，模式串p必须滑动到模式串中的字符<code>&#39;b&#39;</code>与文本串中<code>t[j+i]</code>中字符<code>&#39;b&#39;</code>对齐。为了避免遗漏可能的匹配，需要选择<code>p[i]</code>左侧最近的字符<code>&#39;b&#39;</code>。模式串中选择的字符<code>&#39;b&#39;</code>位置为<code>p[k]</code>，则滑动距离为<code>i-k</code>。</p>
<p><img src="http://blog-image.hyuuhit.com/2018/06/bm/bmbc1.png" alt="坏字符滑动，失配位置左侧存在字符&#39;b&#39;"></p>
<p>如果模式串p中失配字符左侧不存在字符<code>&#39;b&#39;</code>，则将模式串全部移动到文本串中<code>t[j+i]</code>中字符<code>&#39;b&#39;</code>的右侧，这可以看作模式串中选择的字符<code>&#39;b&#39;</code>位置索引为-1，则滑动距离为<code>i+1</code>。</p>
<p><img src="http://blog-image.hyuuhit.com/2018/06/bm/bmbc2.png" alt="坏字符滑动，失配位置左侧不存在字符&#39;b&#39;"></p>
<p>为了满足搜索时任意位置任意字符失配都可以快速查找到该位置左侧最近的失配字符，需要建立一个二维数组，一维长度为模式串长度，一维索引为失配位置，二维长度为字符表（单字节情况可以设为256），二维索引为字符表每个字符。这种二维数组占用空间较大，实际项目中经常采用一维数组存储字符表中每个字符在模式串中最右的位置，这个位置可以记录为距离模式串最右端的距离<code>m-1-i</code>，模式串中未出现的字符记为m。</p>
<p>采用一维数组后，查坏字符表时滑动距离计算为<code>bmBc[text[i + j]] - m + 1 + i</code>，这个值可能是负数。但是由于有并行的好后缀滑动方法存在，最后确定的滑动距离一定是正数。</p>
<figure class="highlight c"><figcaption><span>坏字符表预处理</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreBmBc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *pattern, <span class="keyword">int</span> m, <span class="keyword">int</span> bmBc[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bmBc[i] = m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bmBc[pattern[i]] = m - <span class="number">1</span> - i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="好后缀"><a href="#好后缀" class="headerlink" title="好后缀"></a>好后缀</h3><p>好后缀就是利用模式串中已经匹配部分的信息计算滑动距离，由于字符比较是由右向左，因此匹配部分是模式的后缀。这个方法中关注匹配的后缀，关注模式串中的失配字符，不关注文本串中的失配字符。</p>
<p>以下图情况为例，已经匹配的好后缀为<code>p[i+1 ... m-1] = t[j+i+1 ... j+m+-1]</code>，好后缀字符串记为<code>u</code>，文本串中的<code>&#39;b&#39;</code>与模式串中的<code>&#39;a&#39;</code>失配。由于已经检查到字符失配，这时模式串<code>p</code>需要向右滑动以选择一个可能使匹配完成完成的位置。考虑到文本串中已经匹配部分的<code>u</code>的存在，移动距离分以下几种情况。</p>
<ol>
<li>模式串向右移动，模式串内遇到一串字符可以匹配文本串中的<code>u</code>。同时模式串中新的<code>u</code>前一个字符不能等于模式串中刚刚的那个失配字符，因为如果相等的话肯定不会匹配文本串。</li>
<li>case1中情况没有发生，模式串继续向右移动，模式串的前缀<code>v</code>匹配了文本串中<code>u</code>的后缀。</li>
<li>case1和case2中的情况都没有发生，模式串继续向右移动，直到模式串完全移动到文本串中<code>u</code>的右侧。</li>
</ol>
<p>这几种情况是按移动距离由短及长排列的。为了避免匹配的遗漏，如果可以对应到移动距离短的情况，就不会再继续移动了，因此这三种情况是有优先级的。下面依次分析。</p>
<h4 id="case-1"><a href="#case-1" class="headerlink" title="case 1"></a>case 1</h4><p>模式串内遇到一串字符可以匹配文本串中的<code>u</code>，同时前一个字符不是原失配字符。如果有模式串中有多个位置的串可以匹配，那么选择移动距离最短的，也就是模式串中最右侧的（这个最右不包含后缀<code>u</code>自身）。</p>
<p>在这里<code>u</code>是模式串的后缀，需要检查的模式串内与<code>u</code>相同的串也在模式串内，因此滑动距离可以由模式串自己预处理得到。</p>
<p><img src="http://blog-image.hyuuhit.com/2018/06/bm/bmgs1.png" alt="`u`在模式串中间存在"></p>
<h4 id="计算case-1"><a href="#计算case-1" class="headerlink" title="计算case 1"></a>计算case 1</h4><p>假设存在数组<code>int suff[m]</code>，数组中的每一项<code>suff[i]</code>满足，<code>suff[i]</code>的值为模式串<code>p</code>与模式串前缀<code>p[0 ... i]</code>的最长公共后缀长度。<br>$ for\ 0 \le i &lt; m, suff[i] = max\{k \ge 0 : x[i-k+1 .. i]=x[m-k .. m-1]\} $</p>
<p>假设存在数组<code>int bmGs[m]</code>，用于存储好后缀滑动距离。</p>
<figure class="highlight c"><figcaption><span>好后缀case 1计算</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算每个位置i失配的滑动距离</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="comment">// 已经匹配长度为m-1-i，查找哪个位置的suff[j]等于已经匹配部分的长度。</span></span><br><span class="line">    <span class="comment">// Q:为什么suff数组要记录的是最长公共后缀长度呢？最长的意义是什么？</span></span><br><span class="line">    <span class="comment">// A:这是为了保证前一个字符与刚刚的失配字符不同，或者前一个字符已经位于-1位置(不存在的字符当然与失配字符不同)。</span></span><br><span class="line">    <span class="comment">// j由小到大遍历，为了寻找最右侧符合条件的j，也就是符合条件的j中滑动距离最小的。</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (suff[j] == m - <span class="number">1</span> - i) &#123;</span><br><span class="line">            bmGs[i] = m - <span class="number">1</span> - j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于case 1中好后缀滑动距离的填充都是由suff数组计算得到的，而且从上一个计算方法中<code>if (suff[j] == m - 1 - i)</code>这一判断可以看出，suff数组中的每一项值最多会参与一次且一定会参与一次该方法中好后缀滑动距离的计算，因此只要遍历一次suff数组就可以完成case 1的计算。<br>注意下面遍历过程中赋值的<code>m - 1 - i</code>，由于<code>i</code>是递增的，因此赋值的滑动距离是递减的，最后得到的case 1中的滑动距离都是符合条件且最小。<br><code>i</code>最大值取到<code>m-2</code>，因为<code>i</code>取<code>m-1</code>时，bmGs数组索引将取到<code>-1</code>没有意义。而且<code>suff[m-1]</code>的值恒为m，参考上一个计算方法，<code>m-1-i</code>不可能等于m，因此suff[m-1]在case 1计算中没有意义。</p>
<figure class="highlight c"><figcaption><span>好后缀case 1计算改进</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= m - <span class="number">2</span>; i++) &#123;</span><br><span class="line">    bmGs[m - <span class="number">1</span> - suff[i]] = m - <span class="number">1</span> - i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="case-2"><a href="#case-2" class="headerlink" title="case 2"></a>case 2</h4><p>模式串的前缀<code>v</code>匹配了<code>u</code>的后缀，这时可能有多个<code>v</code>符合要求，选择最长的哪一个，也就是移动距离最短的。</p>
<p>在这里<code>u</code>是模式串的后缀，<code>v</code>是模式串的前缀，因此滑动距离可以由模式串自己预处理得到。</p>
<p><img src="http://blog-image.hyuuhit.com/2018/06/bm/bmgs2.png" alt="`u`的后缀`v`也是模式串的前缀"></p>
<h4 id="计算case-2"><a href="#计算case-2" class="headerlink" title="计算case 2"></a>计算case 2</h4><p><code>suff</code>和<code>bmGs</code>与上面假设相同。</p>
<figure class="highlight c"><figcaption><span>好后缀case 2计算</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// i递减，也就是给j留的向右的空间越来越大，配合j保存状态的递增，只扫描模式一次就可以完成计算。</span></span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 确保以位置索引i结尾的字符串是模式的后缀。</span></span><br><span class="line">    <span class="keyword">if</span>(suff[i] == i + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// j &lt; m - 1 - i，确保j后面至少有i+1长度已经匹配。</span></span><br><span class="line">        <span class="comment">// 为j保存状态，每个bmGs项依次只填充一次。</span></span><br><span class="line">        <span class="comment">// 如果j不保存状态，当i取更小值再次遍历时，m - 1 - i值将会更大，不符合最小滑动距离的要求。</span></span><br><span class="line">        <span class="comment">// 因此bmGs[j]首次取到的值就是符合条件的最小滑动距离。</span></span><br><span class="line">        <span class="keyword">for</span>(; j &lt; m - <span class="number">1</span> - i; j++)</span><br><span class="line">            bmGs[j] = m - <span class="number">1</span> - i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="case-3"><a href="#case-3" class="headerlink" title="case 3"></a>case 3</h4><p>模式串完全移动到文本串中<code>u</code>的右侧。由于文本串<code>u</code>后的内容没有经过任何匹配检查，因此不能跳过文本串<code>u</code>后的任何内容，模式串最多只能移动到<code>u</code>后的下一个字符位置。</p>
<p>不满足前两种情况时，需要的滑动距离很明显是模式串长度<code>m</code>。</p>
<p><img src="http://blog-image.hyuuhit.com/2018/06/bm/bmgs3.png" alt="模式串移出文本串"></p>
<h4 id="计算case-3"><a href="#计算case-3" class="headerlink" title="计算case 3"></a>计算case 3</h4><p>case 3的计算十分简单，由于整体滑动到匹配的内容右侧，因此填充<code>bmGs</code>数组所有项为<code>m</code>。</p>
<figure class="highlight c"><figcaption><span>好后缀case 3计算</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    bmGs[i] = m;</span><br></pre></td></tr></table></figure>
<h4 id="计算suff数组"><a href="#计算suff数组" class="headerlink" title="计算suff数组"></a>计算suff数组</h4><p>前面假设了一个<code>suff[m]</code>数组，数组中的每一项<code>suff[i]</code>满足，<code>suff[i]</code>的值为模式串<code>p</code>与模式串前缀<code>p[0 ... i]</code>的最长公共后缀长度。</p>
<p>简单粗暴的计算方式很容易。</p>
<figure class="highlight c"><figcaption><span>suff数组计算</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">suffixes</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">int</span> m, <span class="keyword">int</span> *suff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line">    suff[m - <span class="number">1</span>] = m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = m - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        j = i;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; p[j] == p[m - <span class="number">1</span> - i + j])</span><br><span class="line">            j--;</span><br><span class="line"></span><br><span class="line">        suff[i] = i - j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>suff数组有一种改进的计算方式，思路是利用已经计算过的suff项来加速后面的计算。</p>
<p>以图为例，<code>f</code>为之前计算过的最长公共后缀的尾部，<code>g</code>为与<code>f</code>匹配的最长公共后缀的首部。<br>新要计算的位置<code>i</code>一定是在<code>f</code>左侧的。<br>图中标识<code>suff[f]</code>的两部分内容是相同的，图中标识<code>suff[m-1-f+i]</code>的两部分内容是相同的。<br>左侧的<code>i</code>相对应的就是右侧的<code>(m-1)-(f-i)</code>。<br>只要满足<code>suff[m-1-f+i] &lt; i-g</code>（也就是说<code>suff[m-1-f+i]</code>限制在绿色区域内）。由于两块绿色区域内容相同，也就意味着<code>suff[i] = suff[m-1-f+i]</code>。这里的条件必须是小于号，因为如果相等的话，虽然两块标识<code>suff[m-1-f+i]</code>的区域在左侧外部（也就是绿色的外部）失配了，但是两块绿色的左侧外部内容并没有经过检查（也就是说有可能内容相同），这样<code>suff[i]</code>就可能超越出绿色部分（也就是超过<code>i-g</code>），也就无法快速计算了。</p>
<p><img src="http://blog-image.hyuuhit.com/2018/06/bm/bmsuff.png" alt="suff数组计算改进"></p>
<figure class="highlight c"><figcaption><span>suff数组计算改进</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BoyerMooreSuffixes</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">int</span> m, <span class="keyword">int</span> *suff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">0</span>, g, i;</span><br><span class="line">    suff[m - <span class="number">1</span>] = m;</span><br><span class="line">    g = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = m - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; g &amp;&amp; suff[m - <span class="number">1</span> - f + i] &lt; i - g)</span><br><span class="line">            suff[i] = suff[m - <span class="number">1</span> - f + i];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; g)</span><br><span class="line">                g = i;</span><br><span class="line">            f = i;</span><br><span class="line">            <span class="keyword">while</span> (g &gt;= <span class="number">0</span> &amp;&amp; p[g] == p[g + m - <span class="number">1</span> - f])</span><br><span class="line">                g--;</span><br><span class="line">            suff[i] = f - g;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="整体代码"><a href="#整体代码" class="headerlink" title="整体代码"></a>整体代码</h2><figure class="highlight c"><figcaption><span>BM算法代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreBmBc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">int</span> m, <span class="keyword">int</span> bmBc[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">        bmBc[i] = m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++)</span><br><span class="line">        bmBc[p[i]] = m - <span class="number">1</span> - i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BoyerMooreSuffixes</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">int</span> m, <span class="keyword">int</span> *suff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">0</span>, g, i;</span><br><span class="line">    suff[m - <span class="number">1</span>] = m;</span><br><span class="line">    g = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = m - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; g &amp;&amp; suff[i + m - <span class="number">1</span> - f] &lt; i - g)</span><br><span class="line">            suff[i] = suff[i + m - <span class="number">1</span> - f];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; g)</span><br><span class="line">                g = i;</span><br><span class="line">            f = i;</span><br><span class="line">            <span class="keyword">while</span> (g &gt;= <span class="number">0</span> &amp;&amp; p[g] == p[g + m - <span class="number">1</span> - f])</span><br><span class="line">                g--;</span><br><span class="line">            suff[i] = f - g;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreBmGs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">int</span> m, <span class="keyword">int</span> bmGs[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> suff[m];</span><br><span class="line"></span><br><span class="line">    BoyerMooreSuffixes(p, m, suff);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三种情况有优先级关系，优先级最高的情况最后填充到表中。</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        bmGs[i] = m;</span><br><span class="line"></span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span>(suff[i] == i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(; j &lt; m - <span class="number">1</span> - i; j++)</span><br><span class="line">                bmGs[j] = m - <span class="number">1</span> - i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= m - <span class="number">2</span>; i++)</span><br><span class="line">        bmGs[m - <span class="number">1</span> - suff[i]] = m - <span class="number">1</span> - i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BMSearch</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">int</span> m, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *t, <span class="keyword">int</span> n, <span class="keyword">int</span> *bmBc, <span class="keyword">int</span> *bmGs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, m1, m2;</span><br><span class="line"></span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= n - m ) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; p[i] == t[i + j]; i--);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Match index %d\n"</span>, j);</span><br><span class="line">            <span class="keyword">return</span> j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j += (m1 = bmGs[i]) &gt; (m2 = bmBc[t[i + j]] - m + <span class="number">1</span> + i)? m1: m2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">int</span> m, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *t, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bmBc[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> bmGs[m];</span><br><span class="line"></span><br><span class="line">    PreBmBc(p, m, bmBc);</span><br><span class="line">    PreBmGs(p, m, bmGs);</span><br><span class="line"></span><br><span class="line">    BMSearch(p, m, t, n, bmBc, bmGs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> p[] = <span class="string">"example"</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">strlen</span>(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> t[] = <span class="string">"here is an example"</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(t);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pattern %s\n"</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"text    %s\n"</span>, t);</span><br><span class="line"></span><br><span class="line">    test((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p, m, (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)t, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/数据结构/">数据结构</a></div><div class="post-nav"><a class="pre" href="/2018/07/09/a-simple-lkm/">Linux kernel module 内核模块</a><a class="next" href="/2018/06/20/suricata-4-0-3-app-layer-protocol-detect/">suricata 4.0.3 应用层协议检测</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://www.hyuuhit.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/libvirt/">libvirt</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/suricata/">suricata</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/vmware/" style="font-size: 15px;">vmware</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2024/04/29/memory-consistency-model-memory-barrier-and-sychronization/">内存一致性模型、内存屏障与同步</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/04/11/rcu-usage/">RCU 使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/09/16/tc-tbf-qdisc/">tc tbf qdisc</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/08/function-call-stack/">gdb查看寄存器及内存数据与函数调用栈分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/16/libpcap-cutoff-captured-packet/">libpcap在libvirt虚拟化环境下捕获数据包不完整的一种情况分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/27/bash-audit/">一种简单的bash审计方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/20/bash-invocation/">bash 调用方式与配置文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/17/uriparser/">uriparser 解析处理URI</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/06/noblock-rabbitmq-c/">rabbitmq-c 非阻塞订阅</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/20/libyaml/">libyaml 解析配置文件</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">属乌鸦的.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>