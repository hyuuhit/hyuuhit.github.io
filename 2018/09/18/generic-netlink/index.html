<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="huyu's blog | Linux"><title>Linux generic netlink 自定义内核通信 | 属乌鸦的</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-129648993-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '85d80db9310fa34ab2f7d34beeff589b';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Linux generic netlink 自定义内核通信</h1><a id="logo" href="/.">属乌鸦的</a><p class="description">无知 &amp; 聒噪</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Linux generic netlink 自定义内核通信</h1><div class="post-meta">Sep 18, 2018</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#generic-netlink-使用"><span class="toc-number">1.</span> <span class="toc-text">generic netlink 使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据结构"><span class="toc-number">1.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例子代码"><span class="toc-number">1.2.</span> <span class="toc-text">例子代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#generic-netlink-实现"><span class="toc-number">2.</span> <span class="toc-text">generic netlink 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化"><span class="toc-number">2.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义协议注册"><span class="toc-number">2.2.</span> <span class="toc-text">自定义协议注册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单播数据包分发"><span class="toc-number">2.3.</span> <span class="toc-text">单播数据包分发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NLM-F-DUMP-请求处理"><span class="toc-number">2.3.1.</span> <span class="toc-text">NLM_F_DUMP 请求处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#controller服务"><span class="toc-number">2.4.</span> <span class="toc-text">controller服务</span></a></li></ol></li></ol></div></div><div class="post-content"><p>前文说过将32个netlink协议号中未使用的号码用于自定义内核模块通信并不是一个好主意，更规范的做法是使用generic netlink的方式达成同样的目的。generic netlink是一种netlink协议，被设计为一个通用的协议，用于承载运行于其上的各种用户自定义协议。这里介绍generic netlink的使用方式及其实现原理。</p>
<a id="more"></a>
<h2 id="generic-netlink-使用"><a href="#generic-netlink-使用" class="headerlink" title="generic netlink 使用"></a>generic netlink 使用</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>例子代码之前先看几个需要了解的数据结构。</p>
<figure class="highlight c"><figcaption><span>struct genlmsghdr</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">genlmsghdr</span> &#123;</span></span><br><span class="line">    __u8    cmd;</span><br><span class="line">    __u8    version;</span><br><span class="line">    __u16   reserved;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>genlmsghdr是generic netlink的消息头，发送给内核的generic netlink消息中该结构必须存在，因为内核需要根据这个协议头定位该cmd对应的ops。</p>
<p><img src="//blog-image.hyuuhit.com/2018/09/genl_msg_format.jpg" alt="generic netlink 消息格式"></p>
<figure class="highlight c"><figcaption><span>struct genl_family</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">genl_family</span> &#123;</span></span><br><span class="line">    RH_KABI_REPLACE(<span class="keyword">unsigned</span> <span class="keyword">int</span> id, <span class="keyword">int</span> id)    <span class="comment">/* private */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>        hdrsize;</span><br><span class="line">    <span class="keyword">char</span>            name[GENL_NAMSIZ];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        version;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        maxattr;</span><br><span class="line">    <span class="keyword">bool</span>            netnsok;</span><br><span class="line">    <span class="keyword">bool</span>            parallel_ops;</span><br><span class="line">    <span class="keyword">int</span>         (*pre_doit)(<span class="keyword">const</span> struct genl_ops *ops,</span><br><span class="line">            struct sk_buff *skb,</span><br><span class="line">            struct genl_info *info);</span><br><span class="line">    <span class="keyword">void</span>            (*post_doit)(<span class="keyword">const</span> struct genl_ops *ops,</span><br><span class="line">            struct sk_buff *skb,</span><br><span class="line">            struct genl_info *info);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> **    <span class="title">attrbuf</span>;</span>    <span class="comment">/* private */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">genl_ops</span> * <span class="title">ops</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">genl_multicast_group</span> *<span class="title">mcgrps</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        n_ops;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        n_mcgrps;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        mcgrp_offset;   <span class="comment">/* private */</span></span><br><span class="line">    RH_KABI_DEPRECATE(struct list_head, family_list)</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">module</span>       *<span class="title">module</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Reserved slots. For Red Hat usage only, modules are required to</span></span><br><span class="line"><span class="comment">     * set them to zero. */</span></span><br><span class="line">    RH_KABI_RESERVE(<span class="number">1</span>)</span><br><span class="line">    RH_KABI_RESERVE(<span class="number">2</span>)</span><br><span class="line">    RH_KABI_RESERVE(<span class="number">3</span>)</span><br><span class="line">    RH_KABI_RESERVE(<span class="number">4</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>genl_family用于注册到generic netlink中，需要使用静态数据，因为后续处理需要该结构。</p>
<ul>
<li>id<br>family注册后最终确定的id，内核保留字段，自定义协议注册该字段保留0。</li>
<li>hdrsize<br>自定义协议中自定义头的长度，会影响内核对消息体中nlattr的定位及预处理。</li>
<li>name<br>family的名字，不能注册重复名字，长度在15以内（不包含’\0’结尾）。</li>
<li>maxattr<br>支持的nla_type的最大值，如果在消息中出现超出该值的nlattr，将不会被解析填充到genl_info中，也不会被policy校验。</li>
<li>netnsok<br>是否支持接收所有net namespace的请求。</li>
<li>parallel_ops<br>是否支持并行操作，如果不支持并行操作，内核将使用一个全局锁将不支持并行操作的family的所有请求串行处理。</li>
<li>pre_doid<br>如果非NULL，将在genl_ops的doit函数指针前执行。</li>
<li>post_doit<br>如果非NULL，将在genl_ops的doit函数指针执行。</li>
<li>attrbuf<br>内核保留字段，如果不支持并行操作，将用作genl_info字段attrs共用的缓存。</li>
<li>ops<br>支持的genl_ops数组。</li>
<li>mcgrps<br>family需要的组播组名字数组。</li>
<li>n_ops<br>ops数组长度。</li>
<li>n_mcgrps<br>mcgrps数组长度</li>
<li>mcgrp_offset<br>内核保留字段，最终确定的组播组连续id的首个id。</li>
</ul>
<figure class="highlight c"><figcaption><span>struct genl_ops</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">genl_ops</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nla_policy</span> *<span class="title">policy</span>;</span></span><br><span class="line">    <span class="keyword">int</span>            (*doit)(struct sk_buff *skb,</span><br><span class="line">            struct genl_info *info);</span><br><span class="line">    <span class="keyword">int</span>            (*dumpit)(struct sk_buff *skb,</span><br><span class="line">            struct netlink_callback *cb);</span><br><span class="line">    <span class="keyword">int</span>            (*done)(struct netlink_callback *cb);</span><br><span class="line">    u8          cmd;</span><br><span class="line">    u8          internal_flags;</span><br><span class="line">    u8          flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注册时嵌入到genl_family结构中，同样需要使用静态数据</p>
<ul>
<li>policy<br>用户校验该cmd下nlattr基本内容，具体看<code>include/net/netlink.h</code>和源码吧。</li>
<li>doit<br>该cmd的处理函数。</li>
<li>dumpit<br>该cmd的请求nlmsg_flags中如果包含NLM_F_DUMP，将由该处理函数处理。这里的处理逻辑支持对于一个dump请求多次调用dumpit返回响应，由dumpit的返回值决定。下面的<a href="#NLM-F-DUMP-请求处理">NLM_F_DUMP 请求处理</a>部分可以看到更多介绍。<a href="#单播数据包分发">单播数据包分发流程</a>可以看到其生效位置。</li>
<li>done<br>与dumpit对应，在dumpit的一个完整逻辑完成后将会调用该处理函数。</li>
<li>cmd<br>该ops对应处理的cmd，对应genlmsghdr中的cmd。</li>
<li>internal_flags<br>family自定义使用，内核不关心该字段。</li>
<li>flags<br>标明该ops中cmd对应的请求，需要进程拥有的权限，<a href="#单播数据包分发">单播数据包分发流程</a>可以看到有对其的检查。</li>
</ul>
<figure class="highlight c"><figcaption><span>组播组名字</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">genl_multicast_group</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>            name[GENL_NAMSIZ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">genl_info</span> &#123;</span></span><br><span class="line">    u32         snd_seq;</span><br><span class="line">    u32         snd_portid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *   <span class="title">nlhdr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">genlmsghdr</span> * <span class="title">genlhdr</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *          userhdr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> **    <span class="title">attrs</span>;</span></span><br><span class="line">    <span class="keyword">possible_net_t</span>      _net;</span><br><span class="line">    <span class="keyword">void</span> *          user_ptr[<span class="number">2</span>];</span><br><span class="line">    RH_KABI_DEPRECATE(struct sock *, dst_sk)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>genl_info由内核generic netlink子系统填充并传递给用户自定义的处理函数，简化用户的解析操作。</p>
<ul>
<li>snd_seq<br>发送方nlmsg_seq。</li>
<li>snd_portid<br>发送方portid。</li>
<li>nlhdr<br>nlmsghdr结构指针。</li>
<li>genlhdr<br>genlmsghdr结构指针。</li>
<li>userhdr<br>genl_family注册时标明长度的自定义头的地址。</li>
<li>attrs<br>内核解析的nlattr指针数组，索引为nla_type，只解析最外层的nlattr。如果相同nla_type的nlattr，后面的会覆盖前面的填充。</li>
<li>_net<br>skb所属sk的net namespace，取对应的net namespace使用函数<code>genl_info_net</code>。</li>
<li>user_ptr<br>这个东西应该是给用户自己使用的，内核不关心。</li>
</ul>
<h3 id="例子代码"><a href="#例子代码" class="headerlink" title="例子代码"></a>例子代码</h3><figure class="highlight c"><figcaption><span>comm.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GENL_EXAMPLE_FAMILY_NAME <span class="meta-string">"genl_exam_name"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    MY_CMD_UNSPEC,</span><br><span class="line">    MY_CMD_PRINT_STR,</span><br><span class="line">    MY_CMD_ADD,</span><br><span class="line">    __MY_CMD_MAX,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_CMD_MAX (__MAX_CMD_MAX -1)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    MY_ATTR_UNSPEC,</span><br><span class="line">    MY_ATTR_STR,</span><br><span class="line">    MY_ATTR_N1,</span><br><span class="line">    MY_ATTR_N2,</span><br><span class="line">    __MY_ATTR_MAX,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_ATTR_MAX (__MY_ATTR_MAX - 1)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>genl_kern.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/skbuff.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/genetlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/sock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"comm.h"</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"Hu Yu &lt;hyuuhit@gmail.com&gt;"</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"generic netlink example"</span>);</span><br><span class="line">MODULE_VERSION(<span class="string">"0.1"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dump_nlhdr</span><span class="params">(struct nlmsghdr *nlhdr)</span> </span>&#123;</span><br><span class="line">    pr_info(<span class="string">"nlh-&gt;nlmsg_len:    %u\n"</span>, nlhdr-&gt;nlmsg_len);</span><br><span class="line">    pr_info(<span class="string">"nlh-&gt;nlmsg_type:   %u\n"</span>, nlhdr-&gt;nlmsg_type);</span><br><span class="line">    pr_info(<span class="string">"nlh-&gt;nlmsg_flags:  %u\n"</span>, nlhdr-&gt;nlmsg_flags);</span><br><span class="line">    pr_info(<span class="string">"nlh-&gt;nlmsg_seq:    %u\n"</span>, nlhdr-&gt;nlmsg_seq);</span><br><span class="line">    pr_info(<span class="string">"nlh-&gt;nlmsg_pid:    %u\n"</span>, nlhdr-&gt;nlmsg_pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dump_genlhdr</span><span class="params">(struct genlmsghdr *genlhdr)</span> </span>&#123;</span><br><span class="line">    pr_info(<span class="string">"genlh-&gt;cmd:        %u\n"</span>, genlhdr-&gt;cmd);</span><br><span class="line">    pr_info(<span class="string">"genlh-&gt;version:    %u\n"</span>, genlhdr-&gt;version);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dump_genl_info</span><span class="params">(struct genl_info *info)</span> </span>&#123;</span><br><span class="line">    dump_nlhdr(info-&gt;nlhdr);</span><br><span class="line">    dump_genlhdr(info-&gt;genlhdr);</span><br><span class="line">    pr_info(<span class="string">"snd_seq:    %u\n"</span>, info-&gt;snd_seq);</span><br><span class="line">    pr_info(<span class="string">"snd_portid: %u\n"</span>, info-&gt;snd_portid);</span><br><span class="line">    pr_info(<span class="string">"attrs:      %s\n"</span>, info-&gt;attrs ? <span class="string">"NOT NULL"</span> : <span class="string">"NULL"</span>);</span><br><span class="line">    <span class="keyword">if</span> (info-&gt;attrs != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pr_info(<span class="string">"%s - %p\n"</span>, <span class="string">"MY_ATTR_STR"</span>, info-&gt;attrs[MY_ATTR_STR]);</span><br><span class="line">        pr_info(<span class="string">"%s - %p\n"</span>, <span class="string">"MY_ATTR_N1"</span>, info-&gt;attrs[MY_ATTR_N1]);</span><br><span class="line">        pr_info(<span class="string">"%s - %p\n"</span>, <span class="string">"MY_ATTR_N2"</span>, info-&gt;attrs[MY_ATTR_N2]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_pre_doit</span><span class="params">(<span class="keyword">const</span> struct genl_ops *ops, struct sk_buff *skb, struct genl_info *info)</span> </span>&#123;</span><br><span class="line">    pr_info(<span class="string">"my_pre_doit\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">print_doit</span><span class="params">(struct sk_buff *skb, struct genl_info *info)</span> </span>&#123;</span><br><span class="line">    pr_info(<span class="string">"print_doit\n"</span>);</span><br><span class="line">    dump_genl_info(info);</span><br><span class="line">    <span class="keyword">if</span> (info-&gt;attrs[MY_ATTR_STR]) &#123;</span><br><span class="line">        pr_info(<span class="string">"print result: %s\n"</span>, (<span class="keyword">char</span> *)nla_data(info-&gt;attrs[MY_ATTR_STR]));</span><br><span class="line">    &#125;</span><br><span class="line">    pr_info(<span class="string">"end print_doit =========================\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add_doit</span><span class="params">(struct sk_buff *skb, struct genl_info *info)</span> </span>&#123;</span><br><span class="line">    pr_info(<span class="string">"add_doit\n"</span>);</span><br><span class="line">    dump_genl_info(info);</span><br><span class="line">    <span class="keyword">if</span> (info-&gt;attrs[MY_ATTR_N1] &amp;&amp; info-&gt;attrs[MY_ATTR_N2]) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = *(u8 *)nla_data(info-&gt;attrs[MY_ATTR_N1]);</span><br><span class="line">        n += *(u8 *)nla_data(info-&gt;attrs[MY_ATTR_N2]);</span><br><span class="line">        pr_info(<span class="string">"add result: %d\n"</span>, n);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    pr_info(<span class="string">"end add_doit   =========================\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_post_doit</span><span class="params">(<span class="keyword">const</span> struct genl_ops *ops, struct sk_buff *skb, struct genl_info *info)</span> </span>&#123;</span><br><span class="line">    pr_info(<span class="string">"my_post_doit\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nla_policy</span> <span class="title">my_policy</span>[] = &#123;</span></span><br><span class="line">    [MY_ATTR_STR] = &#123;</span><br><span class="line">        .type = NLA_NUL_STRING,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">genl_ops</span> <span class="title">my_ops</span>[] = &#123;</span></span><br><span class="line">    &#123;</span><br><span class="line">        .policy = my_policy,</span><br><span class="line">        .doit = print_doit,</span><br><span class="line">        .dumpit = <span class="literal">NULL</span>,</span><br><span class="line">        .done = <span class="literal">NULL</span>,</span><br><span class="line">        .cmd = MY_CMD_PRINT_STR,</span><br><span class="line">        .internal_flags = <span class="number">0</span>,</span><br><span class="line">        .flags = <span class="number">0</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .doit = add_doit,</span><br><span class="line">        .cmd = MY_CMD_ADD,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">genl_multicast_group</span> <span class="title">groups</span>[] = &#123;</span></span><br><span class="line">    &#123;</span><br><span class="line">        .name = <span class="string">"g1"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .name = <span class="string">"g2"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">genl_family</span> <span class="title">family</span> = &#123;</span></span><br><span class="line">    .id = <span class="number">0</span>,</span><br><span class="line">    .name = GENL_EXAMPLE_FAMILY_NAME,</span><br><span class="line">    .hdrsize = <span class="number">0</span>,</span><br><span class="line">    .version = <span class="number">1</span>,</span><br><span class="line">    .maxattr = MY_ATTR_MAX,</span><br><span class="line">    .netnsok = <span class="literal">true</span>,</span><br><span class="line">    .parallel_ops = <span class="literal">false</span>,</span><br><span class="line">    .pre_doit = &amp;my_pre_doit,</span><br><span class="line">    .post_doit = &amp;my_post_doit,</span><br><span class="line">    .ops = my_ops,</span><br><span class="line">    .n_ops = ARRAY_SIZE(my_ops),</span><br><span class="line">    .mcgrps = groups,</span><br><span class="line">    .n_mcgrps = ARRAY_SIZE(groups),</span><br><span class="line">    .<span class="keyword">module</span> = THIS_MODULE,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">my_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">"my init.\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(genl_register_family(&amp;family)) &#123;</span><br><span class="line">        pr_info(<span class="string">"genl_register_family failed\n"</span>);</span><br><span class="line">        pr_info(<span class="string">"====================\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">"====================\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">my_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pr_info(<span class="string">"my exit.\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(genl_unregister_family(&amp;family)) &#123;</span><br><span class="line">        pr_info(<span class="string">"genl_unregister_family failed\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">"====================\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_init);</span><br><span class="line">module_exit(my_exit);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>genl_user.c 重复代码很多，懒得管了</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/genetlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"comm.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> family_id = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * nla_data - head of payload</span></span><br><span class="line"><span class="comment"> * @nla: netlink attribute</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">nla_data</span><span class="params">(<span class="keyword">const</span> struct nlattr *nla)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span> *) nla + NLA_HDRLEN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * nla_ok - check if the netlink attribute fits into the remaining bytes</span></span><br><span class="line"><span class="comment"> * @nla: netlink attribute</span></span><br><span class="line"><span class="comment"> * @remaining: number of bytes remaining in attribute stream</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nla_ok</span><span class="params">(<span class="keyword">const</span> struct nlattr *nla, <span class="keyword">int</span> remaining)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remaining &gt;= (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(*nla) &amp;&amp;</span><br><span class="line">        nla-&gt;nla_len &gt;= <span class="keyword">sizeof</span>(*nla) &amp;&amp;</span><br><span class="line">        nla-&gt;nla_len &lt;= remaining;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * nla_next - next netlink attribute in attribute stream</span></span><br><span class="line"><span class="comment"> * @nla: netlink attribute</span></span><br><span class="line"><span class="comment"> * @remaining: number of bytes remaining in attribute stream</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns the next netlink attribute in the attribute stream and</span></span><br><span class="line"><span class="comment"> * decrements remaining by the size of the current attribute.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct nlattr *<span class="title">nla_next</span><span class="params">(<span class="keyword">const</span> struct nlattr *nla, <span class="keyword">int</span> *remaining)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> totlen = NLA_ALIGN(nla-&gt;nla_len);</span><br><span class="line"></span><br><span class="line">    *remaining -= totlen;</span><br><span class="line">    <span class="keyword">return</span> (struct nlattr *) ((<span class="keyword">char</span> *) nla + totlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_family_id_fill_request</span><span class="params">(<span class="keyword">char</span> *family, <span class="keyword">void</span> *buf, <span class="keyword">int</span> *buf_len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">genlmsghdr</span> *<span class="title">glh</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">nla</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// attr 长度</span></span><br><span class="line">    len += NLA_ALIGN(NLA_HDRLEN + <span class="built_in">strlen</span>(family) + <span class="number">1</span>) ;</span><br><span class="line">    <span class="comment">// + genelmsghdr + pad 长度</span></span><br><span class="line">    len += GENL_HDRLEN;</span><br><span class="line">    <span class="comment">// + nlmsghdr + pad 长度</span></span><br><span class="line">    len = NLMSG_SPACE(len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= *buf_len) &#123;</span><br><span class="line">        *buf_len = len;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nlh = buf;</span><br><span class="line">    glh = NLMSG_DATA(buf);</span><br><span class="line">    nla = (struct nlattr *)((<span class="keyword">char</span> *)glh + GENL_HDRLEN);</span><br><span class="line"></span><br><span class="line">    nlh-&gt;nlmsg_len = len;</span><br><span class="line">    nlh-&gt;nlmsg_type = GENL_ID_CTRL;</span><br><span class="line">    nlh-&gt;nlmsg_flags = NLM_F_REQUEST;</span><br><span class="line">    <span class="comment">// 用于判断请求响应对应情况，先随便填一个。</span></span><br><span class="line">    nlh-&gt;nlmsg_seq = <span class="number">299</span>;</span><br><span class="line">    nlh-&gt;nlmsg_pid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    glh-&gt;cmd = CTRL_CMD_GETFAMILY;</span><br><span class="line">    glh-&gt;version = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    nla-&gt;nla_type = CTRL_ATTR_FAMILY_NAME;</span><br><span class="line">    nla-&gt;nla_len = NLA_HDRLEN + <span class="built_in">strlen</span>(family) + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="keyword">void</span> *)nla + NLA_HDRLEN, family, <span class="built_in">strlen</span>(family) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">nla_ctrl_type_to_string</span><span class="params">(__u16 nla_type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (nla_type) &#123;</span><br><span class="line">        <span class="keyword">case</span> CTRL_ATTR_FAMILY_NAME:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"family name"</span>;</span><br><span class="line">        <span class="keyword">case</span> CTRL_ATTR_FAMILY_ID:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"family id"</span>;</span><br><span class="line">        <span class="keyword">case</span> CTRL_ATTR_VERSION:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"version"</span>;</span><br><span class="line">        <span class="keyword">case</span> CTRL_ATTR_HDRSIZE:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"hdrsize"</span>;</span><br><span class="line">        <span class="keyword">case</span> CTRL_ATTR_MAXATTR:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"maxattr"</span>;</span><br><span class="line">        <span class="keyword">case</span> CTRL_ATTR_OPS:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"ops"</span>;</span><br><span class="line">        <span class="keyword">case</span> CTRL_ATTR_MCAST_GROUPS:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"mcast_groups"</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"unknown"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parse_nla_msg_mcast_group_content</span><span class="params">(<span class="keyword">const</span> struct nlattr *nla, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; nla_ok(nla, len); nla = nla_next(nla, &amp;len)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nla-&gt;nla_type == CTRL_ATTR_MCAST_GRP_ID) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">", id: %u"</span>, *(__u32*)nla_data(nla));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nla-&gt;nla_type == CTRL_ATTR_MCAST_GRP_NAME) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">", name: %s"</span>, (<span class="keyword">char</span> *)nla_data(nla));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">", unknown type %u"</span>, nla-&gt;nla_type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parse_nla_msg_mcast_groups_array</span><span class="params">(<span class="keyword">const</span> struct nlattr *nla, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; nla_ok(nla, len); nla = nla_next(nla, &amp;len)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"  %u group"</span>, nla-&gt;nla_type);</span><br><span class="line">        parse_nla_msg_mcast_group_content(nla_data(nla), nla-&gt;nla_len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parse_nla_msg_op_content</span><span class="params">(<span class="keyword">const</span> struct nlattr *nla, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; nla_ok(nla, len); nla = nla_next(nla, &amp;len)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nla-&gt;nla_type == CTRL_ATTR_OP_ID) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">", id: %u"</span>, *(__u8*)nla_data(nla));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nla-&gt;nla_type == CTRL_ATTR_OP_FLAGS) &#123;</span><br><span class="line">            <span class="keyword">int</span> exist = <span class="number">0</span>;</span><br><span class="line">            __u8 flags = *(__u8*)nla_data(nla);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">", flags: 0x%02x - "</span>, flags);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (flags &amp; GENL_CMD_CAP_DUMP) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"GENL_CMD_CAP_DUMP "</span>);</span><br><span class="line">                exist = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; GENL_CMD_CAP_DO) &#123;</span><br><span class="line">                <span class="keyword">if</span> (exist)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"| "</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"GENL_CMD_CAP_DO "</span>);</span><br><span class="line">                exist = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; GENL_CMD_CAP_HASPOL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (exist) </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"| "</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"GENL_CMD_CAP_HASPOL "</span>);</span><br><span class="line">                exist = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; (~(GENL_CMD_CAP_DUMP | GENL_CMD_CAP_DO | GENL_CMD_CAP_HASPOL))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (exist)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"| "</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"0x%02x"</span>, flags &amp; (~(GENL_CMD_CAP_DUMP | GENL_CMD_CAP_DO | GENL_CMD_CAP_HASPOL)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parse_nla_msg_ops_array</span><span class="params">(<span class="keyword">const</span> struct nlattr *nla, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; nla_ok(nla, len); nla = nla_next(nla, &amp;len)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"  %u op"</span>, nla-&gt;nla_type);</span><br><span class="line">        parse_nla_msg_op_content(nla_data(nla), nla-&gt;nla_len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parse_nla_msg</span><span class="params">(struct nlattr *nla, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; nla_ok(nla, len); nla = nla_next(nla, &amp;len)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"len: %u, type: %u - %s: "</span>, nla-&gt;nla_len, nla-&gt;nla_type, nla_ctrl_type_to_string(nla-&gt;nla_type));</span><br><span class="line">        <span class="keyword">if</span> (nla-&gt;nla_type == CTRL_ATTR_FAMILY_NAME) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, (<span class="keyword">char</span> *)nla + NLA_HDRLEN);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nla-&gt;nla_type == CTRL_ATTR_FAMILY_ID) &#123;</span><br><span class="line">            __u16 num = *(__u16 *)((<span class="keyword">void</span> *)nla + NLA_HDRLEN);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%u\n"</span>, num);</span><br><span class="line">            family_id = num;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nla-&gt;nla_type == CTRL_ATTR_VERSION ||</span><br><span class="line">                nla-&gt;nla_type == CTRL_ATTR_HDRSIZE ||</span><br><span class="line">                nla-&gt;nla_type == CTRL_ATTR_MAXATTR) &#123;</span><br><span class="line">            __u32 num = *(__u32 *)((<span class="keyword">void</span> *)nla + NLA_HDRLEN);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%u\n"</span>, num);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nla-&gt;nla_type == CTRL_ATTR_OPS) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            parse_nla_msg_ops_array(nla_data(nla), nla-&gt;nla_len);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nla-&gt;nla_type == CTRL_ATTR_MCAST_GROUPS) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            parse_nla_msg_mcast_groups_array(nla_data(nla), nla-&gt;nla_len);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">get_ctrl_cmd_name</span><span class="params">(<span class="keyword">int</span> cmd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> CTRL_CMD_UNSPEC:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"CTRL_CMD_UNSPEC"</span>;</span><br><span class="line">        <span class="keyword">case</span> CTRL_CMD_NEWFAMILY:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"CTRL_CMD_NEWFAMILY"</span>;</span><br><span class="line">        <span class="keyword">case</span> CTRL_CMD_DELFAMILY:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"CTRL_CMD_DELFAMILY"</span>;</span><br><span class="line">        <span class="keyword">case</span> CTRL_CMD_GETFAMILY:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"CTRL_CMD_GETFAMILY"</span>;</span><br><span class="line">        <span class="keyword">case</span> CTRL_CMD_NEWOPS:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"CTRL_CMD_NEWOPS"</span>;</span><br><span class="line">        <span class="keyword">case</span> CTRL_CMD_DELOPS:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"CTRL_CMD_DELOPS"</span>;</span><br><span class="line">        <span class="keyword">case</span> CTRL_CMD_GETOPS:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"CTRL_CMD_GETOPS"</span>;</span><br><span class="line">        <span class="keyword">case</span> CTRL_CMD_NEWMCAST_GRP:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"CTRL_CMD_NEWMCAST_GRP"</span>;</span><br><span class="line">        <span class="keyword">case</span> CTRL_CMD_DELMCAST_GRP:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"CTRL_CMD_DELMCAST_GRP"</span>;</span><br><span class="line">        <span class="keyword">case</span> CTRL_CMD_GETMCAST_GRP:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"CTRL_CMD_GETMCAST_GRP"</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"unknown"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parse_genl_msg</span><span class="params">(struct genlmsghdr *glh, <span class="keyword">int</span> len, <span class="keyword">int</span> ctrl)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">nla</span> = (<span class="title">struct</span> <span class="title">nlattr</span> *)((<span class="title">char</span> *)<span class="title">glh</span> + <span class="title">GENL_HDRLEN</span>);</span></span><br><span class="line">    <span class="keyword">int</span> nlalen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt; GENL_HDRLEN) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nlalen = len - GENL_HDRLEN;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"glh cmd    : %u"</span>, glh-&gt;cmd);</span><br><span class="line">    <span class="keyword">if</span> (ctrl)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" - %s\n"</span>, get_ctrl_cmd_name(glh-&gt;cmd));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"glh version: %u\n"</span>, glh-&gt;version);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"nla all len: %d\n"</span>, nlalen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-----------------------\n"</span>);</span><br><span class="line"></span><br><span class="line">    parse_nla_msg(nla, nlalen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parse_nl_msg</span><span class="params">(struct nlmsghdr *nlh, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; NLMSG_HDRLEN) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;NLMSG_OK(nlh, len); nlh = NLMSG_NEXT(nlh, len)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"nlmsg_len  : %u\n"</span>, nlh-&gt;nlmsg_len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"nlmsg_type : %u"</span>, nlh-&gt;nlmsg_type);</span><br><span class="line">        <span class="keyword">if</span> (nlh-&gt;nlmsg_type == GENL_ID_CTRL)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" - %s\n"</span>, <span class="string">"GENL_ID_CTRL"</span>);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"nlmsg_flags: %u\n"</span>, nlh-&gt;nlmsg_flags);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"nlmsg_seq  : %u\n"</span>, nlh-&gt;nlmsg_seq);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"nlmsg_pid  : %u\n"</span>, nlh-&gt;nlmsg_pid);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-----------------------\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nlh-&gt;nlmsg_type == NLMSG_ERROR) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">nlmsgerr</span> *<span class="title">err</span> = <span class="title">NLMSG_DATA</span>(<span class="title">nlh</span>);</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"errno %d, "</span>, err-&gt;error);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, strerror(<span class="built_in">abs</span>(err-&gt;error)));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"&gt;&gt;&gt;\n"</span>);</span><br><span class="line">            parse_nl_msg(&amp;(err-&gt;msg), nlh-&gt;nlmsg_len - NLMSG_HDRLEN);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"&lt;&lt;&lt;\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nlh-&gt;nlmsg_type == GENL_ID_CTRL) &#123;</span><br><span class="line">            parse_genl_msg(NLMSG_DATA(nlh), nlh-&gt;nlmsg_len - NLMSG_HDRLEN, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parse_genl_msg(NLMSG_DATA(nlh), nlh-&gt;nlmsg_len - NLMSG_HDRLEN, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-----------------------\n\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test_print_request</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> family_id, <span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">genlmsghdr</span> *<span class="title">glh</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">nla</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1500</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> <span class="title">dest_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// attr 长度</span></span><br><span class="line">    len += NLA_ALIGN(NLA_HDRLEN + <span class="built_in">strlen</span>(str) + <span class="number">1</span>) ;</span><br><span class="line">    <span class="comment">// + genelmsghdr + pad 长度</span></span><br><span class="line">    len += GENL_HDRLEN;</span><br><span class="line">    <span class="comment">// + nlmsghdr + pad 长度</span></span><br><span class="line">    len = NLMSG_SPACE(len);</span><br><span class="line"></span><br><span class="line">    nlh = (struct nlmsghdr *)buf;</span><br><span class="line">    glh = NLMSG_DATA(buf);</span><br><span class="line">    nla = (struct nlattr *)((<span class="keyword">char</span> *)glh + GENL_HDRLEN);</span><br><span class="line"></span><br><span class="line">    nlh-&gt;nlmsg_len = len;</span><br><span class="line">    nlh-&gt;nlmsg_type = family_id;</span><br><span class="line">    nlh-&gt;nlmsg_flags = NLM_F_REQUEST;</span><br><span class="line">    <span class="comment">// 用于判断请求响应对应情况，先随便填一个。</span></span><br><span class="line">    nlh-&gt;nlmsg_seq = <span class="number">300</span>;</span><br><span class="line">    nlh-&gt;nlmsg_pid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    glh-&gt;cmd = MY_CMD_PRINT_STR;</span><br><span class="line">    glh-&gt;version = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    nla-&gt;nla_type = MY_ATTR_STR;</span><br><span class="line">    nla-&gt;nla_len = NLA_HDRLEN + <span class="built_in">strlen</span>(str) + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="keyword">void</span> *)nla + NLA_HDRLEN, str, <span class="built_in">strlen</span>(str) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;dest_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(dest_addr));</span><br><span class="line">    dest_addr.nl_family = AF_NETLINK;</span><br><span class="line">    dest_addr.nl_pid = <span class="number">0</span>;</span><br><span class="line">    dest_addr.nl_groups = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    err = sendto(fd, buf, len, <span class="number">0</span>, (struct sockaddr *)&amp;dest_addr, (<span class="keyword">socklen_t</span>)<span class="keyword">sizeof</span>(dest_addr));</span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"sendto failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test_add_request</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> family_id, <span class="keyword">int</span> fd, __u8 n1, __u8 n2)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">genlmsghdr</span> *<span class="title">glh</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">nla</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1500</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> <span class="title">dest_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// attr 长度</span></span><br><span class="line">    len += NLA_ALIGN(NLA_HDRLEN + <span class="keyword">sizeof</span>(__u8)) ;</span><br><span class="line">    len += NLA_ALIGN(NLA_HDRLEN + <span class="keyword">sizeof</span>(__u8)) ;</span><br><span class="line">    <span class="comment">// + genelmsghdr + pad 长度</span></span><br><span class="line">    len += GENL_HDRLEN;</span><br><span class="line">    <span class="comment">// + nlmsghdr + pad 长度</span></span><br><span class="line">    len = NLMSG_SPACE(len);</span><br><span class="line"></span><br><span class="line">    nlh = (struct nlmsghdr *)buf;</span><br><span class="line">    glh = NLMSG_DATA(buf);</span><br><span class="line">    nla = (struct nlattr *)((<span class="keyword">char</span> *)glh + GENL_HDRLEN);</span><br><span class="line"></span><br><span class="line">    nlh-&gt;nlmsg_len = len;</span><br><span class="line">    nlh-&gt;nlmsg_type = family_id;</span><br><span class="line">    nlh-&gt;nlmsg_flags = NLM_F_REQUEST;</span><br><span class="line">    <span class="comment">// 用于判断请求响应对应情况，先随便填一个。</span></span><br><span class="line">    nlh-&gt;nlmsg_seq = <span class="number">301</span>;</span><br><span class="line">    nlh-&gt;nlmsg_pid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    glh-&gt;cmd = MY_CMD_ADD;</span><br><span class="line">    glh-&gt;version = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    nla-&gt;nla_type = MY_ATTR_N1;</span><br><span class="line">    nla-&gt;nla_len = NLA_HDRLEN + <span class="keyword">sizeof</span>(__u8);</span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="keyword">void</span> *)nla + NLA_HDRLEN, &amp;n1, <span class="keyword">sizeof</span>(__u8));</span><br><span class="line"></span><br><span class="line">    nla = (struct nlattr *)((<span class="keyword">char</span> *)nla + NLA_ALIGN(NLA_HDRLEN + <span class="keyword">sizeof</span>(__u8)));</span><br><span class="line">    nla-&gt;nla_type = MY_ATTR_N2;</span><br><span class="line">    nla-&gt;nla_len = NLA_HDRLEN + <span class="keyword">sizeof</span>(__u8);</span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="keyword">void</span> *)nla + NLA_HDRLEN, &amp;n2, <span class="keyword">sizeof</span>(__u8));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;dest_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(dest_addr));</span><br><span class="line">    dest_addr.nl_family = AF_NETLINK;</span><br><span class="line">    dest_addr.nl_pid = <span class="number">0</span>;</span><br><span class="line">    dest_addr.nl_groups = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    err = sendto(fd, buf, len, <span class="number">0</span>, (struct sockaddr *)&amp;dest_addr, (<span class="keyword">socklen_t</span>)<span class="keyword">sizeof</span>(dest_addr));</span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"sendto failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> <span class="title">dest_addr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1500</span>];</span><br><span class="line">    <span class="keyword">int</span> buf_len = <span class="keyword">sizeof</span>(buf);</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"my pid: %d\n"</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"NLMSG_HDRLEN: %d\n"</span>, NLMSG_HDRLEN);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"GENL_HDRLEN: %d\n"</span>, GENL_HDRLEN);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"NLA_HDRLEN: %d\n"</span>, NLA_HDRLEN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create */</span></span><br><span class="line">    fd = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_GENERIC);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"socekt failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (get_family_id_fill_request(GENL_EXAMPLE_FAMILY_NAME, buf, &amp;buf_len)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"get_family_id_fill_request failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* send */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;dest_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(dest_addr));</span><br><span class="line">    dest_addr.nl_family = AF_NETLINK;</span><br><span class="line">    dest_addr.nl_pid = <span class="number">0</span>;</span><br><span class="line">    dest_addr.nl_groups = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    err = sendto(fd, buf, buf_len, <span class="number">0</span>, (struct sockaddr *)&amp;dest_addr, (<span class="keyword">socklen_t</span>)<span class="keyword">sizeof</span>(dest_addr));</span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"sendto failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"send len %d\n"</span>, err);</span><br><span class="line"></span><br><span class="line">    err = recv(fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"recv failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"recv len %d\n"</span>, err);</span><br><span class="line">    parse_nl_msg((struct nlmsghdr *)buf, err);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (family_id &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (test_print_request(family_id, fd, <span class="string">"test genl print str request"</span>)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"test_print_request failed\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (test_add_request(family_id, fd, <span class="number">2</span>, <span class="number">5</span>)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"test_add_request failed\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><figcaption><span>Makefile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">obj-m := genl_kern.o</span><br><span class="line"></span><br><span class="line">PWD:=<span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line">KVER:=<span class="variable">$(<span class="built_in">shell</span> uname -r)</span></span><br><span class="line">KDIR:=/lib/modules/<span class="variable">$(KVER)</span>/build</span><br><span class="line"></span><br><span class="line">EXTRA_CFLAGS += -Wall -g</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:all</span></span><br><span class="line"><span class="section">all: kernel genl_user</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:kernel</span></span><br><span class="line"><span class="section">kernel:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">genl_user: genl_user.c</span></span><br><span class="line">    gcc <span class="variable">$(EXTRA_CFLAGS)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean</span><br><span class="line">    rm -f genl_user</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>genl_user 输出</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">my pid: 26758</span><br><span class="line">NLMSG_HDRLEN: 16</span><br><span class="line">GENL_HDRLEN: 4</span><br><span class="line">NLA_HDRLEN: 4</span><br><span class="line">send len 40</span><br><span class="line">recv len 160</span><br><span class="line">nlmsg_len  : 160</span><br><span class="line">nlmsg_type : 16 - GENL_ID_CTRL</span><br><span class="line">nlmsg_flags: 0</span><br><span class="line">nlmsg_seq  : 299</span><br><span class="line">nlmsg_pid  : 26758</span><br><span class="line">-----------------------</span><br><span class="line">glh cmd    : 1 - CTRL_CMD_NEWFAMILY</span><br><span class="line">glh version: 2</span><br><span class="line">nla all len: 140</span><br><span class="line">-----------------------</span><br><span class="line">len: 19, type: 2 - family name: genl_exam_name</span><br><span class="line">len: 6, type: 1 - family id: 27</span><br><span class="line">len: 8, type: 3 - version: 1</span><br><span class="line">len: 8, type: 4 - hdrsize: 0</span><br><span class="line">len: 8, type: 5 - maxattr: 3</span><br><span class="line">len: 44, type: 6 - ops:</span><br><span class="line">  1 op, id: 1, flags: 0x0a - GENL_CMD_CAP_DO | GENL_CMD_CAP_HASPOL</span><br><span class="line">  2 op, id: 2, flags: 0x02 - GENL_CMD_CAP_DO</span><br><span class="line">len: 44, type: 7 - mcast_groups:</span><br><span class="line">  1 group, id: 4, name: g1</span><br><span class="line">  2 group, id: 5, name: g2</span><br><span class="line">-----------------------</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>dmesg 输出</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[985691.316473] my init.</span><br><span class="line">[985691.316502] ====================</span><br><span class="line">[985694.636004] my_pre_doit</span><br><span class="line">[985694.636009] print_doit</span><br><span class="line">[985694.636011] nlh-&gt;nlmsg_len:    52</span><br><span class="line">[985694.636012] nlh-&gt;nlmsg_type:   27</span><br><span class="line">[985694.636013] nlh-&gt;nlmsg_flags:  1</span><br><span class="line">[985694.636014] nlh-&gt;nlmsg_seq:    300</span><br><span class="line">[985694.636015] nlh-&gt;nlmsg_pid:    0</span><br><span class="line">[985694.636016] genlh-&gt;cmd:        1</span><br><span class="line">[985694.636017] genlh-&gt;version:    1</span><br><span class="line">[985694.636018] snd_seq:    300</span><br><span class="line">[985694.636019] snd_portid: 26758</span><br><span class="line">[985694.636021] attrs:      NOT NULL</span><br><span class="line">[985694.636022] MY_ATTR_STR - ffff967ef6a1b214</span><br><span class="line">[985694.636024] MY_ATTR_N1 -           (null)</span><br><span class="line">[985694.636025] MY_ATTR_N2 -           (null)</span><br><span class="line">[985694.636026] print result: test genl print str request</span><br><span class="line">[985694.636027] end print_doit =========================</span><br><span class="line">[985694.636028] my_post_doit</span><br><span class="line">[985694.636030] my_pre_doit</span><br><span class="line">[985694.636031] add_doit</span><br><span class="line">[985694.636032] nlh-&gt;nlmsg_len:    36</span><br><span class="line">[985694.636033] nlh-&gt;nlmsg_type:   27</span><br><span class="line">[985694.636034] nlh-&gt;nlmsg_flags:  1</span><br><span class="line">[985694.636035] nlh-&gt;nlmsg_seq:    301</span><br><span class="line">[985694.636036] nlh-&gt;nlmsg_pid:    0</span><br><span class="line">[985694.636037] genlh-&gt;cmd:        2</span><br><span class="line">[985694.636038] genlh-&gt;version:    1</span><br><span class="line">[985694.636039] snd_seq:    301</span><br><span class="line">[985694.636040] snd_portid: 26758</span><br><span class="line">[985694.636041] attrs:      NOT NULL</span><br><span class="line">[985694.636042] MY_ATTR_STR -           (null)</span><br><span class="line">[985694.636043] MY_ATTR_N1 - ffff967ef6a1b214</span><br><span class="line">[985694.636044] MY_ATTR_N2 - ffff967ef6a1b21c</span><br><span class="line">[985694.636045] add result: 7</span><br><span class="line">[985694.636046] end add_doit   =========================</span><br><span class="line">[985694.636047] my_post_doit</span><br><span class="line">[985706.885696] my exit.</span><br><span class="line">[985706.885711] ====================</span><br></pre></td></tr></table></figure>
<h2 id="generic-netlink-实现"><a href="#generic-netlink-实现" class="headerlink" title="generic netlink 实现"></a>generic netlink 实现</h2><p>generic netlink的实现代码位于<code>/net/netlink/genetlink</code></p>
<p>实现原理上可以简单描述如下:</p>
<ul>
<li>组播依赖netlink的原生组播功能，generic netlink负责对组播组id进行分配管理。</li>
<li>单播由netlink传递到generic netlink消息总线（这个消息总线就是一个统一的处理入口函数），通过family id定位到genl_family，进一步通过cmd定位到genl_ops进行处理。</li>
<li>controller服务负责对family name和family id进行名字翻译处理，controller的family id是固定的<code>GENL_ID_CTRL</code>。</li>
</ul>
<p>下面是<a href="https://wiki.linuxfoundation.org/networking/generic_netlink_howto" target="_blank" rel="noopener">generic netlink howto</a>（文章中数据结构已经比较旧）中描述的基本架构图。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    +---------------------+      +---------------------+</span><br><span class="line">    | (3) application &quot;A&quot; |      | (3) application &quot;B&quot; |</span><br><span class="line">    +------+--------------+      +--------------+------+</span><br><span class="line">           |                                    |</span><br><span class="line">           \                                    /</span><br><span class="line">            \                                  /</span><br><span class="line">             |                                |</span><br><span class="line">     +-------+--------------------------------+-------+</span><br><span class="line">     |        :                               :       |   user-space</span><br><span class="line">=====+        :   (5)  kernel socket API      :       +================</span><br><span class="line">     |        :                               :       |   kernel-space</span><br><span class="line">     +--------+-------------------------------+-------+</span><br><span class="line">              |                               |</span><br><span class="line">        +-----+-------------------------------+----+</span><br><span class="line">        |        (1)  Netlink subsystem            |</span><br><span class="line">        +---------------------+--------------------+</span><br><span class="line">                              |</span><br><span class="line">        +---------------------+--------------------+</span><br><span class="line">        |       (2) Generic Netlink bus            |</span><br><span class="line">        +--+--------------------------+-------+----+</span><br><span class="line">           |                          |       |</span><br><span class="line">   +-------+---------+                |       |</span><br><span class="line">   |  (4) controller |               /         \</span><br><span class="line">   +-----------------+              /           \</span><br><span class="line">                                    |           |</span><br><span class="line">                 +------------------+--+     +--+------------------+</span><br><span class="line">                 | (3) kernel user &quot;X&quot; |     | (3) kernel user &quot;Y&quot; |</span><br><span class="line">                 +---------------------+     +---------------------+</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>generic netlink的初始化工作由函数<code>genl_init</code>完成。</p>
<figure class="highlight c"><figcaption><span>genl_init</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">genl_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    err = genl_register_family(&amp;genl_ctrl);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> problem;</span><br><span class="line"></span><br><span class="line">    err = register_pernet_subsys(&amp;genl_pernet_ops);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> problem;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">problem:</span><br><span class="line">    panic(<span class="string">"GENL: Cannot register controller: %d\n"</span>, err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数内容很少，两个功能。</p>
<ul>
<li>通过函数genl_register_family在generic netlink协议下注册了一个controller名字服务。<ul>
<li>genl_register_family的实现包含了generic netlink如果通过自定义协议名承载·</li>
<li>controller与用户的自定义协议使用同样的api注册，实现了通过自定义协议名查询相关信息的功能(比如id和广播组)。</li>
</ul>
</li>
<li>为每个net namespace注册了函数调用。<br>这个函数会对每个net namespace(包括未来创建的新的net namespace)执行，用于在netlink协议族上注册generic netlink协议。</li>
</ul>
<p>这两个工作完成的先后并没有严格的依赖关系。先看对每个net namespace注册的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pernet_operations</span> <span class="title">genl_pernet_ops</span> = &#123;</span></span><br><span class="line">    .init = genl_pernet_init,</span><br><span class="line">    .<span class="built_in">exit</span> = genl_pernet_exit,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">net_init <span class="title">genl_pernet_init</span><span class="params">(struct net *net)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">netlink_kernel_cfg</span> <span class="title">cfg</span> = &#123;</span></span><br><span class="line">        .input      = genl_rcv,</span><br><span class="line">        .flags      = NL_CFG_F_NONROOT_RECV,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we'll bump the group number right afterwards */</span></span><br><span class="line">    net-&gt;genl_sock = netlink_kernel_create(net, NETLINK_GENERIC, &amp;cfg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!net-&gt;genl_sock &amp;&amp; net_eq(net, &amp;init_net))</span><br><span class="line">        panic(<span class="string">"GENL: Cannot initialize generic netlink\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!net-&gt;genl_sock)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到函数<code>genl_pernet_init</code>就很好理解了，结合之前netlink的介绍，就是在netlink协议族上注册协议号为<code>NETLINK_GENERIC</code>的协议，允许非特权用户接收广播，数据包在内核的接收处理函数为<code>genl_rcv</code>，每个net namespace中创建的sk赋值给<code>net-&gt;genl_sock</code>用于内核发送generic netlink数据包时使用。用户态发送给内核的所有generic netlink数据包，不区分协议名，入口处理函数都是<code>genl_rcv</code>，这个函数我们晚一点再看，先看一下<code>genl_register_family</code>如何注册一个自定义协议到generaic netlink上，然后再看<code>genl_rcv</code>如何将数据包分发给不同的自定义协议。</p>
<h3 id="自定义协议注册"><a href="#自定义协议注册" class="headerlink" title="自定义协议注册"></a>自定义协议注册</h3><p><code>genl_register_family</code>主要完成两个功能：</p>
<ul>
<li>为注册的genl_family分配一个唯一id，并将指针保存起来后续将使用</li>
<li>如果注册有组播，还会为组播分配连续id的组播组，其实组播组id记录在mcgrp_offset字段中</li>
</ul>
<figure class="highlight plain"><figcaption><span>genl_register_family 流程</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+--------------------+</span><br><span class="line">|genl_register_family|</span><br><span class="line">+---+----------------+</span><br><span class="line">    |</span><br><span class="line">    |      +-----------------+</span><br><span class="line">    +------+genl_validate_ops|</span><br><span class="line">    |      +-----------------+</span><br><span class="line">    |      通过genl_family字段n_ops指明的genl_ops个数，遍历所有ops</span><br><span class="line">    |      确保每个ops中dumpid和doit两个函数指针至少有一个不为NULL</span><br><span class="line">    |      同时确保各个ops中要处理的cmd没有冲突</span><br><span class="line">    |</span><br><span class="line">    |      +-------------------------------------------------------------+</span><br><span class="line">    +------+通过函数genl_family_find_by_name查找是否存在同名的genl_family|</span><br><span class="line">    |      |如果存在同名，返回-EEXIST错误                                |</span><br><span class="line">    |      +-------------------------------------------------------------+</span><br><span class="line">    |</span><br><span class="line">    |      +--------------------------------------------------------+</span><br><span class="line">    +------|如果传入的是内核预留的对几个协议，那么做特殊处理，确定id|</span><br><span class="line">    |      +--------------------------------------------------------+</span><br><span class="line">    |       PS:自定义协议不应该使用任何固定id，而应该在注册时将id置0，让系统自动分配id</span><br><span class="line">    |</span><br><span class="line">    |      +-------------------------------------------------------------------------+</span><br><span class="line">    +------+如果maxattr不为0，同时parallel_ops为假                                   |</span><br><span class="line">    |      |那么为attrbuf字段分配内存，大小为maxattr+1个指针，指针类型为struct nlattr|</span><br><span class="line">    |      +-------------------------------------------------------------------------+</span><br><span class="line">    |       内核对数据包的处理位于系统调用也就是进程上下文，是有能力并发的，但是genl提供了串行的选项，</span><br><span class="line">    |       当串行时，就可以利用attrbuf作为该协议所有请求的genl_info中attrs字段的缓存，反复利用。</span><br><span class="line">    |       这样就避免了多余的内存分配。genl_info的填充将在数据包分发中介绍。</span><br><span class="line">    |</span><br><span class="line">    |      +---------+</span><br><span class="line">    +------+idr_alloc|</span><br><span class="line">    |      +---------+</span><br><span class="line">    |       为genl_family的id字段，分配一个generic netlink协议内唯一的id。</span><br><span class="line">    |       这个id用于唯一定位一个自定义协议</span><br><span class="line">    |</span><br><span class="line">    |      +-----------------------------+</span><br><span class="line">    +------+genl_validate_assign_mc_group|</span><br><span class="line">    |      +----+------------------------+</span><br><span class="line">    |           |</span><br><span class="line">    |           |        +-------------------------------------------------------+</span><br><span class="line">    |           +--------+根据genl_family中n_mcgrps遍历mcgrps字段，              |</span><br><span class="line">    |           |        |确保每个多播组名字字符串长度大于0小于16（包含结尾&apos;\0&apos;）|</span><br><span class="line">    |           |        +-------------------------------------------------------+</span><br><span class="line">    |           |</span><br><span class="line">    |           |        +--------------------------------+</span><br><span class="line">    |           +--------+如果传入的是内核预留的几个协议  |</span><br><span class="line">    |           |        |那么做特殊处理，确定使用的组播id|</span><br><span class="line">    |           |        +--------------------------------+</span><br><span class="line">    |           |</span><br><span class="line">    |           |        +----------------------------+</span><br><span class="line">    |           +--------+genl_allocate_reserve_groups|</span><br><span class="line">    |           |        +----------------------------+</span><br><span class="line">    |           |         组播涉及三个全局变量</span><br><span class="line">    |           |         mc_groups是组播位图</span><br><span class="line">    |           |         mc_groups_longs是组播位图占用了几个long类型</span><br><span class="line">    |           |         mc_group_start没啥大用，只是mc_groups初始指向的地址，占用一个long</span><br><span class="line">    |           |         这个函数在mc_groups位图中按顺序查找未被占用的连续n_mcgrps位，</span><br><span class="line">    |           |         如果位图空间不足则会扩充mc_groups空间，直到找到连续的n_mcgrps位，并标记为占用。</span><br><span class="line">    |           |         然后将起始的位数传递回去。</span><br><span class="line">    |           |</span><br><span class="line">    |           |        +----------------------------------------------+</span><br><span class="line">    |           +--------+上一步传回的组播组起始id赋值给mcgrp_offset，  |</span><br><span class="line">    |           |        |这个值与n_mcgrps配合记录了该协议的所有组播组id|</span><br><span class="line">    |           |        +----------------------------------------------+</span><br><span class="line">    |           |</span><br><span class="line">    |           |        +------------------------+</span><br><span class="line">    |           +--------+__netlink_change_ngroups|</span><br><span class="line">    |           |        +------------------------+</span><br><span class="line">    |           |         这个函数会比较传入的组播组数与nl_table中相应的组播组数，</span><br><span class="line">    |           |         在需要时更新nl_table中的组播位图空间。</span><br><span class="line">    |           |         这里在genl_family字段netnsok时遍历了所有的net namespace，</span><br><span class="line">    |           |         但nl_table是全局数组，这个遍历相比只执行一次应该不会有额外的作用。</span><br><span class="line">    |           |</span><br><span class="line">    |           |        +--------------------------------+</span><br><span class="line">    |&lt;----------+--------+没有出错的情况下，函数可以返回了|</span><br><span class="line">    |                    +--------------------------------+</span><br><span class="line">    |                     可以看到generic netlink的组播完全依赖netlink的组播机制，</span><br><span class="line">    |                     generic netlink只是自己管理了自定义协议组播组id的分配，</span><br><span class="line">    |                     然后根据id的分配情况，扩充netlink的组播组位图。</span><br><span class="line">    |            </span><br><span class="line">    |      +---------------+</span><br><span class="line">    +------+genl_ctrl_event|    </span><br><span class="line">    |      +---------------+</span><br><span class="line">    |       生成一个CTRL_CMD_NEWFAMILY事件组播发送给预留组播组GENL_ID_CTRL</span><br><span class="line">    |       为每一个新增的组播组生成一个CTRL_CMD_NEWMCAST事件发送给预留组播组GENL_ID_CTRL</span><br><span class="line">    |           </span><br><span class="line">    v         </span><br><span class="line">  返回</span><br></pre></td></tr></table></figure>
<h3 id="单播数据包分发"><a href="#单播数据包分发" class="headerlink" title="单播数据包分发"></a>单播数据包分发</h3><p>通过前面的注册流程可以看到generic netlink组播依赖netlink的组播机制，这里继续看单播数据包的是如何分发的。之前分析过netlink内核收包流程，这里直接分析generic netlink在内核的收包处理函数<code>genl_rcv</code></p>
<figure class="highlight plain"><figcaption><span>genl_rcv 流程</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">+--------+</span><br><span class="line">|genl_rcv|</span><br><span class="line">+---+----+</span><br><span class="line">    |</span><br><span class="line">    |   +-----------------------------------------------------------+</span><br><span class="line">    |   |           netlink_rcv_skb(skb, &amp;genl_rcv_msg)             |</span><br><span class="line">    |   |                                                           |</span><br><span class="line">    |   |这个函数中做了一些对netlink消息头nlmsghdr的合法性检查，    |</span><br><span class="line">    +---+之前说过netlink协议单纯发数据并不依赖nlmsghdr头，          |</span><br><span class="line">    |   |但在generic netlink使用中，必须遵循generic netlink的要求， |</span><br><span class="line">    |   |因此nlmsghdr和genlmsghdr头都是必须包含且填写正确的。       |</span><br><span class="line">    |   +--+--------------------------------------------------------+</span><br><span class="line">    |      |</span><br><span class="line">    |      |   +-------------------------------------------------+</span><br><span class="line">    |      +---+根据skb数据长度循环处理每个nlmsghdr及其包含的数据|</span><br><span class="line">    |      |   +--+----------------------------------------------+</span><br><span class="line">    |      |      |</span><br><span class="line">    |      |      |   +--------------------------------------------------------------------------------+</span><br><span class="line">    |      |      |   |检查skb剩余数据长度是否足够一个NLMSG_HDRLEN                                     |</span><br><span class="line">    |      |      |   |检查nlmsg_len是否足够NLMSG_HDRLEN                                               |</span><br><span class="line">    |      |      +---+检查skb剩余数据长度是否足够nlmsg_len                                            |</span><br><span class="line">    |      |      |   |检查nlmsg_flags是否包含NLM_F_REQUEST                                            |</span><br><span class="line">    |      |      |   |检查nlmsg_type是否小于NLMSG_MIN_TYPE(因为小于这个值的都是控制消息，不应主动发送)|</span><br><span class="line">    |      |      |   +--------------------------------------------------------------------------------+</span><br><span class="line">    |      |      |</span><br><span class="line">    |      |      |   +--------------------------+</span><br><span class="line">    |      |      +---+调用传入的函数指针，实际为|</span><br><span class="line">    |      |      |   |      genl_rcv_msg        |</span><br><span class="line">    |      |      |   +--+-----------------------+</span><br><span class="line">    |      |      |      |</span><br><span class="line">    |      |      |      |   +-----------------------------------------------------------------+</span><br><span class="line">    |      |      |      |   |                    genl_family_find_byid                        |</span><br><span class="line">    |      |      |      +---+                                                                 |</span><br><span class="line">    |      |      |      |   |以nlmsghdr字段nlmsg_type作为id查找之前是否有注册过genl_family结构|</span><br><span class="line">    |      |      |      |   +-----------------------------------------------------------------+</span><br><span class="line">    |      |      |      |</span><br><span class="line">    |      |      |      |   +--------------------------------------------------------------+</span><br><span class="line">    |      |      |      |   |             genl_family_rcv_msg(family, skb, nlh)            |</span><br><span class="line">    |      |      |      +---+                                                              |</span><br><span class="line">    |      |      |      |   |如果family中parallel_ops为假，这个函数执行前后会有全局锁的操作|</span><br><span class="line">    |      |      |      |   |使所有不支持并行操作的family中所有操作全局串行                |</span><br><span class="line">    |      |      |      |   +--+-----------------------------------------------------------+</span><br><span class="line">    |      |      |      |      |</span><br><span class="line">    |      |      |      |      |   +-----------------------------------------------------------------+</span><br><span class="line">    |      |      |      |      |   |如果family字段netnsok为假，检查skb来源net namesapce是不是init_net|</span><br><span class="line">    |      |      |      |      |   |                                                                 |</span><br><span class="line">    |      |      |      |      |   |检查nlh空间是否足够包含GENL_HDRLEN和family的自定义消息头hdrsize  |</span><br><span class="line">    |      |      |      |      |   |                                                                 |</span><br><span class="line">    |      |      |      |      +---+检查family是否有处理指定cmd的genl_ops                            |</span><br><span class="line">    |      |      |      |      |   |                                                                 |</span><br><span class="line">    |      |      |      |      |   |如果ops字段flags包含GENL_ADMIN_PERM，                            |</span><br><span class="line">    |      |      |      |      |   |检查在init_user_ns是否有CAP_NET_ADMIN权限                        |</span><br><span class="line">    |      |      |      |      |   |                                                                 |</span><br><span class="line">    |      |      |      |      |   |如果ops字段flags包含GENL_UNS_ADMIN_PERM                          |</span><br><span class="line">    |      |      |      |      |   |检查在net所属user_namespace是否有CAP_NET_ADMIN权限               |</span><br><span class="line">    |      |      |      |      |   +-----------------------------------------------------------------+</span><br><span class="line">    |      |      |      |      |</span><br><span class="line">    |      |      |      |      |</span><br><span class="line">    |      |      |      |      |   +---------------------------------------------------------------+</span><br><span class="line">    |      |      |      |      |   |如果nlmsg_flags包含NLM_F_DUMP，将进入一块独立的处理逻辑，      |</span><br><span class="line">    |      |      |      |      |   |这里涉及struct genl_ops中的dumpit和done函数。下面小节单独介绍。|</span><br><span class="line">    |      |      |      |      +---+                                                               |</span><br><span class="line">    |      |      |      |      |   |该块处理逻辑完成后直接从函数genl_family_rcv_msg返回，          |</span><br><span class="line">    |      |      |      |      |   |可以看出dumpit和doit是并列且有优先级的，dumpit条件满足则运行， |</span><br><span class="line">    |      |      |      |      |   |dumpit条件不满足才运行doit。                                   |</span><br><span class="line">    |      |      |      |      |   +---------------------------------------------------------------+</span><br><span class="line">    |      |      |      |      |</span><br><span class="line">    |      |      |      |      |</span><br><span class="line">    |      |      |      |      |   +-----------------------------------------------------+</span><br><span class="line">    |      |      |      |      +---+检查ops字段doit是否为NULL，这里马上就要进入主要工作了|</span><br><span class="line">    |      |      |      |      |   +-----------------------------------------------------+</span><br><span class="line">    |      |      |      |      |</span><br><span class="line">    |      |      |      |      |   +-----------------------------------------------------------------+</span><br><span class="line">    |      |      |      |      |   |如果注册时声明了非并行操作，说明family字段attrbuf已经分配过内存了|</span><br><span class="line">    |      |      |      |      +---+使用该字段作为genl_info的attrs缓存。                             |</span><br><span class="line">    |      |      |      |      |   |                                                                 |</span><br><span class="line">    |      |      |      |      |   |如果注册时声明了并行操作，也就没有共用的缓存了，这时要分配内存   |</span><br><span class="line">    |      |      |      |      |   +-----------------------------------------------------------------+</span><br><span class="line">    |      |      |      |      |</span><br><span class="line">    |      |      |      |      |   +-----------------------------------------------------------------+</span><br><span class="line">    |      |      |      |      |   |                     nlmsg_parse -&gt; nla_parse                    |</span><br><span class="line">    |      |      |      |      |   |这个函数的目的是校验nlattr，同时为genl_info中的attrs做预处理     |</span><br><span class="line">    |      |      |      |      |   |                                                                 |</span><br><span class="line">    |      |      |      |      |   |这里会遍历每一个nlattr，                                         |</span><br><span class="line">    |      |      |      |      +---+对于nla_tyoe大于0小于等于genl_family字段maxattr的nlattr，        |</span><br><span class="line">    |      |      |      |      |   |如果ops存在policy，会使用该policy校验nlattr是否符合要求，        |</span><br><span class="line">    |      |      |      |      |   |最后将nlattr的指针填充近上一步所说的缓存指定槽位中，             |</span><br><span class="line">    |      |      |      |      |   |如果在最外层存在相同nla_type的nlattr，后面的将覆盖槽位中的指针   |</span><br><span class="line">    |      |      |      |      |   |这里填充的指针数组，会设置给genl_info作为nlattr的简单访问入口    |</span><br><span class="line">    |      |      |      |      |   |但如果你希望用更复杂的结构，就需要自己解析nlh了，不过我不会这么做|</span><br><span class="line">    |      |      |      |      |   |这里的实现也说明了，不要把nla_type的类型设置为0                  |</span><br><span class="line">    |      |      |      |      |   +-----------------------------------------------------------------+</span><br><span class="line">    |      |      |      |      |</span><br><span class="line">    |      |      |      |      |   +---------------------------------------------------------------+</span><br><span class="line">    |      |      |      |      |   |填充genl_info结构                                              |</span><br><span class="line">    |      |      |      |      |   |                                                               |</span><br><span class="line">    |      |      |      |      |   |snd_seq是nlmsg_seq                                             |</span><br><span class="line">    |      |      |      |      |   |snd_portid是发送方portid                                       |</span><br><span class="line">    |      |      |      |      +---+nlhdr是nlmsghdr结构指针                                        |</span><br><span class="line">    |      |      |      |      |   |genlhdr是genlmsghdr结构指针                                    |</span><br><span class="line">    |      |      |      |      |   |userhdr是generic netlink注册时标明长度的自定义头的地址         |</span><br><span class="line">    |      |      |      |      |   |attrs是上一步填充的nlattr指针数组                              |</span><br><span class="line">    |      |      |      |      |   |_net是skb所属sk的net namespace，取这个值使用函数genl_info_net  |</span><br><span class="line">    |      |      |      |      |   |user_ptr置0，这个东西应该是给用户自己使用的，内核不关心如何使用|</span><br><span class="line">    |      |      |      |      |   +---------------------------------------------------------------+</span><br><span class="line">    |      |      |      |      |</span><br><span class="line">    |      |      |      |      |</span><br><span class="line">    |      |      |      |      |   +------------------------------------------------------------------+</span><br><span class="line">    |      |      |      |      |   |                                                                  |</span><br><span class="line">    |      |      |      |      |   | ops-&gt;doit(skb, &amp;info)                                            |</span><br><span class="line">    |      |      |      |      +---+                                                                  |</span><br><span class="line">    |      |      |      |      |   | 终于运行doit函数指针了                                           |</span><br><span class="line">    |      |      |      |      |   | 如果ops字段pre_doit和post_doit不为NULL，在doit前后还会运行这两个 |</span><br><span class="line">    |      |      |      |      |   |                                                                  |</span><br><span class="line">    |      |      |      |      |   +------------------------------------------------------------------+</span><br><span class="line">    |      |      |      |      |</span><br><span class="line">    |      |      |      |      |</span><br><span class="line">    |      |      |      |      |   +-----------------------------------+</span><br><span class="line">    |      |      |      |      +---+如果之前分配了attrs内存，这里释放掉|</span><br><span class="line">    |      |      |      |      |   +-----------------------------------+</span><br><span class="line">    |      |      |      |      |</span><br><span class="line">    |      |      |&lt;-----+&lt;-----+</span><br><span class="line">    |      |      |              </span><br><span class="line">    |      |      |   +--------------------------------------------------------------+</span><br><span class="line">    |      |      +---+如果nlmsg_flags包含NFM_F_ACK或者上一步对nlmsghdr的处理返回错误|</span><br><span class="line">    |      |      |   |将调用netlink_ack返回一个netlink消息，包含nlmsgerr结构        |</span><br><span class="line">    |      |      |   +--------------------------------------------------------------+</span><br><span class="line">    |      |      |              </span><br><span class="line">    |      |      |   +---------------------------+</span><br><span class="line">    |&lt;-----+&lt;-----+&lt;--+全部nlmsghdr遍历完成后返回0|</span><br><span class="line">    |                 +---------------------------+</span><br><span class="line">    |                            </span><br><span class="line">    v                            </span><br><span class="line">  完成</span><br></pre></td></tr></table></figure>
<h4 id="NLM-F-DUMP-请求处理"><a href="#NLM-F-DUMP-请求处理" class="headerlink" title="NLM_F_DUMP 请求处理"></a>NLM_F_DUMP 请求处理</h4><p>dump的处理涉及一个结构体<code>struct netlink_callback</code></p>
<figure class="highlight c"><figcaption><span>struct netlink_callback</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netlink_callback</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 当次dump请求所在的skb */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>      *<span class="title">skb</span>;</span></span><br><span class="line">    <span class="comment">/* 档次dump请求所在的netlink消息指针 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span>   *<span class="title">nlh</span>;</span></span><br><span class="line">    <span class="comment">/* dumpit函数指针。如果不支持并行这里将会是genl_lock_dumpit，使用锁包裹dumpit执行。 */</span></span><br><span class="line">    <span class="keyword">int</span>         (*dump)(struct sk_buff * skb,</span><br><span class="line">            struct netlink_callback *cb);</span><br><span class="line">    <span class="comment">/* done函数指针。如果不支持并行这里将会是genl_lock_done，使用锁包裹done执行。 */</span></span><br><span class="line">    <span class="keyword">int</span>         (*done)(struct netlink_callback *cb);</span><br><span class="line">    <span class="comment">/* netlink协议自定的数据。generic netlink这里固定填充genl_ops */</span></span><br><span class="line">    <span class="keyword">void</span>            *data;</span><br><span class="line">    <span class="comment">/* the module that dump function belong to */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span>       *<span class="title">module</span>;</span></span><br><span class="line">    u16         family;</span><br><span class="line">    <span class="comment">/* dumpit最小需要的空间，generic netlink中为0，使用默认大小 */</span></span><br><span class="line">    u16         min_dump_alloc;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于检查在一次完整的dump中，是否有意外导致中断而插入了新的dump请求</span></span><br><span class="line"><span class="comment">     * 如果检查出错会在netlink消息中加入标记NLM_F_DUMP_INTR。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 该检查由函数nl_dump_check_consistent完成，</span></span><br><span class="line"><span class="comment">     * 但是generic netlink中由于使用错误，该检查无效。</span></span><br><span class="line"><span class="comment">     * 也由于generic netlink中不允许一个socket并发多个dump请求，因此该检查并不需要。</span></span><br><span class="line"><span class="comment">     * 正确的使用方式参考函数nl_dump_check_consistent的注释</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        prev_seq, seq;</span><br><span class="line">    <span class="comment">/* 用户自由使用，可以在一次完整dump的多次调用时保存状态 */</span></span><br><span class="line">    <span class="keyword">long</span>            args[<span class="number">6</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在<code>dumpit</code>和<code>done</code>函数中作为参数传递的<code>struct netlink_callback</code>类型指针指向的实际是<code>struct netlink_sock</code>中成员<code>cb</code>，同时nlk成员<code>cb_running</code>标记了一次dump正在运行中，如果在一次dump未完成时有另外的dump请求到来将返回<code>-EBUSY</code>，注意这里仅仅阻止同一个socket的并发dump，不同socket间并不影响。</p>
<p>dump部分的调用栈为</p>
<p><code>genl_family_rcv_msg</code> -&gt; <code>__netlink_dump_start</code> -&gt; <code>netlink_dump</code></p>
<ul>
<li><p><code>__netlink_dump_start</code><br>负责检查nlk的<code>cb_running</code>判断是否有dump未完成，填充cb各成员，并调用<code>netlink_dump</code></p>
</li>
<li><p><code>netlink_dump</code><br>分配了一个skb准备交给<code>dumpit</code>函数填充dump内容，调用<code>cb-&gt;dump</code>也就是<code>dumpit</code>。这里对<code>dumpit</code>返回值的判断值得注意：</p>
<ul>
<li>返回值大于0<br>含义为当次dump未结束，需要后续继续调用<code>dumpit</code>，因此直接发送skb，并不会修改<code>cb_running</code>状态。</li>
<li>返回值小于等于0<br>含义为当次dump已经完成，0为正常完成，负数为错误码的负值。由于当次dump已经完成，因此会在skb中添加一个类型为NLMSG_DONE的netlink消息用于向用户程序标记当次dump已经完成，并修改<code>cb_running</code>为false，释放cb保存的相关资源。</li>
</ul>
</li>
</ul>
<p>通过上面的分析，可以看到一次完整的dump可能不会在该次请求的上下文中完成，因此会有其他位置继续完成该次dump过程。这个位置是函数<code>netlink_recvmsg</code>，也就是用户程序后续接收消息时将会继续dump过程，该调用栈为：</p>
<p><code>netlink_recvmsg</code> -&gt; <code>netlink_dump</code></p>
<p>如果一个dump未完成，而对应的socket已经关闭，则不会继续调用<code>dumpit</code>，而是在close时调用一次<code>done</code>函数通知内核该次dump到此为止。该调用栈为：</p>
<p><code>netlink_release</code>中调用<code>call_rcu</code>传入<code>deferred_put_nlk_sk</code>。</p>
<p><code>deferred_put_nlk_sk</code> -&gt; <code>sock_put</code> -&gt; <code>sk_free</code> -&gt; <code>__sk_free</code> -&gt; <code>sk_destruct</code> -&gt; <code>__sk_destruct</code> -&gt; <code>netlink_sock_destruct</code><br>其中<code>netlink_sock_destruct</code>是由函数指针<code>sk-&gt;sk_destruct</code>调用的。该函数指针在<code>__netlink_create</code>中被设置，参考<a href="/2018/08/22/netlink/#用户态-netlink-socket-创建">netlink相关部分</a>。</p>
<p>通过dump部分内核代码分析，及参考controller中<code>ctrl_dumpfamily</code>的实现，可以推荐<code>dumpit</code>函数实现方式。</p>
<ul>
<li>使用<code>cb-&gt;args</code>数组做状态保存。<ul>
<li>如果对dump存在<code>cb-&gt;args</code>之外的资源分配和状态保存，需要在<code>done</code>函数中做清理。</li>
<li>如果对dump没有<code>cb-&gt;args</code>之外的资源分配和状态保存，则可以不使用<code>done</code>函数。</li>
</ul>
</li>
<li>如果有数据需要dump，填充到skb中。<ul>
<li>如果skb空间不足，则填充一部分数据，并返回skb中数据长度。</li>
<li>如果skb空间充足，则填充数据，同样返回skb中数据长度。</li>
</ul>
</li>
<li>如果不再需要填充数据，返回0。</li>
</ul>
<p>这种实现方式的好处是，最后一次调用<code>dumpit</code>时不会填充skb，因此会保留足够的空间给<code>NLMSG_DONE</code>类型的netlink消息使用，不会因为空间不足而导致失败，内核对<code>NLMSG_DONE</code>类型netlink消息空间不足的处理并不友好。</p>
<p>由于此小节是后续补充的内容，因此代码片段单独列出供参考。</p>
<figure class="highlight c"><figcaption><span>dumpit内核部分测试代码片段</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add_dumpit</span><span class="params">(struct sk_buff *skb, struct netlink_callback *cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *hdr;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    pr_info(<span class="string">"%s\n"</span>, __FUNCTION__);</span><br><span class="line"></span><br><span class="line">    i = cb-&gt;args[<span class="number">0</span>] ++;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        hdr = genlmsg_put(skb, NETLINK_CB(cb-&gt;skb).portid, cb-&gt;nlh-&gt;nlmsg_seq, &amp;family,</span><br><span class="line">                NLM_F_MULTI, MY_CMD_ADD);</span><br><span class="line">        <span class="keyword">if</span> (hdr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> err_out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第i次调用保留i字节nla数据空间用于验证</span></span><br><span class="line">        <span class="keyword">if</span> (nla_reserve(skb, MY_ATTR_N1, i) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> err_out;</span><br><span class="line">        &#125;</span><br><span class="line">        genlmsg_end(skb, hdr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> skb-&gt;len;</span><br><span class="line"></span><br><span class="line">err_out:</span><br><span class="line">    genlmsg_cancel(skb, hdr);</span><br><span class="line">    <span class="keyword">return</span> -ENOBUFS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>dumpit用户态测试代码片段</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test_dump</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> family_id, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">genlmsghdr</span> *<span class="title">glh</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1500</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> <span class="title">dest_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// + genelmsghdr + pad 长度</span></span><br><span class="line">    len += GENL_HDRLEN;</span><br><span class="line">    <span class="comment">// + nlmsghdr + pad 长度</span></span><br><span class="line">    len = NLMSG_SPACE(len);</span><br><span class="line"></span><br><span class="line">    nlh = (struct nlmsghdr *)buf;</span><br><span class="line">    glh = NLMSG_DATA(buf);</span><br><span class="line"></span><br><span class="line">    nlh-&gt;nlmsg_len = len;</span><br><span class="line">    nlh-&gt;nlmsg_type = family_id;</span><br><span class="line">    nlh-&gt;nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP;</span><br><span class="line">    <span class="comment">// 用于判断请求响应对应情况，先随便填一个。</span></span><br><span class="line">    nlh-&gt;nlmsg_seq = <span class="number">302</span>;</span><br><span class="line">    nlh-&gt;nlmsg_pid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    glh-&gt;cmd = MY_CMD_ADD;</span><br><span class="line">    glh-&gt;version = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;dest_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(dest_addr));</span><br><span class="line">    dest_addr.nl_family = AF_NETLINK;</span><br><span class="line">    dest_addr.nl_pid = <span class="number">0</span>;</span><br><span class="line">    dest_addr.nl_groups = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    err = sendto(fd, buf, len, <span class="number">0</span>, (struct sockaddr *)&amp;dest_addr, (<span class="keyword">socklen_t</span>)<span class="keyword">sizeof</span>(dest_addr));</span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"sendto failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        len = recv(fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"recv len %d\n"</span>, err);</span><br><span class="line">        parse_nl_msg((struct nlmsghdr *)buf, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="controller服务"><a href="#controller服务" class="headerlink" title="controller服务"></a>controller服务</h3><p>controller的工作是提供名字服务，提交genl_family的name，返回相关信息，最主要的就是family的id。</p>
<p>从下面的数据结构可以看到controller服务仅接受一个cmd，也就是CTRL_CMD_GETFAMILY，与用户自定义协议不同之处在于这里id是固定的，因为controller服务是首个服务，也只有固定id，才能让后面的查询请求可以准确发送到controller，才能完成名字查询服务。具体流程这里不描述了，返回内容格式可以参考<a href="#例子代码">例子代码中用户态解析</a>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">genl_ops</span> <span class="title">genl_ctrl_ops</span>[] = &#123;</span></span><br><span class="line">    &#123;</span><br><span class="line">        .cmd        = CTRL_CMD_GETFAMILY,</span><br><span class="line">        .doit       = ctrl_getfamily,</span><br><span class="line">        .dumpit     = ctrl_dumpfamily,</span><br><span class="line">        .policy     = ctrl_policy,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">genl_multicast_group</span> <span class="title">genl_ctrl_groups</span>[] = &#123;</span></span><br><span class="line">    &#123; .name = <span class="string">"notify"</span>, &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">genl_family</span> <span class="title">genl_ctrl</span> = &#123;</span></span><br><span class="line">    .<span class="keyword">module</span> = THIS_MODULE,</span><br><span class="line">    .ops = genl_ctrl_ops,</span><br><span class="line">    .n_ops = ARRAY_SIZE(genl_ctrl_ops),</span><br><span class="line">    .mcgrps = genl_ctrl_groups,</span><br><span class="line">    .n_mcgrps = ARRAY_SIZE(genl_ctrl_groups),</span><br><span class="line">    .id = GENL_ID_CTRL,</span><br><span class="line">    .name = <span class="string">"nlctrl"</span>,</span><br><span class="line">    .version = <span class="number">0x2</span>,</span><br><span class="line">    .maxattr = CTRL_ATTR_MAX,</span><br><span class="line">    .netnsok = <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/linux/">linux</a></div><div class="post-nav"><a class="pre" href="/2018/10/17/linux-kernel-timer/">Linux timer 内核软件定时器</a><a class="next" href="/2018/08/25/vim-dot-file-indent/">graphviz(dot) file vim 缩进设置</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://www.hyuuhit.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/libvirt/">libvirt</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/suricata/">suricata</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/vmware/" style="font-size: 15px;">vmware</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/05/05/static-key-jump-label/">static key & jump label</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/30/initcall/">initcall 机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/07/cn-proc-example/">cn_proc 进程事件连接器</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/04/executable-shared-library/">可执行的动态链接库</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/05/26/dirpro-bug-analysis/">一次无源码Linux内核模块bug分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/05/13/elrepo-not-for-production-use/">为什么生产环境服务器不应该使用ELRepo内核</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/04/29/memory-consistency-model-memory-barrier-and-sychronization/">内存一致性模型、内存屏障与同步</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/04/11/rcu-usage/">抢占式RCU与RCU使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/09/16/tc-tbf-qdisc/">tc tbf qdisc 令牌桶过滤器限速队列</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/08/function-call-stack/">gdb查看寄存器及内存数据与函数调用栈分析</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">属乌鸦的.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>