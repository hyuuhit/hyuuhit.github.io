<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="hu yu's blog | Android | 服务端"><title>Linux kernel thread 内核线程 | 属乌鸦的</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-129648993-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '85d80db9310fa34ab2f7d34beeff589b';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Linux kernel thread 内核线程</h1><a id="logo" href="/.">属乌鸦的</a><p class="description">无知 &amp; 聒噪</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Linux kernel thread 内核线程</h1><div class="post-meta">Aug 3, 2018</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#例子"><span class="toc-number">1.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内核线程-api"><span class="toc-number">2.</span> <span class="toc-text">内核线程 api</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#生命周期流程"><span class="toc-number">3.</span> <span class="toc-text">生命周期流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内核线程创建"><span class="toc-number">4.</span> <span class="toc-text">内核线程创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#上半部"><span class="toc-number">4.1.</span> <span class="toc-text">上半部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#下半部"><span class="toc-number">4.2.</span> <span class="toc-text">下半部</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内核线程停止"><span class="toc-number">5.</span> <span class="toc-text">内核线程停止</span></a></li></ol></div></div><div class="post-content"><p>Linux中无论是用户态进程、线程，还是内核线程，在内核中都使用同样的结构<code>task_struct</code>，可以看出内核都是以<strong>任务</strong>这个概念对待这些不同名字的事物。至于为什么会有kernel thread或者说内核线程这个词，个人认为应该是因为所有内核线程共享内核空间资源，因此有线程之名。</p>
<a id="more"></a>
<p>本文内容参考内核版本 3.10.0-862.el7.x86_64</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>用户态进程运行在用户空间，可以通过系统调用陷入内核调用内核资源。Linux中用户态线程与用户态进程基本无异，称之为线程是因为它们有共同的线程组id，并共享一部分资源。内核线程运行在内核空间，可以直接访问内核资源，创建内核线程需要调用内核api，因此我们创建一个内核模块来演示内核线程，模块加载时启动一个内核线程，这个内核线程每隔五秒打印一条消息，打印结束后主动让出cpu，模块卸载时停止该内核线程。</p>
<p>因为内核线程上下文不属于中断上下文，因此可以使用调度类睡眠操作主动让出cpu，这点在输出中可以看到在没有设定cpu亲和的情况下存在唤醒在不同cpu的情况。</p>
<figure class="highlight c"><figcaption><span>kthread_test.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/smp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"Hu Yu &lt;hyuuhit@gmail.com&gt;"</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"kthread test"</span>);</span><br><span class="line">MODULE_VERSION(<span class="string">"0.1"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">my_task</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_kthread</span><span class="params">(<span class="keyword">void</span> *data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = (<span class="keyword">char</span> *)data;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">"my kthread data: %s\n"</span>, str);</span><br><span class="line">    pr_info(<span class="string">"my kthread smp_processor_id %d\n"</span>, smp_processor_id());</span><br><span class="line">    <span class="keyword">while</span>(!kthread_should_stop()) &#123;</span><br><span class="line">        msleep(<span class="number">5000</span>);</span><br><span class="line">        pr_info(<span class="string">"my kthread: living. smp_processor_id %d\n"</span>, smp_processor_id());</span><br><span class="line">        pr_info(<span class="string">"=========================================\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pr_info(<span class="string">"my kthread: stop\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">my_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pr_info(<span class="string">"my init.\n"</span>);</span><br><span class="line">    pr_info(<span class="string">"smp_processor_id %d\n"</span>, smp_processor_id());</span><br><span class="line"></span><br><span class="line">    my_task = kthread_run(my_kthread, <span class="string">"hello my kthread"</span>, <span class="string">"mykthread-%s"</span>, <span class="string">"test"</span>);</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">"my init finish.\n"</span>);</span><br><span class="line">    pr_info(<span class="string">"=========================================\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">my_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pr_info(<span class="string">"my exit.\n"</span>);</span><br><span class="line">    pr_info(<span class="string">"smp_processor_id %d\n"</span>, smp_processor_id());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (my_task) &#123;</span><br><span class="line">        pr_info(<span class="string">"stop kthread\n"</span>);</span><br><span class="line">        kthread_stop(my_task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">"my exit finish.\n"</span>);</span><br><span class="line">    pr_info(<span class="string">"=========================================\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_init);</span><br><span class="line">module_exit(my_exit);</span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><figcaption><span>Makefile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">obj-m := kthread_test.o</span><br><span class="line"></span><br><span class="line">PWD:=<span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line">KVER:=<span class="variable">$(<span class="built_in">shell</span> uname -r)</span></span><br><span class="line">KDIR:=/lib/modules/<span class="variable">$(KVER)</span>/build</span><br><span class="line"></span><br><span class="line">EXTRA_CFLAGS += -Wall -g</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>输出</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[57272.252152] my init.</span><br><span class="line">[57272.252156] smp_processor_id 1</span><br><span class="line">[57272.252222] my init finish.</span><br><span class="line">[57272.252224] =========================================</span><br><span class="line">[57272.252229] my kthread data: hello my kthread</span><br><span class="line">[57272.252232] my kthread smp_processor_id 7</span><br><span class="line">[57277.252530] my kthread: living. smp_processor_id 7</span><br><span class="line">[57277.252534] =========================================</span><br><span class="line">[57282.253374] my kthread: living. smp_processor_id 7</span><br><span class="line">[57282.253379] =========================================</span><br><span class="line">[57287.254189] my kthread: living. smp_processor_id 7</span><br><span class="line">[57287.254193] =========================================</span><br><span class="line">[57292.255016] my kthread: living. smp_processor_id 7</span><br><span class="line">[57292.255020] =========================================</span><br><span class="line">[57292.410807] my exit.</span><br><span class="line">[57292.410810] smp_processor_id 1</span><br><span class="line">[57292.410811] stop kthread</span><br><span class="line">[57297.256008] my kthread: living. smp_processor_id 4</span><br><span class="line">[57297.256013] =========================================</span><br><span class="line">[57297.256014] my kthread: stop</span><br><span class="line">[57297.256050] my exit finish.</span><br><span class="line">[57297.256053] =========================================</span><br></pre></td></tr></table></figure>
<h2 id="内核线程-api"><a href="#内核线程-api" class="headerlink" title="内核线程 api"></a>内核线程 api</h2><p>上面例子代码中创建内核线程调用了<code>kthread_run</code>，停止内核线程调用了函数<code>kthread_stop</code>，内线线程自身调用<code>kthread_should_stop</code>判断是否应该退出，相关的还有其他api。这一组api在创建内核线程时依赖kthreadd内核线程，下面具体介绍这一组api。</p>
<p>以下api位于include/linux/kthread.h。</p>
<ul>
<li><code>kthread_create_on_node</code><br>创建一个内核线程执行指定的函数，从指定numa node上分配内存，如果不指定则传入-1。内核线程创建完毕后进入<code>TASK_UNINTERRUPTIBLE</code>状态并让出cpu，等待人为唤醒。</li>
<li><code>kthread_create</code><br><code>kthread_create_on_node</code>的一个宏包装，numa node指定为-1。</li>
<li><p><code>kthread_run</code><br>调用<code>kthread_create</code>创建内核线程后调用<code>wake_up_process</code>唤醒该线程。</p>
</li>
<li><p><code>kthread_stop</code><br>通知一个内核线程可以停止运行，并等待其停止。这个函数不是强制性的，需要线程内自身代码检查<code>kthread_should_stop</code>返回是否为真并主动返回或退出。如果线程函数自身调用了<code>do_exit</code>，那么需要<code>kthread_stop</code>的调用者确保线程的task_struct结构内存依然被持有，否则会访问无效内存。</p>
</li>
<li><p><code>kthread_should_stop</code><br>线程内自身调用该函数检查是否外部调用了<code>kthread_stop</code>。</p>
</li>
<li><p><code>kthread_freezable_should_stop</code><br>应用于可以冻结的线程，由内核线程自身调用，当系统处于挂起状态时，该函数可以冻结自身直到挂起状态解除。参数的引用用于表示是否从冻结状态返回，返回值与<code>kthread_should_stop</code>一致。</p>
</li>
<li><p><code>kthread_park</code><br>通知内核线程进入park（停靠，可以理解为暂定）状态，并等待其park完成。这个函数同样不是强制性的，需要线程自身代码检查<code>kthread_should_park</code>返回真后调用<code>kthread_parkme</code>将自身置为park状态并让出cpu，直到park状态解除。</p>
</li>
<li><code>kthread_should_park</code><br>线程自身调用该函数检查是否应当进入park状态。</li>
<li><code>kthread_parkme</code><br>线程自身调用该函数令自身进入park状态。</li>
<li><p><code>kthread_unpark</code><br>与<code>kthread_park</code>对应，解除线程park状态。</p>
</li>
<li><p><code>kthread_data</code><br>返回内核线程创建时设定的运行函数的参数。调用者需要确保传入的task_struct的确是一个kthread。</p>
</li>
<li><p><code>probe_kthread_data</code><br>返回内核线程创建时设定的运行函数的参数。如果传入的task_struct不是一个kthread或参数无法访问那么返回NULL。</p>
</li>
<li><p><code>kthread_bind</code><br>将一个内核线程绑定到指定的cpu上。该线程必须处于<code>TASK_UNINTERRUPTIBLE</code>状态，<code>kthread_create</code>刚刚创建的线程符合该要求。获取cpu相关的api在include/linux/cpumask.h文件中，numa node相关api在include/linux/nodemask.h中，用户态查看cpu和numa node相关信息可以使用命令<code>lscpu</code>和<code>cat /proc/cpuinfo</code>。</p>
</li>
</ul>
<h2 id="生命周期流程"><a href="#生命周期流程" class="headerlink" title="生命周期流程"></a>生命周期流程</h2><p>在看具体代码前看一下内核线程生命周期中的大体流程。</p>
<p><img src="http://blog-image.hyuuhit.com/2018/08/linux-kernel-thread/linux_kernel_thread.jpg" alt="内核线程生命周期"></p>
<h2 id="内核线程创建"><a href="#内核线程创建" class="headerlink" title="内核线程创建"></a>内核线程创建</h2><p>内核线程的创建与中断处理的处理思路很相似，尽量将占用cpu时间长的处理逻辑推到下半部在另外的时间执行，尽快完成上半部操作，以让出cpu执行优先级更高的任务。</p>
<h3 id="上半部"><a href="#上半部" class="headerlink" title="上半部"></a>上半部</h3><p>通过上文的api可以看到创建内核线程最后都会落到函数<code>kthread_create_on_node</code>，这个函数的逻辑很简单：</p>
<ul>
<li>在栈上分配<code>kthread_create_info</code>类型结构体，填充必要成员，将其放入队列<code>kthread_create_list</code>中</li>
<li>唤醒<code>kthreadd</code>线程（<code>kthreadd_task</code>就是<code>kthreadd</code>守护线程的<code>task_struct</code>）</li>
<li>等待<code>kthread_create_info</code>中成员done标记被设置（这里将由<code>kthreadd</code>守护线程设置）</li>
<li>上面的标记设置完成，标志着result成员可以被访问了，这是新内核线程的<code>task_struct</code>结构。设置线程名、调度策略和运行cpu。</li>
<li>返回其<code>task_struct</code>结构体指针。此时新内核线程处于<code>TASK_UNINTERRUPTIBLE</code>状态等待被<code>wake_up_process</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kthread_create_on_node - create a kthread.</span></span><br><span class="line"><span class="comment"> * @threadfn: the function to run until signal_pending(current).</span></span><br><span class="line"><span class="comment"> * @data: data ptr for @threadfn.</span></span><br><span class="line"><span class="comment"> * @node: memory node number.</span></span><br><span class="line"><span class="comment"> * @namefmt: printf-style name for the thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Description: This helper function creates and names a kernel</span></span><br><span class="line"><span class="comment"> * thread.  The thread will be stopped: use wake_up_process() to start</span></span><br><span class="line"><span class="comment"> * it.  See also kthread_run().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If thread is going to be bound on a particular cpu, give its node</span></span><br><span class="line"><span class="comment"> * in @node, to get NUMA affinity for kthread stack, or else give -1.</span></span><br><span class="line"><span class="comment"> * When woken, the thread will run @threadfn() with @data as its</span></span><br><span class="line"><span class="comment"> * argument. @threadfn() can either call do_exit() directly if it is a</span></span><br><span class="line"><span class="comment"> * standalone thread for which no one will call kthread_stop(), or</span></span><br><span class="line"><span class="comment"> * return when 'kthread_should_stop()' is true (which means</span></span><br><span class="line"><span class="comment"> * kthread_stop() has been called).  The return value should be zero</span></span><br><span class="line"><span class="comment"> * or a negative error number; it will be passed to kthread_stop().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns a task_struct or ERR_PTR(-ENOMEM).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">struct task_struct *kthread_create_on_node(int (*threadfn)(void *data),</span><br><span class="line">        <span class="keyword">void</span> *data, <span class="keyword">int</span> node,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> namefmt[],</span><br><span class="line">        ...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kthread_create_info</span> <span class="title">create</span>;</span></span><br><span class="line"></span><br><span class="line">    create.threadfn = threadfn;</span><br><span class="line">    create.data = data;</span><br><span class="line">    create.node = node;</span><br><span class="line">    init_completion(&amp;create.done);</span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;kthread_create_lock);</span><br><span class="line">    list_add_tail(&amp;create.<span class="built_in">list</span>, &amp;kthread_create_list);</span><br><span class="line">    spin_unlock(&amp;kthread_create_lock);</span><br><span class="line"></span><br><span class="line">    wake_up_process(kthreadd_task);</span><br><span class="line">    wait_for_completion(&amp;create.done);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!IS_ERR(create.result)) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span> = &#123;</span> .sched_priority = <span class="number">0</span> &#125;;</span><br><span class="line">        va_list args;</span><br><span class="line"></span><br><span class="line">        va_start(args, namefmt);</span><br><span class="line">        vsnprintf(create.result-&gt;comm, <span class="keyword">sizeof</span>(create.result-&gt;comm),</span><br><span class="line">                namefmt, args);</span><br><span class="line">        va_end(args);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * root may have changed our (kthreadd's) priority or CPU mask.</span></span><br><span class="line"><span class="comment">         * The kernel thread should not inherit these properties.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        sched_setscheduler_nocheck(create.result, SCHED_NORMAL, &amp;param);</span><br><span class="line">        set_cpus_allowed_ptr(create.result, cpu_all_mask);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> create.result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一个结构体<code>kthread_create_info</code>，看一下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kthread_create_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* Information passed to kthread() from kthreadd. */</span></span><br><span class="line">    <span class="comment">/* 内核线程需要执行的函数 */</span></span><br><span class="line">    <span class="keyword">int</span> (*threadfn)(<span class="keyword">void</span> *data);</span><br><span class="line">    <span class="comment">/* 执行函数的唯一一个参数 */</span></span><br><span class="line">    <span class="keyword">void</span> *data;</span><br><span class="line">    <span class="comment">/* numa node */</span></span><br><span class="line">    <span class="keyword">int</span> node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Result passed back to kthread_create() from kthreadd. */</span></span><br><span class="line">    <span class="comment">/* kthread_create_on_node函数的返回值 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">result</span>;</span></span><br><span class="line">    <span class="comment">/* kthreadd创建内核线程完成的标识 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">done</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 用于链接到kthread_create_list队列 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="下半部"><a href="#下半部" class="headerlink" title="下半部"></a>下半部</h3><p>内核线程创建的下半部分工作在kthreadd守护线程中完成，这里介绍其创建位置及工作逻辑。</p>
<p>kthreadd是一个内核守护线程，pid为2，用于处理创建内核线程的请求，是其他内核线程的父线程。一个例外是1号线程，后面可以看到为什么。（也可以不通过kthreadd创建内核线程，<code>kernel_thread</code>函数就用于创建内核线程，kthreadd也是调用该函数，但是并不推荐直接使用，而且此文参考的内核版本没有导出该符号，内核模块无法直接调用）</p>
<p>kthreadd的启动代码调用路径是 start_kernel -&gt; rest_init。再之前的部分涉及系统启动，这里不关注。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> noinline <span class="keyword">void</span> __<span class="function">init_refok <span class="title">rest_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line"></span><br><span class="line">    rcu_scheduler_starting();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We need to spawn init first so that it obtains pid 1, however</span></span><br><span class="line"><span class="comment">     * the init task will end up wanting to create kthreads, which, if</span></span><br><span class="line"><span class="comment">     * we schedule it before we create kthreadd, will OOPS.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 这里创建出了1号线程，优先于kthreadd创建，而且其父线程为0号线程</span></span><br><span class="line">    kernel_thread(kernel_init, <span class="literal">NULL</span>, CLONE_FS | CLONE_SIGHAND);</span><br><span class="line">    numa_default_policy();</span><br><span class="line">    <span class="comment">// 这里创建除了2号线程，kthreadd</span></span><br><span class="line">    pid = kernel_thread(kthreadd, <span class="literal">NULL</span>, CLONE_FS | CLONE_FILES);</span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    kthreadd_task = find_task_by_pid_ns(pid, &amp;init_pid_ns);</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">    <span class="comment">// 全局标记kthreadd是否启动完成，1号线程需要等待kthreadd启动完成才能进行后续工作。</span></span><br><span class="line">    complete(&amp;kthreadd_done);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The boot idle thread must execute schedule()</span></span><br><span class="line"><span class="comment">     * at least once to get things moving:</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    init_idle_bootup_task(current);</span><br><span class="line">    schedule_preempt_disabled();</span><br><span class="line">    <span class="comment">/* Call into cpu_idle with preempt disabled */</span></span><br><span class="line">    cpu_startup_entry(CPUHP_ONLINE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先不关注kernel_thread的具体实现，只需要知道创建了新的线程并执行传入的函数指针就可以了。2号线程执行的函数为<code>kthreadd</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthreadd</span><span class="params">(<span class="keyword">void</span> *unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> = <span class="title">current</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Setup a clean context for our children to inherit. */</span></span><br><span class="line">    <span class="comment">/* 设置进程名 */</span></span><br><span class="line">    set_task_comm(tsk, <span class="string">"kthreadd"</span>);</span><br><span class="line">    <span class="comment">/* 忽略所有信号 */</span></span><br><span class="line">    ignore_signals(tsk);</span><br><span class="line">    <span class="comment">/* 设置该进程cpu亲和度 */</span></span><br><span class="line">    set_cpus_allowed_ptr(tsk, cpu_all_mask);</span><br><span class="line">    <span class="comment">/* 设置该进程内存分配 */</span></span><br><span class="line">    set_mems_allowed(node_states[N_MEMORY]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置该进程不允许冻结 */</span></span><br><span class="line">    current-&gt;flags |= PF_NOFREEZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">        <span class="comment">/* 如果链表kthread_create_list为空则主动让出cpu */</span></span><br><span class="line">        <span class="keyword">if</span> (list_empty(&amp;kthread_create_list))</span><br><span class="line">            schedule();</span><br><span class="line">        <span class="comment">/* 重新唤醒运行了 */</span></span><br><span class="line">        __set_current_state(TASK_RUNNING);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 为了防止冲突，链表操作需要上锁 */</span></span><br><span class="line">        spin_lock(&amp;kthread_create_lock);</span><br><span class="line">        <span class="keyword">while</span> (!list_empty(&amp;kthread_create_list)) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">kthread_create_info</span> *<span class="title">create</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 如果链表不空，每次取出一个kthread_create_info结构的实例 */</span></span><br><span class="line">            create = list_entry(kthread_create_list.next,</span><br><span class="line">                    struct kthread_create_info, <span class="built_in">list</span>);</span><br><span class="line">            <span class="comment">/* 从链表摘除 */</span></span><br><span class="line">            list_del_init(&amp;create-&gt;<span class="built_in">list</span>);</span><br><span class="line">            spin_unlock(&amp;kthread_create_lock);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 创建内核线程 */</span></span><br><span class="line">            create_kthread(create);</span><br><span class="line"></span><br><span class="line">            spin_lock(&amp;kthread_create_lock);</span><br><span class="line">        &#125;</span><br><span class="line">        spin_unlock(&amp;kthread_create_lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>kthreadd</code>中调用<code>create_kthread</code>创建内核线程，参数为<code>kthread_create_info</code>结构体（位于<code>kthread_create_on_node</code>栈上内存）。继续看<code>create_kthread</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create_kthread</span><span class="params">(struct kthread_create_info *create)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    current-&gt;pref_node_fork = create-&gt;node;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* We want our own signal handler (we take no signals by default). */</span></span><br><span class="line">    pid = kernel_thread(kthread, create, CLONE_FS | CLONE_FILES | SIGCHLD);</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        create-&gt;result = ERR_PTR(pid);</span><br><span class="line">        complete(&amp;create-&gt;done);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>create_kthread</code>的代码很简单，调用<code>kernel_thread</code>创建一个内核线程并执行函数<code>kthread</code>。额外说一句<code>kthread_create_info</code>中类型为<code>task_struct</code>指针的成员result是在<code>kernel_thread</code>中创建并设置的。继续看<code>kthread</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kthread</span><span class="params">(<span class="keyword">void</span> *_create)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Copy data: it's on kthread's stack */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 将参数kthread_create_info中的指针保存到当前函数栈上，</span></span><br><span class="line"><span class="comment">     * 因为参数内容所在的内存位于kthread_create_on_node函数的栈上，</span></span><br><span class="line"><span class="comment">     * 因为kthread_create_on_node还在阻塞等待内核线程创建完成，因此函数栈内存还是有效的，</span></span><br><span class="line"><span class="comment">     * 一旦complete(&amp;create-&gt;done);这句运行完成。</span></span><br><span class="line"><span class="comment">     * kthread_create_on_node随时可能运行完成返回，这里的参数内容所在的栈内存将无效，</span></span><br><span class="line"><span class="comment">     * 将无法找到其中的指针数据。</span></span><br><span class="line"><span class="comment">     * result指针不需要保存是因为其作为返回值由kthread_create_on_node返回了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kthread_create_info</span> *<span class="title">create</span> = _<span class="title">create</span>;</span></span><br><span class="line">    <span class="keyword">int</span> (*threadfn)(<span class="keyword">void</span> *data) = create-&gt;threadfn;</span><br><span class="line">    <span class="keyword">void</span> *data = create-&gt;data;</span><br><span class="line">    <span class="comment">/* 这里kthread类型的结构体，对内核线程的很多操作会用到 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kthread</span> <span class="title">self</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    self.flags = <span class="number">0</span>;</span><br><span class="line">    self.data = data;</span><br><span class="line">    init_completion(&amp;self.exited);</span><br><span class="line">    init_completion(&amp;self.parked);</span><br><span class="line">    <span class="comment">/* 这里的赋值使通过task_struct定位上面的kthread结构体地址成为可能 */</span></span><br><span class="line">    current-&gt;vfork_done = &amp;self.exited;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* OK, tell user we're spawned, wait for stop or wakeup */</span></span><br><span class="line">    <span class="comment">/* 设置当前线程状态 */</span></span><br><span class="line">    __set_current_state(TASK_UNINTERRUPTIBLE);</span><br><span class="line">    <span class="comment">/* 用于提供给kthread_create_on_node的返回值 */</span></span><br><span class="line">    create-&gt;result = current;</span><br><span class="line">    <span class="comment">/* 设置标识，通知kthread_create_on_node内核创建完成。个人理解这个操作应该包含了内存屏障，没有进一步验证*/</span></span><br><span class="line">    complete(&amp;create-&gt;done);</span><br><span class="line">    <span class="comment">/* 让出cpu，等待wake_up_process唤醒当前内核线程 */</span></span><br><span class="line">    schedule();</span><br><span class="line"></span><br><span class="line">    ret = -EINTR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 唤醒后首先检查是否应该停止 */</span></span><br><span class="line">    <span class="keyword">if</span> (!test_bit(KTHREAD_SHOULD_STOP, &amp;self.flags)) &#123;</span><br><span class="line">        <span class="comment">/* 其次检查是否应该进入park状态 */</span></span><br><span class="line">        __kthread_parkme(&amp;self);</span><br><span class="line">        <span class="comment">/* 运行创建内核线程时传入的指定函数，并传入指定的参数 */</span></span><br><span class="line">        ret = threadfn(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* we can't just return, we must preserve "self" on stack */</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 创建内核线程时传入的指定函数可以直接return，</span></span><br><span class="line"><span class="comment">     * 但kthread函数不能直接return，还需要负责清理线程相关的所有资源</span></span><br><span class="line"><span class="comment">     * 最后通过调度器让出cpu。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    do_exit(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kthread</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> cpu;</span><br><span class="line">    <span class="keyword">void</span> *data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">parked</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">exited</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>到这里kthreadd的实现逻辑已经全部完成了。</p>
<h2 id="内核线程停止"><a href="#内核线程停止" class="headerlink" title="内核线程停止"></a>内核线程停止</h2><p>这里我们看<code>kthread_stop</code>函数逻辑：</p>
<ul>
<li>首先增加<code>task_struct</code>结构体的引用计数，避免在内核线程停止后直接释放其内存，因为我们还需要其返回值。</li>
<li>取到<code>kthread</code>函数上栈上的<code>kthread</code>结构体。</li>
<li>设置标记<code>KTHREAD_SHOULD_STOP</code>。<code>kthread_should_stop</code>函数检查的就是该标记。</li>
<li>取消标记<code>KTHREAD_SHOULD_PARK</code>，因为线程之前可能处于park状态。</li>
<li>唤醒内核线程。</li>
<li>等待内核线程退出标识。这个标识的设置位置实际上是<code>kthread</code> -&gt; <code>do_exit</code>中对<code>task_struct</code>成员<code>vfork_done</code>的设置，该指针指向了这里的exited标识变量。</li>
<li>取得内核线程的退出值。</li>
<li>最后释放<code>task_struct</code>结构体引用计数，根据情况释放其占用资源。</li>
<li>返回内核线程的退出值。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kthread_stop - stop a thread created by kthread_create().</span></span><br><span class="line"><span class="comment"> * @k: thread created by kthread_create().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Sets kthread_should_stop() for @k to return true, wakes it, and</span></span><br><span class="line"><span class="comment"> * waits for it to exit. This can also be called after kthread_create()</span></span><br><span class="line"><span class="comment"> * instead of calling wake_up_process(): the thread will exit without</span></span><br><span class="line"><span class="comment"> * calling threadfn().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If threadfn() may call do_exit() itself, the caller must ensure</span></span><br><span class="line"><span class="comment"> * task_struct can't go away.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns the result of threadfn(), or %-EINTR if wake_up_process()</span></span><br><span class="line"><span class="comment"> * was never called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthread_stop</span><span class="params">(struct task_struct *k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kthread</span> *<span class="title">kthread</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    trace_sched_kthread_stop(k);</span><br><span class="line"></span><br><span class="line">    get_task_struct(k);</span><br><span class="line">    kthread = to_live_kthread(k);</span><br><span class="line">    <span class="keyword">if</span> (kthread) &#123;</span><br><span class="line">        set_bit(KTHREAD_SHOULD_STOP, &amp;kthread-&gt;flags);</span><br><span class="line">        __kthread_unpark(k, kthread);</span><br><span class="line">        wake_up_process(k);</span><br><span class="line">        wait_for_completion(&amp;kthread-&gt;exited);</span><br><span class="line">    &#125;</span><br><span class="line">    ret = k-&gt;exit_code;</span><br><span class="line">    put_task_struct(k);</span><br><span class="line"></span><br><span class="line">    trace_sched_kthread_stop_ret(ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在介绍内核线程创建的下半部<code>kthreadd</code>时说过<code>kthread</code>函数栈上有一个<code>kthread</code>结构体可以通过<code>task_struct</code>结构体获取到其地址（同名的函数和结构体有种绕口令的感觉）。实际就是通过内部成员地址以及其在结构体中偏移量的方式反向获取到结构体地址。对内核线程的操作都与该结构体有关。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr, type, member) (&#123;                      \</span></span><br><span class="line">    const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);    \</span><br><span class="line">    (type *)( (<span class="keyword">char</span> *)__mptr - offsetof(type,member) );&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __to_kthread(vfork) \</span></span><br><span class="line">    container_of(vfork, struct kthread, exited)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct kthread *<span class="title">to_live_kthread</span><span class="params">(struct task_struct *k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">completion</span> *<span class="title">vfork</span> = <span class="title">ACCESS_ONCE</span>(<span class="title">k</span>-&gt;<span class="title">vfork_done</span>);</span></span><br><span class="line">    <span class="keyword">if</span> (likely(vfork))</span><br><span class="line">        <span class="keyword">return</span> __to_kthread(vfork);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/linux/">linux</a></div><div class="post-nav"><a class="pre" href="/2018/08/22/netlink/">Linux netlink socket 内核通信</a><a class="next" href="/2018/07/25/receive-packet/">Linux kernel 链路层帧接收</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://www.hyuuhit.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/libvirt/">libvirt</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/suricata/">suricata</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/vmware/" style="font-size: 15px;">vmware</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2024/05/26/dirpro-bug-analysis/">一次无源码Linux内核模块bug分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/05/13/elrepo-not-for-production-use/">为什么生产环境服务器不应该使用ELRepo内核</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/04/29/memory-consistency-model-memory-barrier-and-sychronization/">内存一致性模型、内存屏障与同步</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/04/11/rcu-usage/">抢占式RCU与RCU使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/09/16/tc-tbf-qdisc/">tc tbf qdisc</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/08/function-call-stack/">gdb查看寄存器及内存数据与函数调用栈分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/16/libpcap-cutoff-captured-packet/">libpcap在libvirt虚拟化环境下捕获数据包不完整的一种情况分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/27/bash-audit/">一种简单的bash审计方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/20/bash-invocation/">bash 调用方式与配置文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/17/uriparser/">uriparser 解析处理URI</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">属乌鸦的.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>