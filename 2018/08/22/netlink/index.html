<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="hu yu's blog | Android | 服务端"><title>Linux netlink socket 内核通信 | 属乌鸦的</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-129648993-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '85d80db9310fa34ab2f7d34beeff589b';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Linux netlink socket 内核通信</h1><a id="logo" href="/.">属乌鸦的</a><p class="description">无知 &amp; 聒噪</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Linux netlink socket 内核通信</h1><div class="post-meta">Aug 22, 2018</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#netlink-使用"><span class="toc-number">1.</span> <span class="toc-text">netlink 使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#例子代码"><span class="toc-number">1.1.</span> <span class="toc-text">例子代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用户态"><span class="toc-number">1.2.</span> <span class="toc-text">用户态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#地址"><span class="toc-number">1.2.1.</span> <span class="toc-text">地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#消息格式"><span class="toc-number">1.2.2.</span> <span class="toc-text">消息格式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内核态"><span class="toc-number">1.3.</span> <span class="toc-text">内核态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#内核态-netlink-socket-创建"><span class="toc-number">1.3.1.</span> <span class="toc-text">内核态 netlink socket 创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内核态-netlink-socket-收消息"><span class="toc-number">1.3.2.</span> <span class="toc-text">内核态 netlink socket 收消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内核态-netlink-socket-发消息"><span class="toc-number">1.3.3.</span> <span class="toc-text">内核态 netlink socket 发消息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#netlink-实现"><span class="toc-number">2.</span> <span class="toc-text">netlink 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#netlink-协议初始化"><span class="toc-number">2.1.</span> <span class="toc-text">netlink 协议初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内核态-netlink-socket-创建-1"><span class="toc-number">2.2.</span> <span class="toc-text">内核态 netlink socket 创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用户态-netlink-socket-创建"><span class="toc-number">2.3.</span> <span class="toc-text">用户态 netlink socket 创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用户态-netlink-socket-bind"><span class="toc-number">2.4.</span> <span class="toc-text">用户态 netlink socket bind</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用户态-netlink-socket-sendto"><span class="toc-number">2.5.</span> <span class="toc-text">用户态 netlink socket sendto</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#netlink-unicast"><span class="toc-number">2.5.1.</span> <span class="toc-text">netlink_unicast</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#netlink-broadcast"><span class="toc-number">2.5.2.</span> <span class="toc-text">netlink_broadcast</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用户态-netlink-socket-其他操作"><span class="toc-number">2.6.</span> <span class="toc-text">用户态 netlink socket 其他操作</span></a></li></ol></li></ol></div></div><div class="post-content"><p>Netlink用于内核与用户空间程序传输信息，同时也可用于用户进程间通信。它包含用户空间下基于socket的标准接口，以及用于内核模块的内核API。iproute2工具包使用该方式从用户空间与内核进行通信。这里介绍netlink的简单使用方式与其实现原理。</p>
<a id="more"></a>
<p>本文内容参考内核版本 3.10.0-862.el7.x86_64</p>
<h2 id="netlink-使用"><a href="#netlink-使用" class="headerlink" title="netlink 使用"></a>netlink 使用</h2><h3 id="例子代码"><a href="#例子代码" class="headerlink" title="例子代码"></a>例子代码</h3><p>先看一个简单例子的代码</p>
<p>ps: 自定义netlink协议不推荐直接占用32个netlink协议号中的未使用号码，后面会单独文章介绍generic netlink的使用。</p>
<figure class="highlight c"><figcaption><span>nl_kern.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/skbuff.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netdevice.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"Hu Yu &lt;hyuuhit@gmail.com&gt;"</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"netlink example"</span>);</span><br><span class="line">MODULE_VERSION(<span class="string">"0.1"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_NETLINK_TYPE 26</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">my_nl_sock</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nl_input</span><span class="params">(struct sk_buff *skb)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">"recv msg len: %d\n"</span>, skb-&gt;len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (skb-&gt;data[skb-&gt;len - <span class="number">1</span>] == <span class="string">'\0'</span>)</span><br><span class="line">        pr_info(<span class="string">"recv msg str: %s\n"</span>, skb-&gt;data);</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">"portid   : %d\n"</span>, NETLINK_CB(skb).portid);</span><br><span class="line">    pr_info(<span class="string">"dst_group: %d\n"</span>, NETLINK_CB(skb).dst_group);</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">"====================\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">my_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">netlink_kernel_cfg</span> <span class="title">cfg</span> = &#123;</span></span><br><span class="line">        .groups = <span class="number">0</span>,</span><br><span class="line">        .input = nl_input,</span><br><span class="line">    &#125;;</span><br><span class="line">    pr_info(<span class="string">"my init.\n"</span>);</span><br><span class="line"></span><br><span class="line">    my_nl_sock = netlink_kernel_create(&amp;init_net, MY_NETLINK_TYPE, &amp;cfg);</span><br><span class="line">    <span class="keyword">if</span> (!my_nl_sock) &#123;</span><br><span class="line">        pr_info(<span class="string">"nl create failed\n"</span>);</span><br><span class="line">        pr_info(<span class="string">"====================\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">"====================\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">my_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pr_info(<span class="string">"my exit.\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (my_nl_sock) &#123;</span><br><span class="line">        netlink_kernel_release(my_nl_sock);</span><br><span class="line">    &#125;</span><br><span class="line">    pr_info(<span class="string">"====================\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_init);</span><br><span class="line">module_exit(my_exit);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>nl_user.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_NETLINK_TYPE 26</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> <span class="title">src_addr</span>, <span class="title">dest_addr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> msg[] = <span class="string">"hello from client."</span>;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"my pid: %d\n"</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create */</span></span><br><span class="line">    fd = socket(PF_NETLINK, SOCK_DGRAM, MY_NETLINK_TYPE);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"socekt failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* bind */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;src_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(src_addr));</span><br><span class="line">    src_addr.nl_family = AF_NETLINK;</span><br><span class="line">    src_addr.nl_pid = getpid();</span><br><span class="line">    src_addr.nl_groups = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    err = bind(fd, (struct sockaddr *)&amp;src_addr, <span class="keyword">sizeof</span>(src_addr));</span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"bind failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* send */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;dest_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(dest_addr));</span><br><span class="line">    dest_addr.nl_family = AF_NETLINK;</span><br><span class="line">    dest_addr.nl_pid = <span class="number">0</span>;</span><br><span class="line">    dest_addr.nl_groups = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    err = sendto(fd, msg, <span class="keyword">sizeof</span>(msg), <span class="number">0</span>, (struct sockaddr *)&amp;dest_addr, (<span class="keyword">socklen_t</span>)<span class="keyword">sizeof</span>(dest_addr));</span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"sendto failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><figcaption><span>Makefile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">obj-m := nl_kern.o</span><br><span class="line"></span><br><span class="line">PWD:=<span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line">KVER:=<span class="variable">$(<span class="built_in">shell</span> uname -r)</span></span><br><span class="line">KDIR:=/lib/modules/<span class="variable">$(KVER)</span>/build</span><br><span class="line"></span><br><span class="line">EXTRA_CFLAGS += -Wall -g</span><br><span class="line"></span><br><span class="line"><span class="section">all: kernel nl_user</span></span><br><span class="line"></span><br><span class="line"><span class="section">kernel:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">nl_user: nl_user.c</span></span><br><span class="line">    gcc <span class="variable">$(EXTRA_CFLAGS)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean</span><br><span class="line">    rm -f nl_user</span><br></pre></td></tr></table></figure>
<h3 id="用户态"><a href="#用户态" class="headerlink" title="用户态"></a>用户态</h3><p>可以与PF_INET协议族一样使用通用socket api，甚至限制更少，比如sendto的目的地址可以设置为NULL，默认目的nl_pid和nl_groups都为0，不过仍然建议显式设置。</p>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p>netlink socket地址结构体为<code>sockaddr_nl</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> &#123;</span></span><br><span class="line">    <span class="keyword">__kernel_sa_family_t</span>    nl_family;  <span class="comment">/* AF_NETLINK   */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  nl_pad;     <span class="comment">/* zero     */</span></span><br><span class="line">    __u32       nl_pid;     <span class="comment">/* port ID  */</span></span><br><span class="line">    __u32       nl_groups;  <span class="comment">/* multicast groups mask */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>nl_family<br>固定为<code>AF_NETLINK</code></li>
<li>nl_pid<br>在<code>bind</code>操作时用作本地绑定的单播源地址，用作唯一不重复的本地端口id，可以自由设置。如果设置为0，内核将自动分配一个id，优先pid，如果冲突了将会分配一个不冲突的id。<br>在<code>connect</code>或<code>send</code>类操作时，用作单播目的地址。内核的目的地址端口固定为0。</li>
<li>nl_groups<br>在<code>bind</code>操作时，用于表示该socket接收的组播消息的组位图，每一个非0位代表一个接收组。<br>在<code>send</code>类操作时，用于表示发送的组播组位图，<strong>但是</strong>只有最低非0位代表的一个组播组是有效的，也就是组播消息只能发给一个组。</li>
</ul>
<h4 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h4><p>很多文章包括man文件中都说明netlink消息需要包含nlmsghdr头，但实际情况是内核包含的netlink协议通过该协议头解析消息层次。自定义的netlink协议并不一定需要nlmsghdr头，在例子代码中可以看到与普通SOCK_DGRAM类socket一致，可以直接通过socket发送数据。在内核netlink收发代码中也可以验证这一点。</p>
<p>如果要使用nlmsghdr协议头，可以参考include/uapi/linux/netlink.h中的一组宏，帮助定位数据对齐。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 消息长度，包含消息头和payload。不包含payload后部为了对齐所需要的pad。 */</span></span><br><span class="line">    __u32       nlmsg_len;  <span class="comment">/* Length of message including header */</span></span><br><span class="line">    __u16       nlmsg_type; <span class="comment">/* Message content */</span></span><br><span class="line">    __u16       nlmsg_flags;    <span class="comment">/* Additional flags */</span></span><br><span class="line">    __u32       nlmsg_seq;  <span class="comment">/* Sequence number */</span></span><br><span class="line">    __u32       nlmsg_pid;  <span class="comment">/* Sending process port ID */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NLMSG_ALIGNTO   4U</span></span><br><span class="line"><span class="comment">/* 计算对齐后的长度 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NLMSG_ALIGN(len) ( ((len)+NLMSG_ALIGNTO-1) &amp; ~(NLMSG_ALIGNTO-1) )</span></span><br><span class="line"><span class="comment">/* nlmsghdr对齐后需要占用的长度 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NLMSG_HDRLEN     ((int) NLMSG_ALIGN(sizeof(struct nlmsghdr)))</span></span><br><span class="line"><span class="comment">/* 长度为len的数据包含nlmsghdr头后需要占用的长度，注意这里没有包含len后面为了对齐所需要的pad */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NLMSG_LENGTH(len) ((len) + NLMSG_HDRLEN)</span></span><br><span class="line"><span class="comment">/* 跟上面那个类似，区别就是增加了len后面为了对齐所需要的pad */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NLMSG_SPACE(len) NLMSG_ALIGN(NLMSG_LENGTH(len))</span></span><br><span class="line"><span class="comment">/* 参数为netlink消息，返回payload地址。 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NLMSG_DATA(nlh)  ((void*)(((char*)nlh) + NLMSG_LENGTH(0)))</span></span><br><span class="line"><span class="comment">/* nlh开始的缓冲区长度len，跳过一个netlink消息，返回下一个netlink消息地址，同时len做减法</span></span><br><span class="line"><span class="comment">   注意这里没有对nlh重新赋值</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NLMSG_NEXT(nlh,len)  ((len) -= NLMSG_ALIGN((nlh)-&gt;nlmsg_len), \</span></span><br><span class="line">                          (struct nlmsghdr*)(((<span class="keyword">char</span>*)(nlh)) + NLMSG_ALIGN((nlh)-&gt;nlmsg_len)))</span><br><span class="line"><span class="comment">/* nlh开始的缓冲区长度len以内，至少包含一个合法的netlink消息 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NLMSG_OK(nlh,len) ((len) &gt;= (int)sizeof(struct nlmsghdr) &amp;&amp; \</span></span><br><span class="line">                       (nlh)-&gt;nlmsg_len &gt;= <span class="keyword">sizeof</span>(struct nlmsghdr) &amp;&amp; \</span><br><span class="line">                       (nlh)-&gt;nlmsg_len &lt;= (len))</span><br><span class="line"><span class="comment">/* 返回payload中len字节偏移的指针 */</span></span><br><span class="line">#define NLMSG_PAYLOAD(nlh,len) ((nlh)-&gt;nlmsg_len - NLMSG_SPACE((len)))</span><br></pre></td></tr></table></figure>
<h3 id="内核态"><a href="#内核态" class="headerlink" title="内核态"></a>内核态</h3><p>内核api参考文件include/linux/netlink.h</p>
<h4 id="内核态-netlink-socket-创建"><a href="#内核态-netlink-socket-创建" class="headerlink" title="内核态 netlink socket 创建"></a>内核态 netlink socket 创建</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *</span></span><br><span class="line"><span class="class"><span class="title">netlink_kernel_create</span>(<span class="title">struct</span> <span class="title">net</span> *<span class="title">net</span>, <span class="title">int</span> <span class="title">unit</span>, <span class="title">struct</span> <span class="title">netlink_kernel_cfg</span> *<span class="title">cfg</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> __netlink_kernel_create(net, unit, THIS_MODULE, cfg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个参数是net namespace网络命名空间的内核结构体，可以理解netlink socket只在该命名空间有效。另外netlink_sock可以有一个flag，NETLINK_F_LISTEN_ALL_NSID，这时就可以接收所有namespace的消息。<br>第二个参数是netlink协议族下具体的协议号，在include/uapi/linux/netlink.h中预定义了一些协议号，并且设置了该协议族下最多允许32个协议号，这个限制用于nl_table的创建。理论上32以内未被占用的协议号可以用于自定义的netlink协议通信，但是这种方式并不规范，而且对于未来更新版本内核可能对协议号的占用兼容性不好，更合适的自定义netlink通信的方式是使用generic netlink，也就是编号为16的NETLINK_GENERIC通信，后面会有单独文章介绍。<br>第三个参数是一个配置用的结构体，定义如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* optional Netlink kernel configuration parameters */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netlink_kernel_cfg</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 支持的组播组数。并不是该内核netlink socket接收组播的位图，最终会使用该字段与32中的较大值确定组播组数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    groups;</span><br><span class="line">    <span class="comment">/* 设置该netlink协议是否允许非特权用户发送组播消息或接收组播消息 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    flags;</span><br><span class="line">    <span class="comment">/* 回调函数，发送给内核的消息将回调该函数处理 */</span></span><br><span class="line">    <span class="keyword">void</span>        (*input)(struct sk_buff *skb);</span><br><span class="line">    <span class="comment">/* 锁，用于netlink_dump，具体使用场景暂时不关注 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>    *<span class="title">cb_mutex</span>;</span></span><br><span class="line">    <span class="comment">/* 回调函数，当有netlink socket绑定到组播组时回调该函数通知，参数为组播号 */</span></span><br><span class="line">    <span class="keyword">int</span>         (*bind)(<span class="keyword">int</span> group);</span><br><span class="line">    <span class="comment">/* 回调函数，当有netlink socket解绑组播组时回调该函数通知，参数为组播号 */</span></span><br><span class="line">    <span class="keyword">void</span>        (*unbind)(<span class="keyword">int</span> group);</span><br><span class="line">    <span class="comment">/* 我看的内核版本中对该函数指针没有使用，应该是内核高版本功能移植时导致的。更新版本内核暂时不关注。 */</span></span><br><span class="line">    <span class="keyword">bool</span>        (*compare)(struct net *net, struct sock *sk);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="内核态-netlink-socket-收消息"><a href="#内核态-netlink-socket-收消息" class="headerlink" title="内核态 netlink socket 收消息"></a>内核态 netlink socket 收消息</h4><p>用户态程序发送消息给内核netlink socket时，上一步配置的input回调函数将被调用。注意这里位于系统调用的上下文，也就是进程上下文。</p>
<h4 id="内核态-netlink-socket-发消息"><a href="#内核态-netlink-socket-发消息" class="headerlink" title="内核态 netlink socket 发消息"></a>内核态 netlink socket 发消息</h4><p>参考include/net/netlink.h中的注释。</p>
<p>单模使用<code>netlink_unicast</code>，实现参考<a href="#netlink-unicast">用户态sendto的单播实现</a>。</p>
<p>组播使用<code>netlink_multicast</code>，这只是<code>netlink_broadcast</code>的简单包装，实现参考<a href="#netlink-broadcast">用户态sendto的组播实现</a>。</p>
<h2 id="netlink-实现"><a href="#netlink-实现" class="headerlink" title="netlink 实现"></a>netlink 实现</h2><p>先看一下netlink socket在内核中的实现的结构关系。</p>
<p><img src="http://blog-image.hyuuhit.com/2018/08/netlink.jpg" alt="abc"></p>
<h3 id="netlink-协议初始化"><a href="#netlink-协议初始化" class="headerlink" title="netlink 协议初始化"></a>netlink 协议初始化</h3><p>内核在启动阶段完成netlink协议的初始化，函数为<code>netlink_proto_init</code>，重点为两点。</p>
<ul>
<li><code>nl_table</code>的内存分配与哈希表初始化。</li>
<li>为用户态netlink socket的创建提供支持，具体为将<code>netlink_family_ops</code>注册到<code>net_families[PF_NETLINK]</code>上，这里的<code>create</code>函数指针（也就是函数<code>netlink_create</code>将在创建socket的系统调用中发挥作用）。</li>
</ul>
<p>函数最后包含的<code>rtnetlink_init</code>可以作为内核netlink api使用方式的参考。</p>
<figure class="highlight c"><figcaption><span>netlink_family_ops定义</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>     family;</span><br><span class="line">    <span class="keyword">int</span>     (*create)(struct net *net, struct socket *sock,</span><br><span class="line">            <span class="keyword">int</span> protocol, <span class="keyword">int</span> kern);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span>   *<span class="title">owner</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> <span class="title">netlink_family_ops</span> = &#123;</span></span><br><span class="line">    .family = PF_NETLINK,</span><br><span class="line">    .create = netlink_create,</span><br><span class="line">    .owner  = THIS_MODULE,  <span class="comment">/* for consistency 8) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>netlink协议初始化流程</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">+------------------+</span><br><span class="line">|netlink_proto_init|</span><br><span class="line">+---------+--------+</span><br><span class="line">          |</span><br><span class="line">          |   +--------------+</span><br><span class="line">          +---+proto_register|</span><br><span class="line">          |   +--------------+</span><br><span class="line">          |    参数为netlink_proto，将其注册到proto_list全局链表上，</span><br><span class="line">          |    作用是proc文件系统上/proc/net/protocols显示支持的协议。</span><br><span class="line">          |</span><br><span class="line">          |</span><br><span class="line">          +--- nl_table全局数组分配内存，并初始化每一个协议项的哈希表。</span><br><span class="line">          |            netlink的操作围绕这个全局数组展开。</span><br><span class="line">          |</span><br><span class="line">          |</span><br><span class="line">          +--- 初始化链表头netlink_tap_all，用于挂载netlink_tap结构体。</span><br><span class="line">          |            看起来是用于监听，这里不做重点跟进。</span><br><span class="line">          |</span><br><span class="line">          |   +--------------------------+</span><br><span class="line">          +---+netlink_add_usersock_entry|</span><br><span class="line">          |   +--------------------------+</span><br><span class="line">          |    初始化了nl_table[NETLINK_USERSOCK]项。</span><br><span class="line">          |    从代码看应该是用于用户态进程间通信预留的，因为并没有内核接收函数。</span><br><span class="line">          |</span><br><span class="line">          |   +-------------+</span><br><span class="line">          +---+sock_register|</span><br><span class="line">          |   +-------------+</span><br><span class="line">          |    参数为netlink_family_ops，实际为net_families[PF_NETLINK]赋值netlink_family_ops。</span><br><span class="line">          |    作为用socket系统调用时，为该协议族指定创建时调用的函数指针，这里为netlink_create </span><br><span class="line">          |</span><br><span class="line">          |   +----------------------+</span><br><span class="line">          +---+register_pernet_subsys|</span><br><span class="line">          |   +----------------------+</span><br><span class="line">          |    为每个net namespace注册proc文件系统节点</span><br><span class="line">          |   </span><br><span class="line">          |   +--------------+</span><br><span class="line">          +---+rtnetlink_init|</span><br><span class="line">          |   +--------------+</span><br><span class="line">          |    初始化rtnetlink，用于网络相关配置操作。这也是netlink出现的最初目的。</span><br><span class="line">          |    关于内核netlink的正确使用方式，可以参考这里。</span><br><span class="line">          |</span><br><span class="line">          v</span><br><span class="line">         返回</span><br></pre></td></tr></table></figure>
<h3 id="内核态-netlink-socket-创建-1"><a href="#内核态-netlink-socket-创建-1" class="headerlink" title="内核态 netlink socket 创建"></a>内核态 netlink socket 创建</h3><p>内核代码使用<code>netlink_create_kernel</code>函数创建netlink socket。实现重点是：</p>
<ul>
<li>创建关联的struct socket和struct sock，这里sock实际空间类型为struct netlink_sock。</li>
<li>将netlink_sock插入nl_table该协议项的哈希表中。</li>
<li>将参数中cfg配置填充入nl_table该协议项内和netlink_sock中。</li>
</ul>
<figure class="highlight plain"><figcaption><span>内核netlink socket创建流程</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">|netlink_kernel_create|</span><br><span class="line">+----------+----------+</span><br><span class="line">           |</span><br><span class="line">           |   +-----------------------+</span><br><span class="line">           +---+__netlink_kernel_create|</span><br><span class="line">           |   +-----------+-----------+</span><br><span class="line">           |               |</span><br><span class="line">           |               |    +----------------+</span><br><span class="line">           |               +----+sock_create_lite|</span><br><span class="line">           |               |    +----------------+</span><br><span class="line">           |               |     创建struct socket结构</span><br><span class="line">           |               |</span><br><span class="line">           |               |    +----------------+</span><br><span class="line">           |               +----+__netlink_create|</span><br><span class="line">           |               |    +----------------+</span><br><span class="line">           |               |     socket的ops赋值为netlink_ops，</span><br><span class="line">           |               |     创建struct sock结构，</span><br><span class="line">           |               |     实际分配空间为struct netlink_sock</span><br><span class="line">           |               |     内部有调用sock_init_data初始化sock和sk内部字段，比如sk_data_ready函数指针</span><br><span class="line">           |               |</span><br><span class="line">           |               |    +----------------------------------------------------------------+</span><br><span class="line">           |               |    |更新sk关联的net namespace                                       |</span><br><span class="line">           |               |    |确定最终使用的组播组数，取cfg-&gt;groups与32中的较大值             |</span><br><span class="line">           |               |    |为组播位图listeners分配内存                                     |</span><br><span class="line">           |               |    |                                                                |</span><br><span class="line">           |               |    |设置sk字段函数指针sk_data_ready为netlink_data_ready             |</span><br><span class="line">           |               +----+这个函数在内核netlink_sock中是无用的，因为内核收消息流程的原因。|</span><br><span class="line">           |               |    |可以看到是一个空函数                                            |</span><br><span class="line">           |               |    |                                                                |</span><br><span class="line">           |               |    |设置nlk(netlink_sock)字段函数指针netlink_rcv为cfg中input函数指针|</span><br><span class="line">           |               |    |这将在内核收消息时被调用                                        |</span><br><span class="line">           |               |    +----------------------------------------------------------------+</span><br><span class="line">           |               |</span><br><span class="line">           |               |    +--------------+</span><br><span class="line">           |               +----+netlink_insert|</span><br><span class="line">           |               |    +-------+------+</span><br><span class="line">           |               |            |</span><br><span class="line">           |               |            |</span><br><span class="line">           |               |            +----&gt; 设置netlink_sock的portid</span><br><span class="line">           |               |            |</span><br><span class="line">           |               |            |     +----------------+</span><br><span class="line">           |               |            +-----+__netlink_insert|</span><br><span class="line">           |               |            |     +----------------+</span><br><span class="line">           |               |            |      struct sock插入nl_table特定表项的哈希表中</span><br><span class="line">           |               |            |</span><br><span class="line">           |               |            +----&gt; 设置netlink_sock的bound为portid</span><br><span class="line">           |               |            |</span><br><span class="line">           |               |&lt;-----------+</span><br><span class="line">           |               |</span><br><span class="line">           |               |    +----------------------------------------------------------------------------------+</span><br><span class="line">           |               |    |将struct sock指针转换为netlink_sock指针                                           |</span><br><span class="line">           |               +----+设置flags增加标记NETLINK_F_KERNEL_SOCKET                                          |</span><br><span class="line">           |               |    |标记这是一个内核netlink_sock，因为内核和用户态netlink_sock对接收消息的处理方式不同|</span><br><span class="line">           |               |    +----------------------------------------------------------------------------------+</span><br><span class="line">           |               |</span><br><span class="line">           |               |    +---------------------------------------------------------+</span><br><span class="line">           |               +----|nl_table特定表项根据struct netlink_kernel_cfg类型参数填充|</span><br><span class="line">           |               |    +---------------------------------------------------------+</span><br><span class="line">           |&lt;--------------+</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">   返回struct sock结构指针</span><br></pre></td></tr></table></figure>
<h3 id="用户态-netlink-socket-创建"><a href="#用户态-netlink-socket-创建" class="headerlink" title="用户态 netlink socket 创建"></a>用户态 netlink socket 创建</h3><p>用户态socket创建调用了<code>net_families</code>中该协议族的<code>create</code>函数指针。netlink初始化时为PF_NETLINK协议族设定了函数指针为<code>netlink_create</code>函数。在这里为socket的ops指针赋值为<code>netlink_ops</code>，这里的函数指针涉及针对socket的系统调用，定义如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> <span class="title">netlink_ops</span> = &#123;</span></span><br><span class="line">    .family =   PF_NETLINK,</span><br><span class="line">    .owner =    THIS_MODULE,</span><br><span class="line">    .release =  netlink_release,</span><br><span class="line">    .bind =     netlink_bind,</span><br><span class="line">    .connect =  netlink_connect,</span><br><span class="line">    .socketpair =   sock_no_socketpair,</span><br><span class="line">    .accept =   sock_no_accept,</span><br><span class="line">    .getname =  netlink_getname,</span><br><span class="line">    .poll =     datagram_poll,</span><br><span class="line">    .ioctl =    sock_no_ioctl,</span><br><span class="line">    .listen =   sock_no_listen,</span><br><span class="line">    .shutdown = sock_no_shutdown,</span><br><span class="line">    .setsockopt =   netlink_setsockopt,</span><br><span class="line">    .getsockopt =   netlink_getsockopt,</span><br><span class="line">    .sendmsg =  netlink_sendmsg,</span><br><span class="line">    .recvmsg =  netlink_recvmsg,</span><br><span class="line">    .mmap =     sock_no_mmap,</span><br><span class="line">    .sendpage = sock_no_sendpage,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>用户态netlink socket创建流程</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">+--------------+</span><br><span class="line">|socket系统调用|</span><br><span class="line">+-------+------+</span><br><span class="line">        |</span><br><span class="line">        |   +-----------+</span><br><span class="line">        +---+sock_create|</span><br><span class="line">        |   +--+--------+                         </span><br><span class="line">        |      |                           </span><br><span class="line">        |      |  +-------------+          </span><br><span class="line">        |      +--+__sock_create|         </span><br><span class="line">        |         +------+------+            </span><br><span class="line">        |                | </span><br><span class="line">        |                |  +----------+                           </span><br><span class="line">        |                +--+sock_alloc| 分配struct socket              </span><br><span class="line">        |                |  +----------+                   </span><br><span class="line">        |                |                 </span><br><span class="line">        |                |  +--------------------------------+</span><br><span class="line">        |                |  |net_families[PF_NETLINK]-&gt;create|  </span><br><span class="line">        |                +--+                                |</span><br><span class="line">        |                |  |  实际调用函数为netlink_create  |</span><br><span class="line">        |                |  +-----+--------------------------+</span><br><span class="line">        |                |        |                </span><br><span class="line">        |                |        |     +----------------+</span><br><span class="line">        |                |        +-----+__netlink_create|</span><br><span class="line">        |                |        |     +----------------+</span><br><span class="line">        |                |        |      socket的ops赋值为netlink_ops，</span><br><span class="line">        |                |        |      创建struct sock结构，</span><br><span class="line">        |                |        |      实际分配空间为struct netlink_sock</span><br><span class="line">        |                |        |      内部有调用sock_init_data初始化sock和sk内部字段，比如sk_data_ready函数指针</span><br><span class="line">        |                |        |</span><br><span class="line">        |                |        |</span><br><span class="line">        |                |        |     +----------------------------+</span><br><span class="line">        |                |        +-----+设置netlink_sock的回调函数，|</span><br><span class="line">        |                |        |     |netlink_bind，netlink_unbind|</span><br><span class="line">        |                |        |     +----------------------------+</span><br><span class="line">        |                |&lt;-------+</span><br><span class="line">        |&lt;---------------+</span><br><span class="line">        |</span><br><span class="line">        |</span><br><span class="line">        |   +-----------+</span><br><span class="line">        +---+sock_map_fd| struct socket结构映射文件描述符fd</span><br><span class="line">        |   +-----------+     </span><br><span class="line">        |</span><br><span class="line">     返回fd</span><br></pre></td></tr></table></figure>
<h3 id="用户态-netlink-socket-bind"><a href="#用户态-netlink-socket-bind" class="headerlink" title="用户态 netlink socket bind"></a>用户态 netlink socket bind</h3><p>看过前面的内容，用户态bind操作就好理解了，系统调用处理函数中调用socket的ops-&gt;bind函数指针，对于netlink协议族来说就是函数<code>netlink_bind</code>。这里涉及有组播的配置操作，注意区分位图与组播组数的区别就好。<br>bind完成后，内核态和用户态netlink socket的结构关系就基本配置完成了。</p>
<figure class="highlight plain"><figcaption><span>用户态netlink socket bind流程</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">+------------+</span><br><span class="line">|bind系统调用|</span><br><span class="line">+-----+------+</span><br><span class="line">      |</span><br><span class="line">      |   +-------------------+</span><br><span class="line">      +---+sockfd_lookup_light|</span><br><span class="line">      |   +-------------------+</span><br><span class="line">      |    通过fd查找struct socket结构</span><br><span class="line">      | </span><br><span class="line">      |   +-------------------+</span><br><span class="line">      +---+move_addr_to_kernel| </span><br><span class="line">      |   +-------------------+</span><br><span class="line">      |    将用户态内存地址中的地址参数数据拷贝到内核</span><br><span class="line">      | </span><br><span class="line">      |   +-------------------------------+</span><br><span class="line">      |   |调用socket成员ops-&gt;bind函数指针|</span><br><span class="line">      +---+                               |</span><br><span class="line">      |   |  实际调用函数为netlink_bind   |</span><br><span class="line">      |   +---------------+---------------+</span><br><span class="line">      |                   |</span><br><span class="line">      |                   |   +-----------------------------------------------------------------------+</span><br><span class="line">      |                   |   |如果bind地址中nl_groups不为0                                           |</span><br><span class="line">      |                   |   |首先检查了是否允许非特权用户接收组播消息或该用户是否有CAP_NET_ADMIN特权|</span><br><span class="line">      |                   +---+权限检查通过后调用netlink_realloc_groups                               |</span><br><span class="line">      |                   |   |为netlink_sock分配组播位图空间并记录位图支持组个数上限                 |</span><br><span class="line">      |                   |   +-----------------------------------------------------------------------+</span><br><span class="line">      |                   |</span><br><span class="line">      |                   |   +----------------------------------------------------------------------+</span><br><span class="line">      |                   |   |如果该netlink_sock之前有过绑定端口，                                  |</span><br><span class="line">      |                   |   |这里将会检查传入的nl_pid是否与之前绑定的端口号相同。                  |</span><br><span class="line">      |                   +---+                                                                      |</span><br><span class="line">      |                   |   |可以看到如果需要修改绑定的组播号，可以多次调用bind传入最新需要的组播号|</span><br><span class="line">      |                   |   |只是需要注意参数中的nl_pid要与之前绑定的端口号相同                    |</span><br><span class="line">      |                   |   |如果是自动分配的端口号，可以通过getsockname函数获取已经绑定的端口号   |</span><br><span class="line">      |                   |   +----------------------------------------------------------------------+</span><br><span class="line">      |                   |</span><br><span class="line">      |                   |   +----------------------------------------------------------+</span><br><span class="line">      |                   +---+如果bind有组播，同时之前的内核netlink设置有bind回调函数   |</span><br><span class="line">      |                   |   |对于接收组播的每一位调用回调函数，参数为每一位代表的组序号|</span><br><span class="line">      |                   |   +----------------------------------------------------------+</span><br><span class="line">      |                   |</span><br><span class="line">      |                   |   +-------------------------------------------------------------------+</span><br><span class="line">      |                   |   |netlink_insert将bind地址参数中的nl_pid设置入netlink_sock，         |</span><br><span class="line">      |                   +---+同时插入nl_table特定的哈希表中。                                   |</span><br><span class="line">      |                   |   |如果传入的nl_pid为0，将调用netlink_autobind自动分配一个不冲突的值，|</span><br><span class="line">      |                   |   |然后调用netlink_insert。                                           |</span><br><span class="line">      |                   |   +-------------------------------------------------------------------+</span><br><span class="line">      |                   |</span><br><span class="line">      |                   |   +----------------------------+</span><br><span class="line">      |                   |   |netlink_update_subscriptions|</span><br><span class="line">      |                   |   +----------------------------+</span><br><span class="line">      |                   |    更新netlink_sock成员subscriptions，记录订阅的组播组数</span><br><span class="line">      |                   |    如果存在订阅组播，需要将struct sock成员sk_bind_node插入到nl_table特定项的mc_list链表中</span><br><span class="line">      |                   |</span><br><span class="line">      |                   |</span><br><span class="line">      |                   +--- 更新组播位图</span><br><span class="line">      |                   |</span><br><span class="line">      |                   |   +------------------------+</span><br><span class="line">      |                   +---+netlink_update_listeners|</span><br><span class="line">      |                   |   +------------------------+</span><br><span class="line">      |                   |    更新nl_table特定表项成员listeners-&gt;masks位图记录了该协议下有哪些组存在被订阅</span><br><span class="line">      |                   |</span><br><span class="line">      |&lt;------------------+</span><br><span class="line">      |</span><br><span class="line">      v</span><br><span class="line"> 返回成功失败</span><br></pre></td></tr></table></figure>
<h3 id="用户态-netlink-socket-sendto"><a href="#用户态-netlink-socket-sendto" class="headerlink" title="用户态 netlink socket sendto"></a>用户态 netlink socket sendto</h3><figure class="highlight plain"><figcaption><span>用户态netlink socket sendto流程</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">+--------------+</span><br><span class="line">|sendto系统调用|</span><br><span class="line">+-----+--------+</span><br><span class="line">      |</span><br><span class="line">      |   +-------------------+</span><br><span class="line">      +---+sockfd_lookup_light|</span><br><span class="line">      |   +-------------------+</span><br><span class="line">      |    通过fd查找struct socket结构</span><br><span class="line">      | </span><br><span class="line">      |   +-------------------+</span><br><span class="line">      +---+move_addr_to_kernel| </span><br><span class="line">      |   +-------------------+</span><br><span class="line">      |    将用户态内存地址中的地址参数数据拷贝到内核</span><br><span class="line">      |</span><br><span class="line">      |   +---------------------------------------------------------+</span><br><span class="line">      +---+组装一个struct msghdr结构，要发送的数据地址和长度填充其中|</span><br><span class="line">      |   +---------------------------------------------------------+</span><br><span class="line">      |   </span><br><span class="line">      |   +------------------------------------------------------+</span><br><span class="line">      |   |sock_sendmsg -&gt; __sock_sendmsg -&gt; __sock_sendmsg_nosec|</span><br><span class="line">      +---+内部调用socket成员ops-&gt;sendmsg，实际调用函数为        |</span><br><span class="line">      |   |                   netlink_sendmsg                    |</span><br><span class="line">      |   +---+--------------------------------------------------+</span><br><span class="line">      |       |     这里忽略安全相关操作，不做分析</span><br><span class="line">      |       |</span><br><span class="line">      |       |      +--------------------------------------------------------------------------+</span><br><span class="line">      |       +------+选择目标portid和group，                                                   |</span><br><span class="line">      |       |      |如果传入的目标地址为空则使用netlink_sock结构成员(如果没有connect过应该是0)|</span><br><span class="line">      |       |      +--------------------------------------------------------------------------+</span><br><span class="line">      |       |</span><br><span class="line">      |       |      +------------------------------------------------------+</span><br><span class="line">      |       +------+如果没有bind过，调用netlink_autobind自动bind一个portid|</span><br><span class="line">      |       |      +------------------------------------------------------+</span><br><span class="line">      |       |</span><br><span class="line">      |       |      +-----------------------+</span><br><span class="line">      |       +------+netlink_alloc_large_skb|</span><br><span class="line">      |       |      |   分配一个skb内存     |</span><br><span class="line">      |       |      +-----------------------+</span><br><span class="line">      |       |</span><br><span class="line">      |       |      +-----------------------------------------------------+</span><br><span class="line">      |       +------+使用NETLINK_CB取得skb中的control buffer              |</span><br><span class="line">      |       |      |写入当前netlink_sock的portid、dst_group、creds、flags|</span><br><span class="line">      |       |      +-----------------------------------------------------+</span><br><span class="line">      |       |</span><br><span class="line">      |       |      +-------------------------------+</span><br><span class="line">      |       +------+memcpy_from_msg                |</span><br><span class="line">      |       |      |从用户态内存地址复制数据到skb中|</span><br><span class="line">      |       |      +-------------------------------+</span><br><span class="line">      |       |</span><br><span class="line">      |       |      +--------------------------------------------------+</span><br><span class="line">      |       |      |如果目标地址包含组播组，首先增加skb-&gt;users引用计数|</span><br><span class="line">      |       |      |(这个引用计数将在广播完成后由函数内部消费掉)      |</span><br><span class="line">      |       |      |                                                  |</span><br><span class="line">      |       |      | netlink_broadcast做广播，但是广播的返回值并不在意|</span><br><span class="line">      |       |      |                                                  |</span><br><span class="line">      |       |      +--------------------------------------------------+</span><br><span class="line">      |       |</span><br><span class="line">      |       |      +--------------------------+</span><br><span class="line">      |       |      |                          |</span><br><span class="line">      |       +------+ netlink_unicast做单播    |</span><br><span class="line">      |       |      |                          |</span><br><span class="line">      |       |      | 单播返回值作为函数返回值 |</span><br><span class="line">      |       |      |                          |</span><br><span class="line">      |       |      +--------------------------+</span><br><span class="line">      |       |</span><br><span class="line">      |&lt;------+</span><br><span class="line">      |</span><br><span class="line">      v</span><br><span class="line"> 返回成功失败</span><br></pre></td></tr></table></figure>
<h4 id="netlink-unicast"><a href="#netlink-unicast" class="headerlink" title="netlink_unicast"></a>netlink_unicast</h4><p>函数定义为<br><code>int netlink_unicast(struct sock *ssk, struct sk_buff *skb, u32 portid, int nonblock)</code></p>
<ul>
<li>ssk<br>发送源的struct sock结构。</li>
<li>skb<br>需要发送的数据。</li>
<li>portid<br>目标portid。</li>
<li>nonblock<br>标记是否阻塞。(如果使用阻塞方式，将取ssk的sk_sndtimeo字段作为超时时间，且可能会引起调度。如果在中断和软中断上下文中使用需要注意)。</li>
</ul>
<figure class="highlight plain"><figcaption><span>netlink_unicast 流程</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">+---------------+</span><br><span class="line">|netlink_unicast|</span><br><span class="line">+-------+-------+</span><br><span class="line">        |</span><br><span class="line">        |   +------------+</span><br><span class="line">        +---+netlink_trim|</span><br><span class="line">        |   +------------+</span><br><span class="line">        |    对于使用物理内存且空闲空间超过一半的skb，做裁剪操作。</span><br><span class="line">        |</span><br><span class="line">        |   +------------+</span><br><span class="line">        +---+取得超时时间|</span><br><span class="line">        |   +------------+</span><br><span class="line">        |</span><br><span class="line">        |   +-----------------------+</span><br><span class="line">        +---+netlink_getsockbyportid|</span><br><span class="line">        |   +-----------------------+</span><br><span class="line">        |    取得目标struct sock结构。返回已经sock_hold增加过引用计数sk_refcnt的struct sock结构。</span><br><span class="line">        |    通过ssk的协议号和net namespace选择同协议同namespace下目标portid的struct sock结构。</span><br><span class="line">        |    如果目标sk状态为NETLINK_CONNECTED且netlink_sock成员dst_port不等于ssk的port，则返回connection refused错误。</span><br><span class="line">        |    netlink_sock和sock的结构关系见图。</span><br><span class="line">        |</span><br><span class="line">        |   +----------------------------------------------------------------+</span><br><span class="line">        |   |netlink_is_kernel判断上一步拿到的sk是否是内核sk                 |</span><br><span class="line">        +---+方式就是判断netlink_sock字段flags是否包含NETLINK_F_KERNEL_SOCKET|</span><br><span class="line">        |   |这个标记在内核函数netlink_kernel_create中被设置。               |</span><br><span class="line">        |   +---------------+-------------------------------------------+----+</span><br><span class="line">        |                   |                                           |</span><br><span class="line">        |       如果是内核sk|                             如果不是内核sk|</span><br><span class="line">        |                   |                                           |</span><br><span class="line">        |                   v                                           |</span><br><span class="line">        |       +-------------------------------------------+           |</span><br><span class="line">        |       |netlink_unicast_kernel函数处理             |           |</span><br><span class="line">        |       |然后返回，netlink_unicast结束              |           |</span><br><span class="line">        |       |                                           |           |</span><br><span class="line">        +-------+如果netlink_sock没有netlink_rcv函数指针    |           |</span><br><span class="line">        |       |则释放skb，并释放sk引用计数                |           |</span><br><span class="line">        |       |                                           |           |</span><br><span class="line">        |       |如果有设置netlink_rcv函数指针则进行以下流程|           |</span><br><span class="line">        |       |(该函数指针是netlink_kernel_create传入的)  |           |</span><br><span class="line">        |       +-------------------------------------------+           |</span><br><span class="line">        |         |                                                     |</span><br><span class="line">        |         |   +-----------------------------------------+       |</span><br><span class="line">        |         |   |netlink_skb_set_owner_r                  |       |</span><br><span class="line">        |         +---+将skb-&gt;sk字段设置为目标sk并设置destructor|       |</span><br><span class="line">        |         |   |修改目标sk缓冲区相关成员                 |       |</span><br><span class="line">        |         |   +-----------------------------------------+       |</span><br><span class="line">        |         |                                                     |</span><br><span class="line">        |         |   +-----------------------------------+             |</span><br><span class="line">        |         +---+NETLINK_CB(skb).sk设置为源sk，既ssk|             |</span><br><span class="line">        |         |   +-----------------------------------+             |</span><br><span class="line">        |         |                                                     |</span><br><span class="line">        |         |   +---------------------------------+               |</span><br><span class="line">        |         +---+调用netlink_rcv函数指针处理skb   |               |</span><br><span class="line">        |         |   |而后释放skb，释放sk引用计数，返回|               |</span><br><span class="line">        |         |   +---------------------------------+               |</span><br><span class="line">        |&lt;--------+                                                     |</span><br><span class="line">        |                                                               |  </span><br><span class="line">        |                                                               |  </span><br><span class="line">        |       +-------------------------------------------------------+</span><br><span class="line">        |       |                                                        </span><br><span class="line">        |       |    +--------------------------------------------------------------+</span><br><span class="line">        |       +----+sk_filter判断是否阻断后续处理，不确定具体情况，可能与ebpf有关 |</span><br><span class="line">        |       |    +--------------------------------------------------------------+</span><br><span class="line">        |       |</span><br><span class="line">        |       |    +--------------------------------------------------------------------+</span><br><span class="line">        |       |    |netlink_attachskb                                                   |</span><br><span class="line">        |       |    |判断sk剩余缓冲区是否满足大小，如果有超时设置可能会引发调度。        |</span><br><span class="line">        |       +----+                                                                    |</span><br><span class="line">        |       |    |如果大小满足，调用netlink_skb_set_owner_r，将skb-&gt;sk字段设置为目标sk|</span><br><span class="line">        |       |    |并设置destructor和修改目标sk缓冲区相关成员                          |</span><br><span class="line">        |       |    +--------------------------------------------------------------------+</span><br><span class="line">        |       |</span><br><span class="line">        |       |    +----------------------------------------------------------------+</span><br><span class="line">        |       +----+根据上一步返回值判断是出错还是从netlink_getsockbyportid开始重试 |</span><br><span class="line">        |       |    |如果正常，返回值为0，进行下一步。                               |</span><br><span class="line">        |       |    +----------------------------------------------------------------+</span><br><span class="line">        |       |</span><br><span class="line">        |       |    +---------------+</span><br><span class="line">        |       +----+netlink_sendskb|</span><br><span class="line">        |       |    +----+----------+</span><br><span class="line">        |       |         |</span><br><span class="line">        |       |         |     +-----------------+</span><br><span class="line">        |       |         +-----+__netlink_sendskb|</span><br><span class="line">        |       |         |     +-+---------------+</span><br><span class="line">        |       |         |       |</span><br><span class="line">        |       |         |       |    +-------------------+</span><br><span class="line">        |       |         |       +----+netlink_deliver_tap|</span><br><span class="line">        |       |         |       |    +-------------------+</span><br><span class="line">        |       |         |       |        tap流程不关注</span><br><span class="line">        |       |         |       |</span><br><span class="line">        |       |         |       |    +--------------+</span><br><span class="line">        |       |         |       +----+skb_queue_tail|</span><br><span class="line">        |       |         |       |    +--------------+</span><br><span class="line">        |       |         |       |     将skb挂到sk字段sk_receive_queue上，这个函数使用了保存中断的自旋锁</span><br><span class="line">        |       |         |       |</span><br><span class="line">        |       |         |       |    +-------------------------------------------------+</span><br><span class="line">        |       |         |       +----+调用sk-&gt;sk_data_ready函数指针，参数为sk和数据长度|</span><br><span class="line">        |       |         |       |    +-------------------------------------------------+</span><br><span class="line">        |       |         |&lt;------+</span><br><span class="line">        |       |         |</span><br><span class="line">        |       |         |     +-----------------------------------------------------+</span><br><span class="line">        |       |         +-----+sock_put释放sk引用计数，如果不再有引用则sk_free释放sk|</span><br><span class="line">        |       |         |     +-----------------------------------------------------+</span><br><span class="line">        |       |         |</span><br><span class="line">        |       |&lt;--------+</span><br><span class="line">        |       |          </span><br><span class="line">        |&lt;------+          </span><br><span class="line">        |                 </span><br><span class="line">        v                 </span><br><span class="line">      返回</span><br></pre></td></tr></table></figure>
<h4 id="netlink-broadcast"><a href="#netlink-broadcast" class="headerlink" title="netlink_broadcast"></a>netlink_broadcast</h4><p>函数定义为</p>
<p><code>int netlink_broadcast(struct sock *ssk, struct sk_buff *skb, u32 portid, u32 group, gfp_t allocation)</code></p>
<ul>
<li>ssk<br>发送源的struct sock结构。</li>
<li>skb<br>需要发送的数据。</li>
<li>portid<br>单播目标portid，作为组播处理函数的参数是为了避免重复发送。</li>
<li>group</li>
<li>allocation</li>
</ul>
<figure class="highlight plain"><figcaption><span>netlink_broadcast 流程</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+----------------------------------------------------------------------------------------+</span><br><span class="line">|netlink_broadcast，直接调用netlink_broadcast_filterd(后两个参数过滤函数指针及数据置NULL)|</span><br><span class="line">+----------------------------------------------------------------------------------------+</span><br><span class="line">        |</span><br><span class="line">        |   +------------+</span><br><span class="line">        +---+netlink_trim|</span><br><span class="line">        |   +------------+</span><br><span class="line">        |</span><br><span class="line">        |   +--------------------------------------------+</span><br><span class="line">        +---+填充netlink_broadcast_data结构，变量命名info|</span><br><span class="line">        |   +--------------------------------------------+</span><br><span class="line">        |    为了后续函数调用参数整洁，创建了这个结构体传递组播使用到参数及需要返回检查的多个值</span><br><span class="line">        |    该结构体也只有这一个使用位置。</span><br><span class="line">        |</span><br><span class="line">        |   +---------------------------------------------------------------------+</span><br><span class="line">        |   |遍历nl_table数组中该协议号成员的mc_list(这里链接了所有订阅了组播的sk)|</span><br><span class="line">        +---+                                                                     |</span><br><span class="line">        |   |                对每个sk调用do_one_broadcast(sk, &amp;info)              |</span><br><span class="line">        |   +---+-----------------------------------------------------------------+</span><br><span class="line">        |       |</span><br><span class="line">        |       |   +-----------------------------------------------------------------------+</span><br><span class="line">        |       |   |排除源ssk，排除portid与单播portid相同的，                              |</span><br><span class="line">        |       |   |排除不包含组播group(这里的组播id从1开始，group为1的组对应位图0位)的sk  |</span><br><span class="line">        |       |   |                                                                       |</span><br><span class="line">        |       +---+如果sk与ssk的net namespace不同                                         |</span><br><span class="line">        |       |   |    sk对应的nlk字段flags不包含NETLINK_F_LISTEN_ALL_NSID，排除。        |</span><br><span class="line">        |       |   |    调用peernet_has_id比较sk与ssk的net返回0，排除。(这个不懂，暂时忽略)|</span><br><span class="line">        |       |   |    调用file_ns_capable检查网络广播权限返回0，排除。(这个细节暂时忽略) |</span><br><span class="line">        |       |   +-----------------------------------------------------------------------+</span><br><span class="line">        |       |</span><br><span class="line">        |       |   +-----------------------------------------------------------------+</span><br><span class="line">        |       +---+检查info-&gt;failure字段，如果为真说明之前对skb的skb_clone操作失败了|</span><br><span class="line">        |       |   |如果为真，调用netlink_overrun将出错消息传播给sk并返回            |</span><br><span class="line">        |       |   +-----------------------------------------------------------------+</span><br><span class="line">        |       |</span><br><span class="line">        |       |   +-----------------------------------------------------------------------------------+</span><br><span class="line">        |       |   |检查info-&gt;skb2字段，如果未NULL则由原skb取得一个独立的skb置于skb2字段用于后续广播   |</span><br><span class="line">        |       +---+取得独立skb的方式有两种，由原skb引用计数值区分：                                   |</span><br><span class="line">        |       |   |  大于1，调用skb_clone克隆一个，可能会失败                                         |</span><br><span class="line">        |       |   |  等于1，先增加引用计数再调用skb_orphan执行destructor后将其与destructor函数指针剥离|</span><br><span class="line">        |       |   +-----------------------------------------------------------------------------------+</span><br><span class="line">        |       |</span><br><span class="line">        |       |   +-----------------------------------------------------------------------------------------+</span><br><span class="line">        |       |   |如果info-&gt;skb2字段为NULL，说明上一步的操作失败了                                         |</span><br><span class="line">        |       |   |那么调用netlink_overrun将出错消息传递给sk，并将info-&gt;failure字段置1                      |</span><br><span class="line">        |       +---+    如果sk对应的nlk字段flags包含标记NETLINK_F_BROADCAST_SEND_ERROR                       |</span><br><span class="line">        |       |   |    则info-&gt;delivery_failure置1                                                          |</span><br><span class="line">        |       |   |函数返回                                                                                 |</span><br><span class="line">        |       |   |(这里的netlink_overrun和failure置1，配合再前一步对failure的检查，完成了对所有sk的出错传播|</span><br><span class="line">        |       |   +-----------------------------------------------------------------------------------------+</span><br><span class="line">        |       |</span><br><span class="line">        |       |   +----------------------------------------------------------------+</span><br><span class="line">        |       +---+对传入参数的过滤函数指针调用(在这个调用栈里该参数为NULL，不关注)|</span><br><span class="line">        |       |   +----------------------------------------------------------------+</span><br><span class="line">        |       |</span><br><span class="line">        |       |   +---------------------------------------------------+</span><br><span class="line">        |       +---+sk_filter过滤检查，如果未通过将释放skb2并置NULL返回|</span><br><span class="line">        |       |   +---------------------------------------------------+</span><br><span class="line">        |       |</span><br><span class="line">        |       |   +-------------------------------------------------------------+</span><br><span class="line">        |       |   |在sk的net字段netns_idr中查找ssk的net所对应的id               |</span><br><span class="line">        |       +---+赋值给NETLINK_CB的nsid字段，并为nsid_is_set置真              |</span><br><span class="line">        |       |   |(不明白为什么要为net对应的peer net分配id，取了又是做什么用？)|</span><br><span class="line">        |       |   +-------------------------------------------------------------+</span><br><span class="line">        |       |</span><br><span class="line">        |       |   +-------------------------------------------+</span><br><span class="line">        |       |   |                                           |</span><br><span class="line">        |       |   | netlink_broadcast_deliver(sk, info-&gt;skb2) |</span><br><span class="line">        |       |   |                                           |</span><br><span class="line">        |       |   +---+---------------------------------------+</span><br><span class="line">        |       |       |</span><br><span class="line">        |       |       |   +-----------------------------------------------------------------------+</span><br><span class="line">        |       |       +---+判断sk缓冲区是否满足要求及nlk-&gt;state字段是否包含标记NETLINK_S_CONGESTED|</span><br><span class="line">        |       |       |   |如果不满足要求直接返回-1                                               |</span><br><span class="line">        |       |       |   +-----------------------------------------------------------------------+</span><br><span class="line">        |       |       |</span><br><span class="line">        |       |       |</span><br><span class="line">        |       |       |   +-------------------------+</span><br><span class="line">        |       |       |   |                         |</span><br><span class="line">        |       |       |   | netlink_skb_set_owner_r |</span><br><span class="line">        |       |       +---+                         |</span><br><span class="line">        |       |       |   | __netlink_sendskb       |</span><br><span class="line">        |       |       |   |                         |</span><br><span class="line">        |       |       |   +-------------------------+</span><br><span class="line">        |       |       |    这里是真正的发送部分，</span><br><span class="line">        |       |       |    可以参考单播中同样的函数调用</span><br><span class="line">        |       |       |</span><br><span class="line">        |       |       |   +----------------------------+</span><br><span class="line">        |       |&lt;------+---+返回sk缓冲区是否是否超过一半|</span><br><span class="line">        |       |           +----------------------------+</span><br><span class="line">        |       |</span><br><span class="line">        |       |   +--------------------------------------------------------------------------------------------+</span><br><span class="line">        |       |   |如果上一步出错，也就是缓冲区不足，将会调用netlink_overrun对sk报错                           |</span><br><span class="line">        |       |   |    同时如果nlk-&gt;flags包含标记NETLINK_F_BROADCAST_SEND_ERROR                                |</span><br><span class="line">        |       |   |    则将info-&gt;delivery_failure置1                                                           |</span><br><span class="line">        |       +---+                                                                                            |</span><br><span class="line">        |       |   |如果上一步正常返回，                                                                        |</span><br><span class="line">        |       |   |    info-&gt;congested与返回值做或操作，也就是在遍历中记录是否存在拥塞的sk                     |</span><br><span class="line">        |       |   |    info-&gt;delivered置1                                                                      |</span><br><span class="line">        |       |   |    info-&gt;skb2置NULL（也就是说对每个组播中的sk，递交的skb2都是新的独立的，但数据不一定独立）|</span><br><span class="line">        |       |   +--------------------------------------------------------------------------------------------+</span><br><span class="line">        |       |</span><br><span class="line">        |       |</span><br><span class="line">        |&lt;------+        </span><br><span class="line">        |                </span><br><span class="line">        |   +---------------------------------+</span><br><span class="line">        +---+consume_skb(skb，也就是info-&gt;skb)|       </span><br><span class="line">        |   +---------------------------------+</span><br><span class="line">        |                </span><br><span class="line">        |   +------------------------------------------+</span><br><span class="line">        |   |                                          |</span><br><span class="line">        |   | 如果info-&gt;delivery_failure为真           |</span><br><span class="line">        +---+     kfree_skb(info.skb2)                 |</span><br><span class="line">        |   |     返回-ENOBUFS，也就是因为sk缓冲区不足 |</span><br><span class="line">        |   |                                          |</span><br><span class="line">        |   +------------------------------------------+</span><br><span class="line">        |                </span><br><span class="line">        |   +----------------------+</span><br><span class="line">        +---+consume_skb(info.skb2)|           </span><br><span class="line">        |   +----------------------+</span><br><span class="line">        |                </span><br><span class="line">        |   +---------------------------------------------------------------------------------------------+</span><br><span class="line">        |   |                                                                                             |</span><br><span class="line">        |   | 如果info-&gt;delivered为真，说明存在提交成功的sk，返回0                                        |</span><br><span class="line">        +---+     如果info-&gt;congested为真且内存分配标记包含__GFP_WAIT（也就是说当前允许调度，进程上下文） |</span><br><span class="line">        |   |     说明存拥塞，那么在返回0前先调用yield释放cpu且会闲置一会                                 |</span><br><span class="line">        |   |                                                                                             |</span><br><span class="line">        |   +---------------------------------------------------------------------------------------------+</span><br><span class="line">        |                </span><br><span class="line">        |   +------------------------------------------------+</span><br><span class="line">        |   |                                                |</span><br><span class="line">        +---+ 如果运行到这里了，说明没有合适的接收该组播的sk |</span><br><span class="line">        |   | 返回-ESRCH，No such process                    |</span><br><span class="line">        |   |                                                |</span><br><span class="line">        |   +------------------------------------------------+</span><br><span class="line">        |                </span><br><span class="line">        v                </span><br><span class="line">      返回</span><br></pre></td></tr></table></figure>
<h3 id="用户态-netlink-socket-其他操作"><a href="#用户态-netlink-socket-其他操作" class="headerlink" title="用户态 netlink socket 其他操作"></a>用户态 netlink socket 其他操作</h3><p>与前文操作类似，其他系统调用操作在系统调用处理函数中会调用struct socket的ops成员响应的函数指针，跟进代码就可以了。</p>
</div><div class="tags"><a href="/tags/linux/">linux</a></div><div class="post-nav"><a class="pre" href="/2018/08/25/vim-dot-file-indent/">graphviz(dot) file vim 缩进设置</a><a class="next" href="/2018/08/03/linux-kernel-thread/">Linux kernel thread 内核线程</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://www.hyuuhit.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/libvirt/">libvirt</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/suricata/">suricata</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/vmware/" style="font-size: 15px;">vmware</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/08/08/function-call-stack/">gdb查看寄存器及内存数据与函数调用栈分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/16/libpcap-cutoff-captured-packet/">libpcap在libvirt虚拟化环境下捕获数据包不完整的一种情况分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/27/bash-audit/">一种简单的bash审计方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/20/bash-invocation/">bash 调用方式与配置文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/17/uriparser/">uriparser 解析处理URI</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/06/noblock-rabbitmq-c/">rabbitmq-c 非阻塞订阅</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/20/libyaml/">libyaml 解析配置文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/23/netns/">Linux network namespace 简单解读</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/11/af-packet-bpf/">AF_PACKET & BPF 伪造arp响应</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/04/nonblock-redis/">hiredis & libev 非阻塞模式</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">属乌鸦的.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>