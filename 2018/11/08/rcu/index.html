<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="hu yu's blog | Android | 服务端"><title>Linux RCU 内核同步机制 | 属乌鸦的</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-129648993-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '85d80db9310fa34ab2f7d34beeff589b';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Linux RCU 内核同步机制</h1><a id="logo" href="/.">属乌鸦的</a><p class="description">无知 &amp; 聒噪</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Linux RCU 内核同步机制</h1><div class="post-meta">Nov 8, 2018 11:01 PM</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#RCU-原理"><span class="toc-number">1.</span> <span class="toc-text">RCU 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#插入读取并发"><span class="toc-number">1.1.</span> <span class="toc-text">插入读取并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除读取并发"><span class="toc-number">1.2.</span> <span class="toc-text">删除读取并发</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RCU-API"><span class="toc-number">2.</span> <span class="toc-text">RCU API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RCU-链表"><span class="toc-number">3.</span> <span class="toc-text">RCU 链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#链表删除"><span class="toc-number">3.1.</span> <span class="toc-text">链表删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链表修改"><span class="toc-number">3.2.</span> <span class="toc-text">链表修改</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RCU-实现"><span class="toc-number">4.</span> <span class="toc-text">RCU 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概念"><span class="toc-number">4.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#大体流程"><span class="toc-number">4.2.</span> <span class="toc-text">大体流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据结构"><span class="toc-number">4.3.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#回调链表"><span class="toc-number">4.3.1.</span> <span class="toc-text">回调链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#树形结构"><span class="toc-number">4.3.2.</span> <span class="toc-text">树形结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化"><span class="toc-number">4.4.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数解释"><span class="toc-number">4.5.</span> <span class="toc-text">函数解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注册回调"><span class="toc-number">4.6.</span> <span class="toc-text">注册回调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#检查回调"><span class="toc-number">4.7.</span> <span class="toc-text">检查回调</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#中断部分"><span class="toc-number">4.7.1.</span> <span class="toc-text">中断部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#软中断部分"><span class="toc-number">4.7.2.</span> <span class="toc-text">软中断部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内核线程部分"><span class="toc-number">4.7.3.</span> <span class="toc-text">内核线程部分</span></a></li></ol></li></ol></li></ol></div></div><div class="post-content"><p>RCU(Read, Copy, Update)是一组Linux内核API，实现了一种同步机制，允许多个读者与写者并发操作而不需要任何锁，这种同步机制可以用于保护通过指针进行访问的数据。RCU读者只有很低的额外成本，在典型服务器内核配置下甚至是0成本。如果可能有多个写者，写者之间需要使用其他同步机制。除了使用RCU API直接访问指针数据，更多的使用方式是封装RCU API使其用于链表访问。</p>
<p>RCU适用于读取量很大、而且可以接受读取到旧数据的场景。一个典型场景就是内核路由表，路由表的更新是由外部触发的，外部环境的延迟远比内核更新延迟高，在内核更新路由表前实际已经向旧路径转发了很多数据包，RCU读者按照旧路径再多转发几个数据包是完全可以接受的，而且由于RCU的无锁特性，实际上相比有锁的同步机制，内核可以更早生效新的路由表。路由表这个场景，以系统内部短时间的不一致为代价，降低了系统内部与外部世界的不一致时间，同时降低了读者成本。</p>
<p>Q: <strong>为什么只能保护通过指针访问的数据？</strong><br>A: 任何CPU架构下的Linux都可以保证指针操作的原子性，这是无锁并发的前提。也就是说，假设CPU A在修改指针，无论何时CPU B读取该指针，都可以保证读取到的数据要么是旧的值，要么是新的值，绝不会是混合新旧值不同bit位的无意义值。因此使用RCU对更复杂的数据结构的保护都是基于对指向该数据结构的指针的保护。</p>
<p>Q: <strong>读者0额外成本是怎么做到的？</strong><br>A: 在典型的服务器内核配置(非抢占内核配置并使用gcc编译)时进入临界区函数如下，barrier并不会生成任何汇编代码，只是通知编译器对临界区内外代码不要做乱序并且进入临界区后刷新寄存器(防止cpu乱序的内存屏障操作在其他api中添加)，离开临界区的代码同样最后只有一个barrier，因此可以看作0额外成本。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rcu_read_lock</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __rcu_read_lock();</span><br><span class="line">    __acquire(RCU);</span><br><span class="line">    rcu_lock_acquire(&amp;rcu_lock_map);</span><br><span class="line">    rcu_lockdep_assert(rcu_is_watching(),</span><br><span class="line">            <span class="string">"rcu_read_lock() used illegally while idle"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __rcu_read_lock(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    preempt_disable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> preempt_disable()       barrier()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> barrier() __asm__ __volatile__(<span class="meta-string">""</span>: : :<span class="meta-string">"memory"</span>)</span></span><br></pre></td></tr></table></figure>
<p>Q: <strong>读者额外成本很低，那么写者呢？</strong><br>A：如果有释放旧数据的需要，那么需要等待此前的读者全部完成后才能释放旧数据，这是时间成本。可以通过同步等待的方式，也可以通过注册异步执行函数的方式。</p>
<p>本文内容参考内核版本 3.10.0-862.el7.x86_64</p>
<h2 id="RCU-原理"><a href="#RCU-原理" class="headerlink" title="RCU 原理"></a>RCU 原理</h2><p>RCU是基于保护通过指针访问的数据而达成并发安全的同步机制，这就涉及两个场景，插入和读取并发、删除和读取并发（更新操作可以理解为这两个场景的结合）。</p>
<h3 id="插入读取并发"><a href="#插入读取并发" class="headerlink" title="插入读取并发"></a>插入读取并发</h3><p>设想有一个初始化为NULL的全局变量指针gp被更新为指向一个新分配内存并初始化的数据结构（假设并发写操作已有合适的锁保护）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *<span class="title">gp</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* . . . */</span></span><br><span class="line"></span><br><span class="line">p = kmalloc(<span class="keyword">sizeof</span>(*p), GFP_KERNEL);</span><br><span class="line">p-&gt;a = <span class="number">1</span>;</span><br><span class="line">p-&gt;b = <span class="number">2</span>;</span><br><span class="line">p-&gt;c = <span class="number">3</span>;</span><br><span class="line">gp = p;</span><br></pre></td></tr></table></figure>
<p>然后这段代码并不会阻止编译器和CPU对最后四行代码的执行顺序做保证。如果对gp的赋值操作在数据结构初始化之前被执行，那么读者将会访问到未经正确初始化的数据。因此需要添加内存屏障和编译器指令以保证gp的赋值一定要在数据结构初始化之后，但是内存屏障的正确使用并不容易。<code>rcu_assign_pointer</code>原语通过将内存屏障和编译器指令包装于其中，强制编译器和CPU保证对gp的赋值在对p成员赋值后。</p>
<p>然而只对写操作顺序做保证并不够，同样要注意读者操作的顺序性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = gp;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    do_something_with(p-&gt;a, p-&gt;b, p-&gt;c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段读操作代码看起来是没有问题的，但不幸的是，在Alpha架构CPU以及编译器启用值预测优化时，<code>p-&gt;a</code>、<code>p-&gt;b</code>、<code>p-&gt;b</code>的取值可能会在<code>p</code>前，因此我们需要阻止编译器和CPU进行这种侵略性过高的行为，以使并发读取可以得到正确的结果。<code>rcu_dereference</code>原语同样包装了内存屏障和编译器指令，强制保证读操作的合理顺序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rcu_read_lock();</span><br><span class="line">p = rcu_dereference(gp);</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    do_something_with(p-&gt;a, p-&gt;b, p-&gt;c);</span><br><span class="line">&#125;</span><br><span class="line">rcu_read_unlock();</span><br></pre></td></tr></table></figure>
<p><code>rcu_dereference</code>原语和<code>rcu_assign_pointer</code>原语结合使用，保证了通过指针访问到的数据一定经过了合理的初始化。代码中的<code>rcu_read_lock</code>和<code>rcu_read_unlock</code>原语同样是不可或缺的，它们共同定义了RCU读临界区，具体含义见下节，与其他锁机制不同，这个临界区并不会引起任何等待或调度，也不会阻止写操作的并发执行，在非抢占内核下这两个原语实际上并不生成任何代码。</p>
<h3 id="删除读取并发"><a href="#删除读取并发" class="headerlink" title="删除读取并发"></a>删除读取并发</h3><p>删除操作（包括更新）与插入不同的是，还要面对旧数据结构回收的问题，写者必须要等待可能持有旧数据结构的读者不再读取旧数据结构后才可以执行回收操作，在RCU中这个等待的读者操作区间叫做RCU读者临界区，一个读者调用的<code>rcu_read_lock</code>和<code>rcu_read_unlock</code>原语分别标识了临界区的开始和结束，临界区可以嵌套，可以包含任意多的代码，但是不能够显式的阻塞和睡眠（也就是不能触发调度）。</p>
<p>RCU等待相关的临界区退出，但并不直接判断临界区何时退出，实现细节见下文的<a href="./#RCU-实现">RCU实现</a>。</p>
<p>参考下图，RCU以一种称为宽限期（Grace Period）的方式等待已经存在的临界区运行结束。需要注意的是，grace period开始之后才开始的临界区并不会影响grace period的结束时间。</p>
<p><img src="http://blog-image.hyuuhit.com/2018/10/GracePeriodGood.png" alt="Grace Period"></p>
<p>下面展示一种基础的RCU等待读者操作完成的算法：</p>
<ol>
<li>做修改操作，比如修改全局变量指针的指向。</li>
<li>等待之前所有的RCU临界区执行完成（比如使用<code>synchronize_rcu</code>原语）。</li>
<li>做回收，比如释放全局变量指针之前指向的结构。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *<span class="title">gp</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* . . . . . . . . . . */</span></span><br><span class="line"><span class="comment">/* 这里可能对gp做赋值  */</span></span><br><span class="line"><span class="comment">/* . . . . . . . . . . */</span></span><br><span class="line"></span><br><span class="line">p = rcu_dereference(gp);</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* 做适当操作，比如解锁返回 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">q = kmalloc(<span class="keyword">sizeof</span>(*q), GFP_KERNEL);</span><br><span class="line">*q = *p;</span><br><span class="line">q-&gt;b = <span class="number">2</span>;</span><br><span class="line">q-&gt;c = <span class="number">3</span>;</span><br><span class="line">rcu_assign_pointer(gp, q);</span><br><span class="line">synchronize_rcu();</span><br><span class="line">kfree(p);</span><br></pre></td></tr></table></figure>
<p>上面代码段的21、22、23行实现了前文所说的三个步骤。18-21行展示了RCU（read copy update）的名字含义：在允许读者并发read的同时，18行copy，19-21行update。</p>
<p><code>synchronize_rcu</code>原语暂时还比较难理解，但只要知道它等待所有之前存在的临界区执行完成，之后不会有任何读者能够访问到旧的指针指向的数据，也就可以安全的回收旧数据了。</p>
<p>为了更便于理解，这里有一个trick，Classic RCU临界区中不允许阻塞和睡眠，因为当一个CPU经历一次调度后，我们认为之前的RCU临界区一定运行完成了，这就意味着当所有CPU都至少经历一次调度后，之前所有的RCU临界区都执行完成了，也就意味着<code>synchronize_rcu</code>可以安全的返回了。</p>
<p>因此Classic RCU的<code>synchronize_rcu</code>可以从概念上简单理解为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for_each_online_cpu(cpu)</span><br><span class="line">    run_on(cpu);</span><br></pre></td></tr></table></figure>
<p>这里的<code>run_on</code>切换当前线程到指定的CPU上，也就强制指定CPU做了一次调度。<code>for_each_online_cpu</code>对所有CPU做了轮询，这就保证了所有RCU临界区执行完成。虽然这种方式在不允许RCU临界区抢占的内核下可以工作，但在配置了<code>CONFIG_PREEMPT_RT</code>（一般服务器并不采用该种配置）的内核中使用的realtime RCU使用的是另一种方法来判断临界区的结束。当然，实际上内核RCU的实现远比这个复杂。</p>
<h2 id="RCU-API"><a href="#RCU-API" class="headerlink" title="RCU API"></a>RCU API</h2><p>前面已经看到了一些RCU API，这里简单汇总一些，更多API参考头文件<code>include/linux/rcupdate.h</code>。</p>
<ul>
<li><p>读者临界区<br><code>rcu_read_lock</code><br><code>rcu_read_lock</code></p>
</li>
<li><p>RCU指针取值<br><code>rcu_dereference</code></p>
</li>
<li><p>RCU指针修改<br><code>rcu_assign_pointer</code></p>
</li>
<li><p>同步等待grace period<br><code>synchronize_rcu</code></p>
</li>
<li><p>注册回调函数，异步等待grace period<br><code>call_rcu</code></p>
</li>
<li><p>异步等待grace period后释放内存<br><code>kfree_rcu</code></p>
</li>
</ul>
<p>另外有一组API后缀_bh，不同之处在于将中断下半部的运行结束也看作临界区完成的标识，因此可以猜到对应的临界区原语<code>rcu_read_lock_bh</code>内部封装了关闭中断下半部。</p>
<h2 id="RCU-链表"><a href="#RCU-链表" class="headerlink" title="RCU 链表"></a>RCU 链表</h2><p>实际使用中，RCU更多的用于链表操作，因此有一组包装了RCU的链表API。Linux内核中有两种双向链表，一种是环形链表结构<code>struct list_head</code>，一种是线性链表结构<code>struct hlist_head</code>/<code>struct hlist_node</code>（用于哈希表，节省哈希表表头的内存占用）。为了简单起见，这里的图不展示双向结构，只展示单向next指针。RCU链表操作也只允许读者单向遍历，因此只展示单向链接并不影响理解。</p>
<h3 id="链表删除"><a href="#链表删除" class="headerlink" title="链表删除"></a>链表删除</h3><p>以下代码作为RCU链表删除的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line">LIST_HEAD(head);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* . . . */</span></span><br><span class="line"></span><br><span class="line">p = search(head, key);</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    list_del_rcu(&amp;p-&gt;<span class="built_in">list</span>);</span><br><span class="line">    synchronize_rcu();</span><br><span class="line">    kfree(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设包含指针p的链表初始状态如下：</p>
<p><img src="http://blog-image.hyuuhit.com/2018/10/rcu_list_1.jpg" alt="链表初始状态"></p>
<p>每个元素中的三个成员分别代表a、b、c的值。每个元素的红色边框表示可能有读者持有它们的引用，由于读者并没有与写者直接同步，因此读者可能会与修改操作并发执行。</p>
<p>第13行的<code>list_del_rcu</code>运行结束后，如下图所示，元素<code>5,6,7</code>被从链表中移除。因为读者并没有与写者做直接同步，仍可能有读者正在遍历该链表。这些读者可能看到刚刚移除的元素，也可能看不到，这取决于读者遍历和写者修改的时机。那些看到了旧版本链表的读者可能在元素被从链表移除后仍然访问该元素。这时元素<code>5,6,7</code>的边框仍是红色的，此时在不同的读者看来链表存在两个版本。</p>
<p><img src="http://blog-image.hyuuhit.com/2018/10/rcu_list_2.jpg" alt="链表移除p后"></p>
<p>这里需要注意的是，读者在离开临界区后，绝对不允许再持有链表任何元素的引用（也就是不允许再访问链表的任何元素）。因为一旦14行的<code>synchronize_rcu</code>执行完毕，意味着所有之前的读者都已经离开了临界区，没有任何读者可能持有刚刚移除的元素p，可以看到它由黑框标识，此时所有的读者看到的链表又回归为唯一的版本。</p>
<p><img src="http://blog-image.hyuuhit.com/2018/10/rcu_list_3.jpg" alt="链表经历grace period后"></p>
<p>这时p指向的元素<code>5,6,7</code>可以被安全的释放了。</p>
<p><img src="http://blog-image.hyuuhit.com/2018/10/rcu_list_4.jpg" alt="链表元素p释放后"></p>
<h3 id="链表修改"><a href="#链表修改" class="headerlink" title="链表修改"></a>链表修改</h3><p>以下代码作为RCU链表修改的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">q = kmalloc(<span class="keyword">sizeof</span>(*p), GFP_KERNEL);</span><br><span class="line">*q = *p;</span><br><span class="line">q-&gt;b = <span class="number">2</span>;</span><br><span class="line">q-&gt;c = <span class="number">3</span>;</span><br><span class="line">list_replace_rcu(&amp;p-&gt;<span class="built_in">list</span>, &amp;q-&gt;<span class="built_in">list</span>);</span><br><span class="line">synchronize_rcu();</span><br><span class="line">kfree(p);</span><br></pre></td></tr></table></figure>
<p>假设包含指针p的链表初始状态如下：</p>
<p><img src="http://blog-image.hyuuhit.com/2018/10/rcu_list_1.jpg" alt="链表初始状态"></p>
<p>第一行<code>kmalloc</code>分配了一个待替换的元素。</p>
<p><img src="http://blog-image.hyuuhit.com/2018/10/rcu_list_replace_1.jpg" alt="分配待替换元素"></p>
<p>第二行将旧元素内容复制给新元素。</p>
<p><img src="http://blog-image.hyuuhit.com/2018/10/rcu_list_replace_2.jpg" alt="复制旧元素内容"></p>
<p>第三行将新元素成员b的值更新为2。</p>
<p><img src="http://blog-image.hyuuhit.com/2018/10/rcu_list_replace_3.jpg" alt="更新新元素内容"></p>
<p>第四行将新元素成员c的值更新为3。</p>
<p><img src="http://blog-image.hyuuhit.com/2018/10/rcu_list_replace_4.jpg" alt="更新新元素内容"></p>
<p>到第五行，做了替换操作，这时新的元素可以被读者看到了。如下图所示，此时链表存在两个版本，之前的读者可能看到元素<code>5,6,7</code>，新的读者看到的将是元素<code>5,2,3</code>，但是任何读者看到的都是一个可以顺利遍历的合理的链表。</p>
<p><img src="http://blog-image.hyuuhit.com/2018/10/rcu_list_replace_5.jpg" alt="替换链表元素"></p>
<p>第六行<code>synchronize_rcu</code>执行后，会经历一个grace period，之后所有的在<code>list_replace_rcu</code>之前进入临界区的读者都已经完成读操作离开了临界区，并且不会有新的读者访问到元素<code>5,6,7</code>。这时链表回归到唯一版本。</p>
<p><img src="http://blog-image.hyuuhit.com/2018/10/rcu_list_replace_6.jpg" alt="链表经历grace period后"></p>
<p>第七行<code>kfree</code>执行后，链表如下所示。</p>
<p><img src="http://blog-image.hyuuhit.com/2018/10/rcu_list_replace_7.jpg" alt="链表最终状态"></p>
<p>尽管RCU的命名来源是替换场景，但是Linux内核中大多数RCU操作都是前文所示的<a href="./#链表删除">链表删除</a>。</p>
<h2 id="RCU-实现"><a href="#RCU-实现" class="headerlink" title="RCU 实现"></a>RCU 实现</h2><p>在不同的编译配置下有不同的RCU实现，比如经典RCU、可抢占RCU、可睡眠RCU，这里只记录经典RCU的实现（也是典型服务器配置下使用的RCU）。经典RCU的实现又分为rcu tiny和rcu tree，tiny版只适用于UP单核系统，树形RCU适用于SMP多核系统，这里记录树形RCU实现。</p>
<p>下面可能直接使用简称，rsp（rcu_state pointer），rnp(rcu_node pointer)，（rcu_data pointer）。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>quiescent states(qs)<br>静止状态。可以确定不在读者临界区内。</li>
<li>extended quiescent state(eqs)<br>扩展的静止状态。当系统停止当前CPU的本地定时器中断，进入动态时钟模式（nohz）时，此时由于没有了时钟中断会导致无法判定静止状态，因此在rdp上有成员dynticks和dynticks_snap配合记录是否处于eqs状态和是否经历过eqs状态。系统的动态时钟由编译配置CONFIG_NO_HZ设定开启与否，默认为y，<br>具体有以下几种模式：<ul>
<li>CONFIG_HZ_PERIODIC<br>传统的周期性时钟中断。</li>
<li>CONFIG_NO_HZ_IDLE<br>只对idle的CPU进入动态时钟模式。</li>
<li>CONFIG_NO_HZ_FULL<br>在CONFIG_NO_HZ_IDLE更进一步，对于只有一个task的CPU，也会进入动态时钟模式。典型配置使用该模式。</li>
<li>CONFIG_NO_HZ_FULL_ALL<br>对所有CPU启用CONFIG_NO_HZ_FULL。典型配置未开启该选项。</li>
</ul>
</li>
<li>rcu boost<br>配置开关<code>CONFIG_RCU_BOOST</code>，与可抢占RCU配合使用，用于避免低优先级进程长期无法退出临界区而造成内存耗尽。典型配置下为关闭状态。</li>
<li>nocb<br>no callback，callback offload，用于指定CPU不在软中断中执行callback，而是在rcuo内核线程上执行callback。配置开关为CONFIG_RCU_NOCB_CPU，典型配置值为y。对nocb CPU的指定有以下配置。<ul>
<li>CONFIG_RCU_NOCB_CPU_NONE<br>没有CPU被指定offload，典型配置使用该值。</li>
<li>CONFIG_RCU_NOCB_CPU_ZERO<br>0号CPU指定offload</li>
<li>CONFIG_RCU_NOCB_CPU_ALL<br>所有CPU指定offload</li>
</ul>
</li>
</ul>
<h3 id="大体流程"><a href="#大体流程" class="headerlink" title="大体流程"></a>大体流程</h3><p>这里先描述一下一个RCU的大体工作流程，有一个直观认识。</p>
<ol>
<li><code>call_rcu</code>将<code>rcu_head</code>挂载到当前CPU的rdp成员nxtlist末尾。</li>
<li>CPU的本地定时器中断isp中通过<code>rcu_pending</code>判定需要软中断工作，激活软中断。</li>
<li>软中断通过<code>cpu_needs_another_gp</code>判定需要开始一个新的gp，调用<code>rcu_start_gp</code>将<code>rsp-&gt;gp_flags</code>标记为<code>RCU_GP_FLAG_INIT</code>。</li>
<li>RCU内核线程观察到<code>RCU_GP_FLAG_INIT</code>，调用<code>rcu_gp_init</code>，为<code>rsp-&gt;gpnum</code>设定新的gp序号，然后遍历所有rnp重置qsmask并更新gpnum。（顺便会将当前CPU的rdp状态也更新一下，包括gp序号和重置qs）</li>
<li>每个其他CPU在本地定时器中断isp中经过<code>rcu_pending</code>发现rdp的gpnum不等于rnp的gpnum，有新gp需要处理，因此激活软中断。</li>
<li>每个其他CPU在软中断中将gpnum从rnp向下传递到rdp，并重置qs相关状态（这个与4中最后的额外工作一起将所有CPU的rdp更新到新gp状态）。</li>
<li>每个CPU在本地定时器中断isp中判定是否符合qs条件，如果符合则更新rdp中passed_quiesce为1，表示经历过qs。经过<code>rcu_pending</code>判定需要软中断工作，激活软中断。</li>
<li>每个CPU在软中断中将qs完成状态逐级向上汇报更新rnp的qsmask。</li>
<li>最后一个更新会将根节点rnp的qsmask置为0，这时唤醒RCU内核线程。</li>
<li>RCU内核线程发现根节点rnp的qsmask已经为0，调用<code>rcu_gp_cleanup</code>，遍历更新所有rnp的comleted为rsp的gpnum，并更新rsp的completed。（顺便推进当前CPU的rdp的callback链表，将完成的callback置于合适的子链表中）</li>
<li>每个CPU在本地定时器中断中经过<code>rcu_pending</code>发现rdp的completed不等于rnp的completed，有已经完成的gp需要处理，因此激活软中断。</li>
<li>每个CPU在软中断中通过<code>rcu_process_gp_end</code>将completed从rnp向下传递到rdp，并将已经完成gp的callback放入nxtlist合适子链表中。最后通过<code>rcu_do_batch</code>完成callback的回调执行。</li>
</ol>
<p>每次只有一个gp在运行中，运行的gp序号gpnum从rsp向下传递到rnp和rdp，qs状态从rdp向上汇报到rnp和rsp，完成的gp序号completed从rsp向下传递到rnp和rdp，最后再执行回调callback。</p>
<ul>
<li><code>call_rcu</code>主要就是将<code>rcu_head</code>挂载到合适的rdp就可以了。只有当堆积过多时才会采取一些可以推动gp的操作。</li>
<li>CPU本地定时器中断主要就是判定当前是否处于qs（如果处于qs则设定passed_quiesce），然后根据<code>rcu_pending</code>决定是否激活软中断。</li>
<li>软中断中完成的操作多一些，包括：<ul>
<li>推进callback多个子链表。</li>
<li>将completed从rnp向下传递到rdp。</li>
<li>将gpnum从rnp向下传递到rdp。</li>
<li>向上汇报qs。</li>
<li>合适的情况下设定<code>RCU_GP_FLAG_INIT</code>。</li>
<li>执行完成gp的callback。</li>
</ul>
</li>
<li>内核线程部分大体上就是一个无限循环：<ol>
<li>等待<code>RCU_GP_FLAG_INIT</code>，rsp开始一个新gp，将新gpnum向下传递给rnp。</li>
<li>等待根节点rnp的qsmask为0（既为所有参与CPU都经历过qs）。</li>
<li>更新completed为刚刚的gpnum，然后将completed向下传递给rnp。</li>
<li>合适的情况下设定<code>RCU_GP_FLAG_INIT</code>。</li>
</ol>
</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="回调链表"><a href="#回调链表" class="headerlink" title="回调链表"></a>回调链表</h4><p><code>rcu_head</code>的结构比较简单，只有一个回调函数的指针和一个单向链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct callback_head - callback structure for use with RCU and task_work</span></span><br><span class="line"><span class="comment"> * @next: next update requests in a list</span></span><br><span class="line"><span class="comment"> * @func: actual update function to call after the grace period.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> (*func)(struct callback_head *head);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rcu_head callback_head</span></span><br></pre></td></tr></table></figure>
<p><code>rcu_head</code>会挂在到rcu_data成员nxtlist上，这个链表被分割为4个部分，这4个部分由nxttail这个数组的4个成员来分割如下：</p>
<ul>
<li><code>[nxtlist, *nxttail[RCU_DONE_TAIL])</code><br>已经完成后gp的callback，它们的gp序号 &lt;= completed</li>
<li><code>[*nxttail[RCU_DONE_TAIL], *nxttail[RCU_WAIT_TAIL])</code><br>等待当前gp的callback，它们的gp序号 &lt;= completed - 1</li>
<li><code>[*nxttail[RCU_WAIT_TAIL], *nxttail[RCU_NEXT_READY_TAIL])</code><br>在当前gp结束前到来的callback</li>
<li><code>[*nxttail[RCU_NEXT_READY_TAIL], *nxttail[RCU_NEXT_TAIL])</code><br>可能是当前gp结束后到来的callback</li>
</ul>
<p>这里<code>*nxttail[RCU_NEXT_TAIL]</code>永远都是NULL，因为这是链表末尾。</p>
<h4 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h4><p><img src="http://blog-image.hyuuhit.com/2018/10/rcu_struct.jpg" alt="RCU树形结构"></p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>RCU所需要的初始化操作在多个位置：</p>
<ul>
<li><code>rcu_init</code>初始化了RCU所需要的全局数据结构（也是树形几何结构），位于<code>start_kernel</code> -&gt; <code>rcu_init</code>。</li>
<li><code>rcu_init_nohz</code>初始化nocb的简单标识，位于<code>start_kernel</code> -&gt; <code>rcu_init_nohz</code>，在<code>rcu_init</code>后。</li>
<li><code>rcu_spawn_gp_kthread</code>为每个rsp创建了内核线程处理grace period的开始和结束，也创建了负责boost和nocb的线程（这部分与<code>rcu_init</code>有重复）。</li>
</ul>
<figure class="highlight plain"><figcaption><span>rcu_init</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">+--------+</span><br><span class="line">|rcu_init|</span><br><span class="line">+---+----+</span><br><span class="line">    |</span><br><span class="line">    |   +-------------------+</span><br><span class="line">    +---+rcu_bootup_announce|</span><br><span class="line">    |   |打印RCU相关启动信息|</span><br><span class="line">    |   +-------------------+</span><br><span class="line">    |</span><br><span class="line">    |   +------------------------------------------------------------------------------------------+</span><br><span class="line">    |   |rcu_init_geometry                                                                         |</span><br><span class="line">    |   |                                                                                          |</span><br><span class="line">    |   |根据实际运行时cpu核数（nr_cpu_ids）初始化树形RCU的几何结构，                              |</span><br><span class="line">    |   |具体就是：树的每层有多少节点（num_rcu_lvl[]数组。最后一层是rcu_data），                                   |</span><br><span class="line">    |   |          树有多少非叶子节点，也就是rcu_node数量（rcu_num_nodes）。                       |</span><br><span class="line">    +---+          树非叶子节点的层数，也就是rcu_node层数（rcu_num_lvls），                                          |</span><br><span class="line">    |   |以典型编译配置的12核cpu为例，                                                             |</span><br><span class="line">    |   |  num_rcu_lvl[0]=1，num_rcu_lvl[1]=12，rcu_num_nodes=1，rcu_num_lvls=1。                  |</span><br><span class="line">    |   |以典型编译配置的48核cpu为例，                                                             |</span><br><span class="line">    |   |  num_rcu_lvl[0]=1，num_rcu_lvl[1]=3，num_rcu_lvl[2]=48，rcu_num_nodes=4，rcu_num_lvls=2。|</span><br><span class="line">    |   |另外设置了jiffies_till_first_fqs，jiffies_till_next_fqs这两个值。                         |</span><br><span class="line">    |   +------------------------------------------------------------------------------------------+</span><br><span class="line">    |</span><br><span class="line">    |   +-----------------------------------------------------------------------------+</span><br><span class="line">    |   |调用rcu_init_one初始化以下两个rsp。                                          |</span><br><span class="line">    |   |初始化rcu_sched_state，用于经典RCU                                           |</span><br><span class="line">    +---|初始化rcu_bh_state，用于经典RCU后缀_bh那组api                                |</span><br><span class="line">    |   |初始化过程包括rsp、rnp（中间节点）和rdp（cpu叶子节点）的初始化               |</span><br><span class="line">    |   |对rdp的初始化由函数rcu_boot_init_percpu_data完成。                           |</span><br><span class="line">    |   |rdp中nocb相关成员nocb_tail和nocb_wq由函数rcu_boot_init_nocb_percpu_data完成。|</span><br><span class="line">    |   +-----------------------------------------------------------------------------+</span><br><span class="line">    |</span><br><span class="line">    |   +--------------------------------------------------+</span><br><span class="line">    +---+__rcu_init_preempt                                |</span><br><span class="line">    |   |如果开启了可抢占式RCU，内部封装rcu_init_on，否则空|</span><br><span class="line">    |   |只对可抢占RCU有意义，只是初始化了rcu_preempt_state|</span><br><span class="line">    |   +--------------------------------------------------+</span><br><span class="line">    |</span><br><span class="line">    |   +--------------------------------+</span><br><span class="line">    +---+      注册RCU_SOFTIRQ软中断     |</span><br><span class="line">    |   |处理函数为 rcu_process_callbacks|</span><br><span class="line">    |   +--------------------------------+</span><br><span class="line">    |</span><br><span class="line">    |   +---------------------------------------------------------------------------------------+</span><br><span class="line">    |   |注册CPU热拔插事件处理函数并对每个CPU做上线操作，上线操作会调用三个函数                 |</span><br><span class="line">    |   |  rcu_prepare_cpu                                                                      |</span><br><span class="line">    |   |    对该CPU在每个rsp上调用rcu_init_percpu_data，                                       |</span><br><span class="line">    |   |    这个操作会将该cpu对应的rdp的grpmask向上汇总到父节点的qsmaskinit，逐层进行。        |</span><br><span class="line">    +---|  rcu_prepare_kthreads                                                                 |</span><br><span class="line">    |   |    调用rcu_spawn_one_boost_kthread，                                                  |</span><br><span class="line">    |   |    这个操作给rdp的父节点rnp创建一个RCU-boost内核线程，用于可抢占RCU，这里不关注。     |</span><br><span class="line">    |   |  rcu_spawn_all_nocb_kthreads                                                          |</span><br><span class="line">    |   |    对该CPU在每个rsp上调用rcu_spawn_one_nocb_kthread，                                 |</span><br><span class="line">    |   |    这个操作给nocb的CPU每一个rsp创建一个rcuo内核线程（使用函数rcu_is_nocb_cpu）判断。  |</span><br><span class="line">    |   |    内核线程执行函数为rcu_nocb_kthread，线程task_struct结构指针赋值给nocb_kthread成员。|</span><br><span class="line">    |   +---------------------------------------------------------------------------------------+</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line">   返回</span><br></pre></td></tr></table></figure>
<p><code>rcu_init_nohz</code>的逻辑比较简单，根据编译配置和启动配置将需要做nocb的 CPU号写入位图<code>rcu_nocb_mask</code>中，然后对每一个nocb CPU调用<code>init_nocb_callback_list</code>（其实就是设置<code>rdp-&gt;nxttail[RCU_NEXT_TAIL] = NULL</code>，这个值就是检查rdp是否启用nocb的标识）。</p>
<p>内核线程初始化代码如下（暂时不深究<code>early_initcall</code>如何生效）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Spawn the kthreads that handle each RCU flavor's grace periods.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">rcu_spawn_gp_kthread</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_node</span> *<span class="title">rnp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_state</span> *<span class="title">rsp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这个标记开启后，RCU相关线程创建才能开始，rcu_init中部分代码也会检查该标记 */</span></span><br><span class="line">    rcu_scheduler_fully_active = <span class="number">1</span>;</span><br><span class="line">    for_each_rcu_flavor(rsp) &#123;</span><br><span class="line">        <span class="comment">/* 每个rsp都开启一个线程，专门处理grace period开始和结束 */</span></span><br><span class="line">        t = kthread_run(rcu_gp_kthread, rsp, rsp-&gt;name);</span><br><span class="line">        BUG_ON(IS_ERR(t));</span><br><span class="line">        rnp = rcu_get_root(rsp);</span><br><span class="line">        raw_spin_lock_irqsave(&amp;rnp-&gt;lock, flags);</span><br><span class="line">        rsp-&gt;gp_kthread = t;</span><br><span class="line">        raw_spin_unlock_irqrestore(&amp;rnp-&gt;lock, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 这里就是对每个CPU调用rcu_spawn_all_nocb_kthreads，与rcu_init中操作重复 */</span></span><br><span class="line">    rcu_spawn_nocb_kthreads();</span><br><span class="line">    <span class="comment">/* 这里最终也会落到嗲用函数rcu_spawn_one_boost_kthread，与rcu_init中操作重复 */</span></span><br><span class="line">    rcu_spawn_boost_kthreads();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">early_initcall(rcu_spawn_gp_kthread);</span><br></pre></td></tr></table></figure>
<p>内核线程可以参考<a href="/2018/08/03/linux-kernel-thread/">Linux kernel thread 内核线程</a>。</p>
<h3 id="函数解释"><a href="#函数解释" class="headerlink" title="函数解释"></a>函数解释</h3><ul>
<li><p><code>rcu_cbs_completed</code><br>用来预估当下一个gp结束后，rnp的completed序号会变成多少。估计逻辑如下：</p>
<ol>
<li>如果是rnp是根节点，并且gpnum等于completed（也就是当前gp已经结束了），那么返回completed + 1（因为下个gp结束completed将顺序递增1）。</li>
<li>如果上一条没满足，则返回completed + 2（这个预估是比较宽松的，实际可能只需要增1，但是在不向上检查时无法确定）。</li>
</ol>
</li>
<li><p><code>rcu_start_future_gp</code><br>这个函数运行的前提是一定有未完成的gp。用于标记rnp成员need_future_gp，记录未来需要开始的gp序号，并在可能的情况下标记开启新的gp。逻辑如下：</p>
<ol>
<li>调用<code>rcu_cbs_completed</code>取得预估的序号c。</li>
<li>如果c在need_future_gp已经有标记，则返回c。</li>
<li>如果当前rnp的gpnum不等于completed，或者不等于rsp的completed。说明当前有gp在运行中。将c标记在need_future_gp中，返回c。</li>
<li>重新从根节点取<code>rcu_cbs_completed</code>返回值c。</li>
<li>如果c小于nxtcompleted数组中成员值，则修改为c（因为根节点的c小于等于中间节点的）。</li>
<li>如果c在need_future_gp已经有标记，则返回c。</li>
<li>将c标记在need_future_gp中。</li>
<li>调用<code>rcu_start_gp_advanced</code>设置开启新gp（运行到这里，说明有未完成的callback，并且有新标记需要完成的gp号。但是还是很绕啊，没懂……）。</li>
</ol>
</li>
<li><p><code>rcu_start_gp_advanced</code><br>这个函数用于标记需要开始新的gp，逻辑比较简单：</p>
<ol>
<li>如果RCU内核线程没启动或者<code>cpu_needs_another_gp</code>返回假，则直接返回。</li>
<li><code>rsp-&gt;gp_flags</code>赋值为<code>RCU_GP_FLAG_INIT</code>，这个值用于告诉内核线程需要开始新的gp序号。</li>
<li><code>irq_work_queue(&amp;rsp-&gt;wakeup_work);</code>唤醒内核线程，具体唤醒流程先不关注了，之前由<code>init_irq_work(&amp;rsp-&gt;wakeup_work, rsp_wakeup);</code>初始化过。</li>
</ol>
</li>
<li><p><code>cpu_needs_another_gp</code><br>这个函数的使用场景是，进行判定是否需要开始新的gp。如果返回真，那么接下来就会将<code>rsp-&gt;gp_flags</code>赋值为<code>RCU_GP_FLAG_INIT</code>，用以告诉内核线程开始一个新的gp。具体判定顺序逻辑为：</p>
<ol>
<li>如果当前gp未结束，返回假。</li>
<li>如果rcu_nocb_needs_gp返回真（依靠rsp中根节点rnp的need_future_gp中completed + 1在里面是否为真来判断，只是建议。这就可以判定存在nocb的callback吗？），返回真。</li>
<li>如果这是一个nocb CPU（通过RCU_NEXT_TAIL判定），返回假。</li>
<li>如果有刚刚注册的callback（通过RCU_NEXT_READY_TAIL判定），返回真。</li>
<li>如果nxtlist的中间两段有callback，并且预分配的nxtcompleted大于已经完成的completed，返回真。</li>
<li>如果以上都不满足，返回假。</li>
</ol>
</li>
<li><p><code>rcu_accelerate_cbs</code><br>用于在可能的情况下将callback链表nxtlist的子段尽量向前合并（通过<code>rcu_cbs_completed</code>取值并比较），并更新nxtcompleted数组。如果有合并和更新，还会调用<code>rcu_start_future_gp</code>。感觉是一个可有可无的函数，幂等。</p>
</li>
<li><p><code>rcu_advance_cbs</code><br>用于将rdp成员nxtlist中RCU_DONE_TAIL标记移动到已经完成gp的子链表后（也就是将子链表与前面的callback连接到一起。注意这里是通过rdp的nxtcompleted与rnp的completed比较来判断是否完成，因为completed是从上向下推进的）。然后是一些子链表的清理工作，不细分析了。最后调用<code>rcu_accelerate_cbs</code>将子链表尽量推进。</p>
</li>
<li><p><code>__rcu_process_gp_end</code><br>这个函数用来处理rdp上已经完成gp的callback：</p>
<ol>
<li>首先判断rdp的completed是否等于rnp的completed（completed是从上向下推进的）。</li>
<li>如果相等，说明没有callback需要放到RCU_DONE_TAIL前。调用<code>rcu_accelerate_cbs</code>加速处理进度。</li>
<li>如果不等，调用<code>rcu_advance_cbs</code>推进callback已完成的子链表。</li>
<li>然后修改rdp的completed为rnp的completed（终于将completed推进到rdp了）。</li>
<li>如果rdp的gpnum小于completed，修改gpnum为completed，修改passed_quiesce为0。（这里是为了eqs情况下可能丢失的gp）</li>
<li>如果rdp的grpmask在rnp的qsmask中不存在，设置rdp的qs_pending为0。</li>
</ol>
</li>
<li><p><code>rcu_process_gp_end</code><br>这个函数只是在调用<code>__rcu_process_gp_end</code>前检查了rdp和rnp的completed是否相等，如果相等或是为rnp上锁失败则直接返回。</p>
</li>
<li><p><code>rcu_start_gp</code><br>这个函数用于开始新的gp，与<code>rcu_start_gp_advanced</code>不同之处在于前面多执行一个<code>rcu_advance_cbs</code>。这么处理的原因可能是为了避免无限的递归，这部分逻辑太坑了。</p>
</li>
<li><p><code>check_for_new_grace_period</code>包装了<code>note_new_gpnum</code>，<code>note_new_gpnum</code>包装了<code>__note_new_gpnum</code><br>主要目的是将gpnum从rnp向下传递到rdp。如果更新了rdp的gpnum，还要设置rdp的passed_quiesce为0，rdp的qs_pending值取决于rnp的qsmask中是否有rdp的grpmask相应bit位。</p>
</li>
<li><p><code>force_quiescent_state</code><br>当gp超时或callback堆积过多时，调用此函数为<code>rsp-&gt;gp_flags</code>增加标识<code>RCU_GP_FLAG_FQS</code>。这样RCU内核线程就会看到该标记并调用<code>rcu_gp_fqs</code>。</p>
</li>
<li><p><code>dyntick_save_progress_counter</code><br>用于判断指定CPU是否处于eqs状态。判断方式很简单，就是读取rdp-&gt;dynticks-&gt;dynticks，如果是偶数说明当前处于eqs状态。同时记录<code>rdp-&gt;dynticks_snap</code>用于后续<code>rcu_implicit_dynticks_qs</code>的判断。当gp超时或rsp被标记<code>RCU_GP_FLAG_FQS</code>时在<code>rcu_gp_fqs</code>中被调用。</p>
</li>
<li><p><code>rcu_implicit_dynticks_qs</code><br>用于判断指定CPU是否经历过qs状态，与<code>force_quiescent_state</code>配合在<code>rcu_gp_fqs</code>中被调用。一个gp中，首次进入<code>rcu_gp_fqs</code>会调用<code>dyntick_save_progress_counter</code>进行判断，后续进入将会调用<code>rcu_implicit_dynticks_qs</code>。此函数逻辑如下：</p>
<ol>
<li>如果当前CPU处于动态时钟的idle状态，或者<code>rdp-&gt;dynticks-&gt;dynticks</code>相比<code>dyntick_save_progress_counter</code>记录的<code>rdp-&gt;dynticks_snap</code>差值大于等于2（说明至少经历了一次动态时钟的idle状态）。返回真。</li>
<li>如果gp经历时间不足两个tick，返回假。</li>
<li>如果CPU处于offline状态，返回真。</li>
<li>如果运行到了这里，有可能CPU处于动态时钟状态，这时没有时钟中断，因此调用<code>rcu_kick_nohz_cpu</code>开启CPU的时钟中断。</li>
<li>CPU还有可能在内核态运行了很长时间而没有经历qs，因此调用<code>resched_cpu</code>让CPU执行调度。</li>
</ol>
</li>
<li><p><code>force_qs_rnp</code><br>扫描rsp的所有叶子rnp，对于qsmask中存在的CPU位调用一个函数指针来判断该CPU是否处于eqs或经历过eqs，如果处于eqs或经历过eqs则认为该CPU一定离开了读者临界区，对应的掩码位可以清除了，可以调用<code>rcu_report_qs_rnp</code>将rnp的qsmask更新并向上汇报。此函数唯一的调用位置是<code>rcu_gp_fqs</code>中。传入的函数指针就是<code>dyntick_save_progress_counter</code>或<code>rcu_implicit_dynticks_qs</code>。</p>
</li>
<li><p><code>rcu_gp_fqs</code><br>RCU内核线程在等待gp结束时，如果遇到超时或<code>RCU_GP_FLAG_FQS</code>被设置，会调用此函数强制检查qs（也就是检查eqs并激活CPU的时钟中断或强制调度）。</p>
</li>
<li><p><code>__rcu_pending</code><br>这个函数对指定的rsp指定的rdp进行检查，查看是否有需要完成的RCU工作，如果有返回真。判断逻辑如下：</p>
<ol>
<li>如果rds成员qs_pending为1，同时passed_quiesce也为1，这说明需要上报qs事件。返回1。</li>
<li>如果<code>cpu_has_callbacks_ready_to_invoke</code>返回1（实际就是rdp回调列表nxtlist在RCU_DONE_TAIL前存在元素），说明有回调可以被执行了。返回1。</li>
<li>如果<code>cpu_needs_another_gp</code>返回1。</li>
<li>如果rnp的completed不等于rdp的completed，说明有gp已经完成了，而且当前rdp还没有感知，因为completed是从上到下传递的，这时需要软中断将gp的完成事件传递到rdp上并进行相应处理。</li>
<li>如果rnp的gpnum不等于rdp的gpnum，说明有新的gp开始了，而且当前rdp还没有感知，因为gpnum也是从上到下传递的，需要软中断中进行处理。</li>
<li>如果上面都不满足，说明没有事情可以做，返回0。</li>
</ol>
</li>
<li><p><code>rcu_pending</code><br>这个函数只是对<code>__rcu_pending</code>的包装，里面遍历了所有类型的rsp，有一个返回真函数既返回真。</p>
</li>
<li><p><code>rcu_report_qs_rdp</code><br>这个函数的主要功能是检查当前rdp等待的gp是否与rnp等待的gp号一致，如果一致则会将rdp的grpmask通过函数<code>rcu_report_qs_rnp</code>向上汇报给rnp，用于通知rnp该CPU已经经历过qs了。这个函数的唯一调用点是软中断处理函数中的<code>rcu_check_quiescent_state</code>。</p>
</li>
<li><p><code>rcu_report_qs_rnp</code><br>通过传入参数代表的的可以清除的掩码位，清除rnp对应的掩码位，并逐级向上汇总，如果最后根节点rnp的qsmask为0了则调用<code>rcu_report_qs_rsp</code>。该函数有两个调用位置，一个是<code>rcu_report_qs_rdp</code>末尾，一个是<code>force_qs_rnp</code>做强制qs检查时。</p>
</li>
<li><p><code>rcu_report_qs_rsp</code><br>这个函数就是唤醒RCU内核线程来处理gp结束工作。唯一调用点是<code>rcu_report_qs_rnp</code>中。</p>
</li>
<li><p><code>rcu_check_quiescent_state</code><br>尝试将新的gp更新到rdp上，如果没有新gp则尝试将rdp的qs更新逐级向上更新到rnp和rsp上。如果最后根节点rnp的qsmask为0了，则唤醒rsp对应的内核线程做gp结束的工作。</p>
</li>
</ul>
<h3 id="注册回调"><a href="#注册回调" class="headerlink" title="注册回调"></a>注册回调</h3><p>以<code>call_rcu</code>为例，实现为<code>__call_rcu</code>，逻辑主要为将指定回调函数填充到rcu_head中，挂载到rdp的nxtlist末尾。</p>
<figure class="highlight c"><figcaption><span>call_rcu</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* In classic RCU, call_rcu() is just call_rcu_sched(). */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> call_rcu    call_rcu_sched</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* . . . */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Queue an RCU-sched callback for invocation after a grace period.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">void call_rcu_sched(struct rcu_head *head, void (*func)(struct rcu_head *rcu))</span><br><span class="line">&#123;</span><br><span class="line">    __call_rcu(head, func, &amp;rcu_sched_state, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(call_rcu_sched);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>__call_rcu</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Helper function for call_rcu() and friends.  The cpu argument will</span></span><br><span class="line"><span class="comment"> * normally be -1, indicating "currently running CPU".  It may specify</span></span><br><span class="line"><span class="comment"> * a CPU only if that CPU is a no-CBs CPU.  Currently, only _rcu_barrier()</span></span><br><span class="line"><span class="comment"> * is expected to specify a CPU.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">__call_rcu(struct rcu_head *head, <span class="keyword">void</span> (*func)(struct rcu_head *rcu),</span><br><span class="line">        struct rcu_state *rsp, <span class="keyword">int</span> cpu, <span class="keyword">bool</span> lazy)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_data</span> *<span class="title">rdp</span>;</span></span><br><span class="line"></span><br><span class="line">    WARN_ON_ONCE((<span class="keyword">unsigned</span> <span class="keyword">long</span>)head &amp; <span class="number">0x3</span>); <span class="comment">/* Misaligned rcu_head! */</span></span><br><span class="line">    debug_rcu_head_queue(head);</span><br><span class="line">    head-&gt;func = func;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Opportunistically note grace-period endings and beginnings.</span></span><br><span class="line"><span class="comment">     * Note that we might see a beginning right after we see an</span></span><br><span class="line"><span class="comment">     * end, but never vice versa, since this CPU has to pass through</span></span><br><span class="line"><span class="comment">     * a quiescent state betweentimes.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 有机会遇到grace period的结束和开始。</span></span><br><span class="line"><span class="comment">     * 可能在看到grace period结束后紧接着看到开始，</span></span><br><span class="line"><span class="comment">     * 但不可能在grace period开始后紧接着看到结束，</span></span><br><span class="line"><span class="comment">     * 因为当前CPU需要时间经历静止状态(quiescent state)(中断关闭状态下不可能经历静止状态)。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 关中断，需要操作per cpu变量 */</span></span><br><span class="line">    local_irq_save(flags);</span><br><span class="line">    <span class="comment">/* 取出当前CPU的rdp */</span></span><br><span class="line">    rdp = this_cpu_ptr(rsp-&gt;rda);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Add the callback to our list. */</span></span><br><span class="line">    <span class="comment">/* 如果当前CPU设定了nocb */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(rdp-&gt;nxttail[RCU_NEXT_TAIL] == <span class="literal">NULL</span>) || cpu != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> offline;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cpu != <span class="number">-1</span>)</span><br><span class="line">            rdp = per_cpu_ptr(rsp-&gt;rda, cpu);</span><br><span class="line">        offline = !__call_rcu_nocb(rdp, head, lazy);</span><br><span class="line">        WARN_ON_ONCE(offline);</span><br><span class="line">        <span class="comment">/* _call_rcu() is illegal on offline CPU; leak the callback. */</span></span><br><span class="line">        local_irq_restore(flags);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 记录rds的nxtlist长度 */</span></span><br><span class="line">    ACCESS_ONCE(rdp-&gt;qlen)++;</span><br><span class="line">    <span class="keyword">if</span> (lazy)</span><br><span class="line">        rdp-&gt;qlen_lazy++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        rcu_idle_count_callbacks_posted();</span><br><span class="line">    smp_mb();  <span class="comment">/* Count before adding callback for rcu_barrier(). */</span></span><br><span class="line">    <span class="comment">/* 在rdp成员nxtlist末尾挂载上当前回调函数，并更新末尾的next成员地址 */</span></span><br><span class="line">    *rdp-&gt;nxttail[RCU_NEXT_TAIL] = head;</span><br><span class="line">    rdp-&gt;nxttail[RCU_NEXT_TAIL] = &amp;head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 使用一个trick判断挂载的是不是kfree_rcu */</span></span><br><span class="line">    <span class="keyword">if</span> (__is_kfree_rcu_offset((<span class="keyword">unsigned</span> <span class="keyword">long</span>)func))</span><br><span class="line">        trace_rcu_kfree_callback(rsp-&gt;name, head, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)func,</span><br><span class="line">                rdp-&gt;qlen_lazy, rdp-&gt;qlen);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        trace_rcu_callback(rsp-&gt;name, head, rdp-&gt;qlen_lazy, rdp-&gt;qlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Go handle any RCU core processing required. */</span></span><br><span class="line">    __call_rcu_core(rsp, rdp, head, flags);</span><br><span class="line">    <span class="comment">/* 恢复中断 */</span></span><br><span class="line">    local_irq_restore(flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>__call_rcu_core</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invoke_rcu_core</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cpu_online(smp_processor_id()))</span><br><span class="line">        raise_softirq(RCU_SOFTIRQ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Handle any core-RCU processing required by a call_rcu() invocation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __call_rcu_core(struct rcu_state *rsp, struct rcu_data *rdp,</span><br><span class="line">        struct rcu_head *head, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If called from an extended quiescent state, invoke the RCU</span></span><br><span class="line"><span class="comment">     * core in order to force a re-evaluation of RCU's idleness.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 如果当前处于eqs，但是又注册了callback，</span></span><br><span class="line"><span class="comment">     * 由于没有了时钟中断判定qs，这时需要主动启用软中断来判定qs和gp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!rcu_is_watching() &amp;&amp; cpu_online(smp_processor_id()))</span><br><span class="line">        invoke_rcu_core();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If interrupts were disabled or CPU offline, don't invoke RCU core. */</span></span><br><span class="line">    <span class="comment">/* 如果在call_rcu之前中断是关闭的，则不做后续操作。不懂这是为什么TODO */</span></span><br><span class="line">    <span class="keyword">if</span> (irqs_disabled_flags(flags) || cpu_is_offline(smp_processor_id()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Force the grace period if too many callbacks or too long waiting.</span></span><br><span class="line"><span class="comment">     * Enforce hysteresis, and don't invoke force_quiescent_state()</span></span><br><span class="line"><span class="comment">     * if some other CPU has recently done so.  Also, don't bother</span></span><br><span class="line"><span class="comment">     * invoking force_quiescent_state() if the newly enqueued callback</span></span><br><span class="line"><span class="comment">     * is the only one waiting for a grace period to complete.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 如果当前堆积了过多的callback，检查当前状况。非普遍路径 */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(rdp-&gt;qlen &gt; rdp-&gt;qlen_last_fqs_check + qhimark)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Are we ignoring a completed grace period? */</span></span><br><span class="line">        <span class="comment">/* 检查是否之前错过了已经结束的gp */</span></span><br><span class="line">        rcu_process_gp_end(rsp, rdp);</span><br><span class="line">        <span class="comment">/* 检查是否有新的gp开始，通过比较gpnum序号。</span></span><br><span class="line"><span class="comment">         * 如果有则更新当前rdp的gpnum、psaaed_quiesce(置0)、qs_pending(置1) */</span></span><br><span class="line">        check_for_new_grace_period(rsp, rdp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Start a new grace period if one not already started. */</span></span><br><span class="line">        <span class="keyword">if</span> (!rcu_gp_in_progress(rsp)) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">rcu_node</span> *<span class="title">rnp_root</span> = <span class="title">rcu_get_root</span>(<span class="title">rsp</span>);</span></span><br><span class="line"></span><br><span class="line">            raw_spin_lock(&amp;rnp_root-&gt;lock);</span><br><span class="line">            <span class="comment">/* 如果当前没有运行的gp，又因为刚插入了callback，那么开始一个新的gp */</span></span><br><span class="line">            rcu_start_gp(rsp);</span><br><span class="line">            raw_spin_unlock(&amp;rnp_root-&gt;lock);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Give the grace period a kick. */</span></span><br><span class="line">            rdp-&gt;blimit = LONG_MAX;</span><br><span class="line">            <span class="comment">/* n_force_qs在函数rcu_gp_fqs中自增，因此这里判断如果没有经历rcu_gp_fqs，</span></span><br><span class="line"><span class="comment">             * 并且之前已经存在未完成gp的callback，那么调用force_quiescent_state</span></span><br><span class="line"><span class="comment">             * 尝试为rsp增加标记RCU_GP_FLAG_FQS，这会使RCU内核线程调用rcu_gp_fqs</span></span><br><span class="line"><span class="comment">             * 进行强制qs或eqs检查。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (rsp-&gt;n_force_qs == rdp-&gt;n_force_qs_snap &amp;&amp;</span><br><span class="line">                    *rdp-&gt;nxttail[RCU_DONE_TAIL] != head)</span><br><span class="line">                force_quiescent_state(rsp);</span><br><span class="line">            rdp-&gt;n_force_qs_snap = rsp-&gt;n_force_qs;</span><br><span class="line">            rdp-&gt;qlen_last_fqs_check = rdp-&gt;qlen;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺便说一下<code>synchronize_rcu</code>，这个函数其实就是调用<code>__call_rcu</code>，然后让当前进程调度走并等待一个<code>struct completion</code>，grace period完成后调用callback设置刚才的completion唤醒等待的进程，也就是说核心依然是<code>__call_rcu</code>和RCU中对grace period的处理。</p>
<h3 id="检查回调"><a href="#检查回调" class="headerlink" title="检查回调"></a>检查回调</h3><p>RCU对grace period的处理过程比较复杂，涉及中断、软中断及内核线程配合处理。</p>
<h4 id="中断部分"><a href="#中断部分" class="headerlink" title="中断部分"></a>中断部分</h4><p>RCU的激活检查由函数<code>rcu_check_callbacks</code>完成，在<code>update_process_times</code>中被调用，由每个CPU的本地定时器中断触发，可以参考<a href="/2018/10/17/linux-kernel-timer/#硬件定时器初始化">timer定时器中硬件定时器初始化部分</a>。</p>
<p>主要功能就是判断是否处于qs（不同rsp判断qs的标准不同），如果处于qs就更新相应rsp中当前CPU的rdp，然后根据是否需要软中断做进一步处理选择是否激活软中断。</p>
<figure class="highlight c"><figcaption><span>RCU中断流程</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+</span><br><span class="line">|rcu_check_callbacks|</span><br><span class="line">+--+----------------+</span><br><span class="line">   |</span><br><span class="line">   |   +-------------------------------------------------------------+</span><br><span class="line">   +---+                 increment_cpu_stall_ticks                   |                </span><br><span class="line">   |   |增加所有rsp下当前CPU的rdp成员ticks_this_gp，用于检测CPU长期占|</span><br><span class="line">   |   +-------------------------------------------------------------+</span><br><span class="line">   |</span><br><span class="line">   |</span><br><span class="line">   |   +--------------------------------------------------------+</span><br><span class="line">   |   |如果中断发生时位于用户态或处于CPU idle状态，调用两个函数|</span><br><span class="line">   +---+  rcu_sched_qs                                          |</span><br><span class="line">   |   |  rcu_bh_qs                                             |</span><br><span class="line">   |   +--------------------------------------------------------+</span><br><span class="line">   |</span><br><span class="line">   |   +--------------------------------------------------------+</span><br><span class="line">   +---+如果不处于用户态或CPU idle状态，同时也不在软中断中，调用|</span><br><span class="line">   |   |  rcu_bh_qs                                             |</span><br><span class="line">   |   +--------------------------------------------------------+</span><br><span class="line">   |</span><br><span class="line">   |</span><br><span class="line">   |</span><br><span class="line">   |   +--------------------------------------------------------+</span><br><span class="line">   +---+rcu_preempt_check_callbacks                             |</span><br><span class="line">   |   |可抢占RCU相关，在未配置CONFIG_TREE_PREEMPT_RCU时是空函数|</span><br><span class="line">   |   +--------------------------------------------------------+</span><br><span class="line">   |</span><br><span class="line">   |</span><br><span class="line">   |   +-------------------------------------------------+</span><br><span class="line">   +---|如果rcu_pending为真（就是需要软中断干活了），调用|</span><br><span class="line">   |   |invoke_rcu_core（实际就是激活RCU_SOFTIRQ软中断） |</span><br><span class="line">   |   +-------------------------------------------------+</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">  返回</span><br></pre></td></tr></table></figure>
<p><code>rcu_sched_qs</code>逻辑很简单，只是标记<code>rcu_sched_state</code>对应的rdp成员<code>passed_quiesce</code>为1。因为该CPU不处于内核代码的上下文，因此一定不在<code>rcu_read_lock</code>开始的临界区中（因为临界区是关闭内核抢占的，不会发生内核抢占，进入用户态或idle状态就说明经历了调度），说明该CPU经过了静止状态。</p>
<p><code>rcu_bh_qs</code>逻辑也是一样，标记<code>rcu_bh_state</code>对应的rdp成员<code>passed_quiesce</code>为1。因为该CPU不处于软中断上下文，因此一定不在<code>rcu_read_lock_bh</code>开始的临界区中，说明该CPU经过了静止状态。</p>
<h4 id="软中断部分"><a href="#软中断部分" class="headerlink" title="软中断部分"></a>软中断部分</h4><p>RCU在每个CPU的主要处理部分在RCU_SOFTIRQ软中断中进行，函数为<code>rcu_process_callbacks</code>，这个函数只是遍历所有rsp并调用<code>__rcu_process_callbacks</code>。</p>
<figure class="highlight c"><figcaption><span>rcu_process_callbacks</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Do RCU core processing for the current CPU.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rcu_process_callbacks</span><span class="params">(struct softirq_action *unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_state</span> *<span class="title">rsp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cpu_is_offline(smp_processor_id()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    trace_rcu_utilization(<span class="string">"Start RCU core"</span>);</span><br><span class="line">    for_each_rcu_flavor(rsp)</span><br><span class="line">        __rcu_process_callbacks(rsp);</span><br><span class="line">    trace_rcu_utilization(<span class="string">"End RCU core"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+</span><br><span class="line">|__rcu_process_callbacks|</span><br><span class="line">+-----------------------+</span><br><span class="line">   |</span><br><span class="line">   |   +-------------------------------------------------------------------------+</span><br><span class="line">   |   |rcu_process_gp_end                                                       |</span><br><span class="line">   +---+这里对已经完成的callback在nxtlist链表上进行推进，放入已经完成gp的子链表。|</span><br><span class="line">   |   |并向completed从rnp向下传递到rdp。                                        |</span><br><span class="line">   |   +-------------------------------------------------------------------------+</span><br><span class="line">   |</span><br><span class="line">   |   +-------------------------+</span><br><span class="line">   +---+rcu_check_quiescent_state|</span><br><span class="line">   |   +--+----------------------+</span><br><span class="line">   |      |</span><br><span class="line">   |      |   +-----------------------------------------------------------------------+</span><br><span class="line">   |      |   |check_for_new_grace_period                                             |</span><br><span class="line">   |      |   |                                                                       |</span><br><span class="line">   |      +---+检查是否开始有新的gp，如果有则将gpnum从rnp向下传递到rdp，              |</span><br><span class="line">   |      |   |并更新rdp的qs_pending和passed_quiesce。                                |</span><br><span class="line">   |      |   |                                                                       |</span><br><span class="line">   |      |   |这个函数返回真的话，说明有新的gp，那么rcu_check_quiescent_state直接返回|</span><br><span class="line">   |      |   +-----------------------------------------------------------------------+</span><br><span class="line">   |      |</span><br><span class="line">   |      |   +--------------------------------------------------------------+</span><br><span class="line">   |      +---+如果rdp的qs_pending为假，说明当前gp不需要这个CPU的qs，直接返回|</span><br><span class="line">   |      |   +--------------------------------------------------------------+</span><br><span class="line">   |      |</span><br><span class="line">   |      |   +------------------------------------------------------------------------+</span><br><span class="line">   |      +---+如果rdp的passed_quiesce为假，说明当前gp在这个CPU上还没有经历qs，直接返回|</span><br><span class="line">   |      |   +------------------------------------------------------------------------+</span><br><span class="line">   |      |</span><br><span class="line">   |      |   +------------------------------------------------------+</span><br><span class="line">   |      |   |rcu_report_qs_rdp                                     |</span><br><span class="line">   |      +---+将qs完成情况向上汇报，如果最后根节点rnp的qsmask为<span class="number">0</span>了，|</span><br><span class="line">   |      |   |就可以唤醒内核线程做gp结束的处理工作了。              |</span><br><span class="line">   |      |   +------------------------------------------------------+</span><br><span class="line">   |&lt;-----+</span><br><span class="line">   |</span><br><span class="line">   |   +-----------------------------------+</span><br><span class="line">   +---+如果cpu_needs_another_gp返回真，调用|</span><br><span class="line">   |   |rcu_start_gp开始一个新gp           |</span><br><span class="line">   |   +-----------------------------------+</span><br><span class="line">   |</span><br><span class="line">   |   +-----------------------------------------------------------------------------------+</span><br><span class="line">   +---+如果cpu_hash_callbacks_ready_to_invoke返回真（判断nxtlist上是否有完成gp的callback）|</span><br><span class="line">   |   |调用 invode_rcu_callbacks                                                          |</span><br><span class="line">   |   +--+--------------------------------------------------------------------------------+</span><br><span class="line">   |      |</span><br><span class="line">   |      |   +-------------------------------------------------------+</span><br><span class="line">   |      +---+如果启用了rcu boost，则调用invoke_rcu_callbacks_kthread|</span><br><span class="line">   |      |   +-------------------------------------------------------+</span><br><span class="line">   |      |</span><br><span class="line">   |      |   +--------------------------------------------------------------------------+</span><br><span class="line">   |      |   |否则调用 rcu_do_batch                                                     |</span><br><span class="line">   |      |   |                                                                          |</span><br><span class="line">   |      |   |这里不细说了，大概就是根据rdp中blimit的值批量运行一部分callback，然后判断 |</span><br><span class="line">   |      +---+如果当前是idle进程上下文或者运行运行在单独的内核线程中，并且没有调度的需求|</span><br><span class="line">   |      |   |那么还可以接续运行更多的callback。否则会停止运行callback。                |</span><br><span class="line">   |      |   |最后如果有剩余的callback没运行，再放回nxtlist头部等待下次rcu_do_batch，   |</span><br><span class="line">   |      |   |还更新了一些rdp中的成员值，细节。                                         |</span><br><span class="line">   |      |   +--------------------------------------------------------------------------+</span><br><span class="line">   |&lt;-----+</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">软中断部分完成</span><br></pre></td></tr></table></figure>
<h4 id="内核线程部分"><a href="#内核线程部分" class="headerlink" title="内核线程部分"></a>内核线程部分</h4><p>每个rsp有一个内核线程负责grace pierod的开始和结束。为什么创建一个线程独立负责这部分，我只能猜测是为了避免grace period开始时并发操作rsp时锁的spin，由一个独立线程负责可以避免冲突，软中断中只要直接从内存读取rsp相关成员就可以了。</p>
<p><code>rcu_gp_kthread</code>内部是一个不会退出的循环：</p>
<figure class="highlight c"><figcaption><span>rcu_gp_kthread</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">+--------------+</span><br><span class="line">|rcu_gp_kthread|</span><br><span class="line">+------+-------+</span><br><span class="line">       |                                                 </span><br><span class="line">       |                                                 </span><br><span class="line">  +---&gt;|                                                 </span><br><span class="line">  |    |                                                 </span><br><span class="line">  |    |   +------------------------------------------------+</span><br><span class="line">  |    +---+循环等待`rsp-&gt;gp_flags &amp; RCU_GP_FLAG_INIT`为真，|</span><br><span class="line">  |    |   |这时说明应该为该rsp开启一个新的grace period。   |</span><br><span class="line">  |    |   +------------------------------------------------+</span><br><span class="line">  |    |</span><br><span class="line">  |    |   +--------------------------------------------------------------+</span><br><span class="line">  |    +---|              rcu_gp_init 开启一个新的grace period            |</span><br><span class="line">  |    |   |开启与新的grace period，由内核线程唯一负责，该函数的唯一调用点|</span><br><span class="line">  |    |   +--------------------------------------------------------------+</span><br><span class="line">  |    |     |</span><br><span class="line">  |    |     |   +----------------------------+</span><br><span class="line">  |    |     +---+rsp-&gt;gp_flags置<span class="number">0</span>，清理标记。|</span><br><span class="line">  |    |     |   +----------------------------+</span><br><span class="line">  |    |     |</span><br><span class="line">  |    |     |   +-------------------------------------------------+</span><br><span class="line">  |    |     +---+rsp-&gt;gpnum ++，记录当前新开始的grace period序号。|</span><br><span class="line">  |    |     |   +-------------------------------------------------+</span><br><span class="line">  |    |     |</span><br><span class="line">  |    |     |   +-----------------------------+</span><br><span class="line">  |    |     +---+遍历所有的rnp，进行以下操作：|</span><br><span class="line">  |    |     |   +--+--------------------------+</span><br><span class="line">  |    |     |      |</span><br><span class="line">  |    |     |      |    +----------------------------------------------+</span><br><span class="line">  |    |     |      +----|rnp-&gt;qsmask设置为rnp-&gt;qsmaskinit，            |</span><br><span class="line">  |    |     |      |    |  qsmask用于标记下属rnp或rdp静止状态的完成情况|</span><br><span class="line">  |    |     |      |    |  经历过静止状态的节点会清除相应bit位。       |</span><br><span class="line">  |    |     |      |    +----------------------------------------------+</span><br><span class="line">  |    |     |      |</span><br><span class="line">  |    |     |      |    +--------------------------------------------------------------------------+</span><br><span class="line">  |    |     |      +----+rnp-&gt;completed设置为rsp-&gt;completed，                                      |</span><br><span class="line">  |    |     |      |    |  这个操作有点像冗余操作，因为在这个线程调用`rcu_gp_cleanup`时会更新该值。|</span><br><span class="line">  |    |     |      |    +--------------------------------------------------------------------------+</span><br><span class="line">  |    |     |      |</span><br><span class="line">  |    |     |      |    +-----------------------------------------+</span><br><span class="line">  |    |     |      +----+rnp-&gt;gpnum设置为rsp-&gt;gpnum               |</span><br><span class="line">  |    |     |      |    |  可以看到gpnum是由rsp向下传递到所有rnp的|</span><br><span class="line">  |    |     |      |    +-----------------------------------------+</span><br><span class="line">  |    |     |      |</span><br><span class="line">  |    |     |      |    +---------------------------------------------+</span><br><span class="line">  |    |     |      +----+如果操作的rnp是当前CPU对应的rdp的父节点，调用|</span><br><span class="line">  |    |     |      |    |rcu_start_gp_per_cpu (该函数的唯一调用点)    |</span><br><span class="line">  |    |     |      |    +--+------------------------------------------+</span><br><span class="line">  |    |     |      |       |</span><br><span class="line">  |    |     |      |       |   +--------------------+</span><br><span class="line">  |    |     |      |       |   |__rcu_process_gp_end|</span><br><span class="line">  |    |     |      |       |   +--------------------+</span><br><span class="line">  |    |     |      |       |   这里作用是加速callback子表合并，和推进已经完成gp的callback到完成子表。</span><br><span class="line">  |    |     |      |       |   参考函数解释节。</span><br><span class="line">  |    |     |      |       |</span><br><span class="line">  |    |     |      |       |   +----------------+</span><br><span class="line">  |    |     |      |       +---+__note_new_gpnum|</span><br><span class="line">  |    |     |      |       |   +----------------+</span><br><span class="line">  |    |     |      |       |   这里将新的gpnum向下推进到rdp上。并更新passed_quiesce和qs_pending。</span><br><span class="line">  |    |     |      |       |</span><br><span class="line">  |    |     |      |&lt;------+</span><br><span class="line">  |    |     |      |</span><br><span class="line">  |    |     |      |    +--------------------------+</span><br><span class="line">  |    |     |      +----+rcu_preempt_boost_start_gp|</span><br><span class="line">  |    |     |      |    +--------------------------+</span><br><span class="line">  |    |     |      |    boost相关，不关注</span><br><span class="line">  |    |     |      |</span><br><span class="line">  |    |     |&lt;-----+</span><br><span class="line">  |    |     |</span><br><span class="line">  |    |&lt;----+</span><br><span class="line">  |    |</span><br><span class="line">  |    |</span><br><span class="line">  |    |   +---------------------------------------------------------------------------+</span><br><span class="line">  |    |   |循环等待根节点`rnp-&gt;qsmask`为<span class="number">0</span>，                                           |</span><br><span class="line">  |    +---+这时说明所有的CPU都经历过静止状态，可以结束当前grace period。              |</span><br><span class="line">  |    |   |在超时或rsp中RCU_GP_FLAG_FQS被设置时，会调用rcu_gp_fqs强制检查qs（或eqs），|</span><br><span class="line">  |    |   |这里也可能清除符合条件的CPU的掩码位并逐级向上汇报。参考函数解释节。        |</span><br><span class="line">  |    |   +---------------------------------------------------------------------------+</span><br><span class="line">  |    |</span><br><span class="line">  |    |</span><br><span class="line">  |    |   +---------------------------------------+</span><br><span class="line">  |    +---+`rcu_gp_cleanup` 结束当前grace period。|</span><br><span class="line">  |    |   +-+-------------------------------------+</span><br><span class="line">  |    |     | </span><br><span class="line">  |    |     |   +-----------------------------+</span><br><span class="line">  |    |     +---+遍历所有的rnp，进行以下操作：|</span><br><span class="line">  |    |     |   +--+--------------------------+</span><br><span class="line">  |    |     |      |</span><br><span class="line">  |    |     |      |    +------------------------------+</span><br><span class="line">  |    |     |      +----+rnp-&gt;completed设置为rsp-&gt;gpnum|</span><br><span class="line">  |    |     |      |    +------------------------------+</span><br><span class="line">  |    |     |      |</span><br><span class="line">  |    |     |      |    +-----------------------------------------------------------------------+</span><br><span class="line">  |    |     |      +----+如果操作的rnp是当前CPU对应的rdp的父节点，调用                          |</span><br><span class="line">  |    |     |      |    |__rcu_process_gp_end，用于推进当前CPU上已经完成gp的callback等待被执行。|</span><br><span class="line">  |    |     |      |    +-----------------------------------------------------------------------+</span><br><span class="line">  |    |     |      |</span><br><span class="line">  |    |     |      |    +-----------------------------------------------------------+</span><br><span class="line">  |    |     |      |    |rcu_future_gp_cleanup                                      |</span><br><span class="line">  |    |     |      +----+清除rnp成员need_future_gp中刚刚完成的gp序号标记，          |</span><br><span class="line">  |    |     |      |    |并返回下一个gp序号标记是否需要开启。                       |</span><br><span class="line">  |    |     |      |    |这里会调用rcu_nocb_gp_cleanup唤醒等待该gp完成的nocb内核线程|</span><br><span class="line">  |    |     |      |    +-----------------------------------------------------------+</span><br><span class="line">  |    |     |      |</span><br><span class="line">  |    |     |&lt;-----+</span><br><span class="line">  |    |     |</span><br><span class="line">  |    |     |   +------------------------------------------------+</span><br><span class="line">  |    |     +---+rcu_nocb_gp_set，传入根节点rnp。nocb相关先不关注||</span><br><span class="line">  |    |     |   +------------------------------------------------+</span><br><span class="line">  |    |     |      </span><br><span class="line">  |    |     |   +----------------------------------------------+</span><br><span class="line">  |    |     +---+rsp-&gt;completed设置为rsp-&gt;gpnum，当前gp正式完成|</span><br><span class="line">  |    |     |   +----------------------------------------------+</span><br><span class="line">  |    |     |</span><br><span class="line">  |    |     |   +---------------------------------------------------------+</span><br><span class="line">  |    |     +---+rsp-&gt;fqs_state = RCU_GP_IDLE，实际上rsp中该成员并没有用到|</span><br><span class="line">  |    |     |   +---------------------------------------------------------+</span><br><span class="line">  |    |     |      </span><br><span class="line">  |    |     |   +--------------------------------------------+</span><br><span class="line">  |    |     |   |rcu_advance_cbs                             |</span><br><span class="line">  |    |     +---+推进当前CPU的rdp上的callback链表，          |</span><br><span class="line">  |    |     |   |这样下一步操作可以减少误判以避免无谓开始新gp|</span><br><span class="line">  |    |     |   +--------------------------------------------+</span><br><span class="line">  |    |     |      </span><br><span class="line">  |    |     |   +------------------------------------------------+</span><br><span class="line">  |    |     |   |如果cpu_needs_another_gp返回真，                |</span><br><span class="line">  |    |     +---+  rsp-&gt;gp_flags设置为RCU_GP_FLAG_INIT，         |</span><br><span class="line">  |    |     |   |  这样该线程再次循环时就会开启新的grace period。|</span><br><span class="line">  |    |     |   +------------------------------------------------+</span><br><span class="line">  |    |     |      </span><br><span class="line">  |    |&lt;----+      </span><br><span class="line">  |    |       </span><br><span class="line">  |    |      </span><br><span class="line">  +&lt;---+   开始下一个循环</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/linux/">linux</a></div><div class="post-nav"><a class="pre" href="/2018/11/20/virt-install/">virt-install 简单使用</a><a class="next" href="/2018/10/17/linux-kernel-timer/">Linux timer 内核软件定时器</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://www.hyuuhit.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/libvirt/">libvirt</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/suricata/">suricata</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/vmware/" style="font-size: 15px;">vmware</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/08/20/bash-invocation/">bash 调用方式与配置文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/17/uriparser/">uriparser 解析处理URI</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/06/noblock-rabbitmq-c/">rabbitmq-c 非阻塞订阅</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/20/libyaml/">libyaml 解析配置文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/23/netns/">Linux network namespace 简单解读</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/11/af-packet-bpf/">AF_PACKET & BPF 伪造arp响应</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/04/nonblock-redis/">hiredis & libev 非阻塞模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/13/nwfilter/">libvirt nwfilter 简单使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/03/libxml2/">libxml2 简单使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/20/virt-install/">virt-install 简单使用</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">属乌鸦的.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>