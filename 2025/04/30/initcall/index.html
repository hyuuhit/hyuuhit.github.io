<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="huyu's blog | Linux"><title>initcall 机制 | 属乌鸦的</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-129648993-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '85d80db9310fa34ab2f7d34beeff589b';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">initcall 机制</h1><a id="logo" href="/.">属乌鸦的</a><p class="description">无知 &amp; 聒噪</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">initcall 机制</h1><div class="post-meta">Apr 30, 2025</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#定义"><span class="toc-number">1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#链接"><span class="toc-number">2.</span> <span class="toc-text">链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运行"><span class="toc-number">3.</span> <span class="toc-text">运行</span></a></li></ol></div></div><div class="post-content"><p>linux内核各个子系统和内置模块都有自己的初始化函数，比如<code>init_tracepoints</code>，但是看不到这个函数是如何被调用的，只有<code>__initcall(init_tracepoints)</code>这样一条语句。这里的<code>__initcall</code>被宏定义为<code>device_initcall</code>，类似还有<code>early_initcall</code>、<code>pure_initcall</code>、<code>core_initcall</code>等等。这些就是initcall机制，使得各个初始化函数可以按一定先后顺序被调用执行。</p>
<a id="more"></a>
<p>参考内核版本：3.10.0-862.el7.x86_64</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在文件include/linux/init.h中可以看到各种initcall被宏定义为<code>__define_initcall</code>，<code>__define_initcall</code>接收两个参数，<code>fn</code>是回调函数，<code>id</code>有两个作用，一个是标示段及其优先级，另一个是使不同优先级的段中可以存在同一个回调函数而不出现符号冲突。</p>
<p>以<code>__initcall(init_tracepoints)</code>为例，会被扩展为<code>device_initcall(init_tracepoints)</code>，再次扩展为<code>__define_initcall(init_tracepoints, 6)</code>，</p>
<p>这会定义出一个变量<code>__initcall_init_tracepoints6</code></p>
<ul>
<li>类型为<code>static initcall_t</code>，<code>initcall_t</code>的类型是<code>typedef int (*initcall_t)(void)</code>，也就是回调函数的类型。</li>
<li>被放置于段.initcall6.init中。</li>
<li>被赋值为<code>init_tracepoints</code>，也就是该回调函数的地址。</li>
<li><code>__used</code>用于使编译器不会优化掉该变量，同时使编译器不会警告该变量未被直接引用。</li>
</ul>
<figure class="highlight c"><figcaption><span>include/linux/init.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* initcalls are now grouped by functionality into separate</span></span><br><span class="line"><span class="comment">* subsections. Ordering inside the subsections is determined</span></span><br><span class="line"><span class="comment">* by link order.</span></span><br><span class="line"><span class="comment">* For backwards compatibility, initcall() puts the call in</span></span><br><span class="line"><span class="comment">* the device init subsection.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* The `id' arg to __define_initcall() is needed so that multiple initcalls</span></span><br><span class="line"><span class="comment">* can point at the same handler without causing duplicate-symbol build errors.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __define_initcall(fn, id) \</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">initcall_t</span> __initcall_#<span class="meta">#fn##id __used \</span></span><br><span class="line">    __attribute__((__section__(<span class="string">".initcall"</span> #id <span class="string">".init"</span>))) = fn</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Early initcalls run before initializing SMP.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Only for built-in code, not modules.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#define early_initcall(fn)      __define_initcall(fn, early)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* A "pure" initcall has no dependencies on anything else, and purely</span></span><br><span class="line"><span class="comment">* initializes variables that couldn't be statically initialized.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* This only exists for built-in code, not for modules.</span></span><br><span class="line"><span class="comment">* Keep main.c:initcall_level_names[] in sync.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#define pure_initcall(fn)       __define_initcall(fn, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">#define core_initcall(fn)       __define_initcall(fn, <span class="number">1</span>)</span><br><span class="line">#define core_initcall_sync(fn)      __define_initcall(fn, <span class="number">1</span>s)</span><br><span class="line">#define postcore_initcall(fn)       __define_initcall(fn, <span class="number">2</span>)</span><br><span class="line">#define postcore_initcall_sync(fn)  __define_initcall(fn, <span class="number">2</span>s)</span><br><span class="line">#define arch_initcall(fn)       __define_initcall(fn, <span class="number">3</span>)</span><br><span class="line">#define arch_initcall_sync(fn)      __define_initcall(fn, <span class="number">3</span>s)</span><br><span class="line">#define subsys_initcall(fn)     __define_initcall(fn, <span class="number">4</span>)</span><br><span class="line">#define subsys_initcall_sync(fn)    __define_initcall(fn, <span class="number">4</span>s)</span><br><span class="line">#define fs_initcall(fn)         __define_initcall(fn, <span class="number">5</span>)</span><br><span class="line">#define fs_initcall_sync(fn)        __define_initcall(fn, <span class="number">5</span>s)</span><br><span class="line">#define rootfs_initcall(fn)     __define_initcall(fn, rootfs)</span><br><span class="line">#define device_initcall(fn)     __define_initcall(fn, <span class="number">6</span>)</span><br><span class="line">#define device_initcall_sync(fn)    __define_initcall(fn, <span class="number">6</span>s)</span><br><span class="line">#define late_initcall(fn)       __define_initcall(fn, <span class="number">7</span>)</span><br><span class="line">#define late_initcall_sync(fn)      __define_initcall(fn, <span class="number">7</span>s)</span><br><span class="line"></span><br><span class="line">#define __initcall(fn) device_initcall(fn)</span><br><span class="line"></span><br><span class="line">#define __exitcall(fn) \</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">exitcall_t</span> __exitcall_##fn __exit_call = fn</span><br><span class="line"></span><br><span class="line">#define console_initcall(fn) \</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">initcall_t</span> __initcall_##fn \</span><br><span class="line">    __used __section(.con_initcall.init) = fn</span><br><span class="line"></span><br><span class="line">#define security_initcall(fn) \</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">initcall_t</span> __initcall_##fn \</span><br><span class="line">    __used __section(.security_initcall.init) = fn</span><br></pre></td></tr></table></figure>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>在链接器脚本头文件include/asm-generic/vmlinux.lds.h中可以看到对这些段的使用</p>
<p>最终的效果是，在内核的段.init.data中</p>
<ul>
<li>定义了符号，函数指针数组<code>__initcall_start[]</code>，存储了一组函数指针<ul>
<li>所有目标文件.initcallearly.init段中的函数指针</li>
</ul>
</li>
<li>通过宏<code>INIT_CALLS_LEVEL(0)</code>，定义了符号，函数指针数组<code>__initcall0_start[]</code>，按顺序存储了两组函数指针<ul>
<li>所有目标文件.initcall0.init段中的函数指针</li>
<li>所有目标文件.initcall0s.init段中的函数指针</li>
</ul>
</li>
<li>与上面的宏<code>INIT_CALLS_LEVEL(0)</code>同样方式，分别处理1、2、3、4、5、rootfs、6、7这些initcall等级。</li>
<li>定义了符号，函数指针数组<code>__initcall_end[]</code>，这个地址就是上面这些指针的末尾地址。</li>
<li>定义了符号，函数指针数组<code>__con_initcall_start[]</code>，存储了一组函数指针<ul>
<li>所有目标文件.con_initcall.init段中的函数指针</li>
</ul>
</li>
<li>定义了符号，函数指针数组<code>__con_initcall_end[]</code>，这个地址就是上面这组函数指针的末尾地址。</li>
<li>定义了符号，函数指针数组<code>__security_initcall_start[]</code>，存储了一组函数地址<ul>
<li>所有目标文件.security_initcall.init段中的函数指针</li>
</ul>
</li>
<li>定义了符号，函数指针数组<code>__security_initcall_end[]</code>，这个地址就是上面这组函数指针的末尾地址。</li>
</ul>
<p><code>INIT_DATA_SECTION</code>宏将上面这些数据都放置到段.init.data，这个宏会在链接器脚本x86/kernel/vmlinux.lds.S中被调用</p>
<figure class="highlight c"><figcaption><span>include/asm-generic/vmlinux.lds.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_CALLS_LEVEL(level)                     \</span></span><br><span class="line">        VMLINUX_SYMBOL(__initcall##level##_start) = .;      \</span><br><span class="line">        *(.initcall##level##.init)              \</span><br><span class="line">        *(.initcall##level##s.init)             \</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_CALLS                          \</span></span><br><span class="line">        VMLINUX_SYMBOL(__initcall_start) = .;           \</span><br><span class="line">        *(.initcallearly.init)                  \</span><br><span class="line">        INIT_CALLS_LEVEL(<span class="number">0</span>)                 \</span><br><span class="line">        INIT_CALLS_LEVEL(<span class="number">1</span>)                 \</span><br><span class="line">        INIT_CALLS_LEVEL(<span class="number">2</span>)                 \</span><br><span class="line">        INIT_CALLS_LEVEL(<span class="number">3</span>)                 \</span><br><span class="line">        INIT_CALLS_LEVEL(<span class="number">4</span>)                 \</span><br><span class="line">        INIT_CALLS_LEVEL(<span class="number">5</span>)                 \</span><br><span class="line">        INIT_CALLS_LEVEL(rootfs)                \</span><br><span class="line">        INIT_CALLS_LEVEL(<span class="number">6</span>)                 \</span><br><span class="line">        INIT_CALLS_LEVEL(<span class="number">7</span>)                 \</span><br><span class="line">        VMLINUX_SYMBOL(__initcall_end) = .;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_DATA_SECTION(initsetup_align)              \</span></span><br><span class="line">    .init.data : AT(ADDR(.init.data) - LOAD_OFFSET) &#123;       \</span><br><span class="line">        INIT_DATA                       \</span><br><span class="line">        INIT_SETUP(initsetup_align)             \</span><br><span class="line">        INIT_CALLS                      \</span><br><span class="line">        CON_INITCALL                        \</span><br><span class="line">        SECURITY_INITCALL                   \</span><br><span class="line">        INIT_RAM_FS                     \</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>按照时间顺序，这里只关注initcall相关，不记录其他内容</p>
<p><code>start_kernel</code> &lt;- <code>x86_64_start_reservations</code> &lt;- <code>x86_64_start_kernel</code></p>
<ul>
<li><code>console_init</code><ul>
<li>从<code>__con_initcall_start</code>遍历到<code>__con_initcall_end</code>，执行每个回调函数。</li>
</ul>
</li>
<li><code>security_init</code><ul>
<li><code>do_security_initcalls</code><ul>
<li>从<code>__security_initcall_start</code>遍历到<code>__security_initcall_end</code>，执行每个回调函数。</li>
</ul>
</li>
</ul>
</li>
<li><code>rest_init</code>，创建出1号进程，执行<code>kernel_init</code><ul>
<li><code>kernel_init_freeable</code><ul>
<li>先等待<code>kthreadd</code>进程创建，也就是其<code>task_struct</code>指针变量<code>kthreadd_task</code>被赋值完成。</li>
<li><code>do_pre_smp_initcalls</code><ul>
<li>从<code>__initcall_start</code>遍历到<code>__initcall0_start</code>，对每个回调函数指针，依次调用<code>do_one_initcall</code>执行初始化函数</li>
</ul>
</li>
<li><code>do_basic_setup</code><ul>
<li><code>do_initcalls</code><ul>
<li>遍历<code>initcall_levels</code>数组，按顺序依次调用<code>do_initcall_level</code><ul>
<li>从一个level的函数指针数组起始位置，对每个回调函数指针，依次调用<code>do_one_initcall</code>执行初始化函数，直到下一个数组的起始位置</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>可以看到这个数组里缺少了<code>__initcallrootfs_start</code>。由于其实际处于5和6之间，因此也会在5之后6之前被执行到。</p>
<p>那些带有sync后缀的initcall宏修饰的回调函数，目的是等待本等级的所有回调函数执行完成后，才会被调用，例如执行一些清理操作。<br>比如<code>late_initcall_sync</code>修饰的函数，会在所有<code>late_initcall</code>修饰的函数执行完成后被调用。这是由<code>INIT_CALLS_LEVEL</code>宏的实现决定的。</p>
<figure class="highlight c"><figcaption><span>init/main.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">initcall_t</span> __initcall_start[];</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">initcall_t</span> __initcall0_start[];</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">initcall_t</span> __initcall1_start[];</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">initcall_t</span> __initcall2_start[];</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">initcall_t</span> __initcall3_start[];</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">initcall_t</span> __initcall4_start[];</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">initcall_t</span> __initcall5_start[];</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">initcall_t</span> __initcall6_start[];</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">initcall_t</span> __initcall7_start[];</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">initcall_t</span> __initcall_end[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">initcall_t</span> *initcall_levels[] __initdata = &#123;</span><br><span class="line">    __initcall0_start,</span><br><span class="line">    __initcall1_start,</span><br><span class="line">    __initcall2_start,</span><br><span class="line">    __initcall3_start,</span><br><span class="line">    __initcall4_start,</span><br><span class="line">    __initcall5_start,</span><br><span class="line">    __initcall6_start,</span><br><span class="line">    __initcall7_start,</span><br><span class="line">    __initcall_end,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>init/main.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">init_or_module <span class="title">do_one_initcall</span><span class="params">(<span class="keyword">initcall_t</span> fn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = preempt_count();</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initcall_blacklisted(fn))</span><br><span class="line">        <span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initcall_debug)</span><br><span class="line">        ret = do_one_initcall_debug(fn);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret = fn();</span><br><span class="line"></span><br><span class="line">    msgbuf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (preempt_count() != count) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(msgbuf, <span class="string">"preemption imbalance "</span>);</span><br><span class="line">        preempt_count() = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (irqs_disabled()) &#123;</span><br><span class="line">        strlcat(msgbuf, <span class="string">"disabled interrupts "</span>, <span class="keyword">sizeof</span>(msgbuf));</span><br><span class="line">        local_irq_enable();</span><br><span class="line">    &#125;</span><br><span class="line">    WARN(msgbuf[<span class="number">0</span>], <span class="string">"initcall %pF returned with %s\n"</span>, fn, msgbuf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/linux/">linux</a></div><div class="post-nav"><a class="pre" href="/2025/05/05/static-key-jump-label/">static key &amp; jump label</a><a class="next" href="/2025/04/07/cn-proc-example/">cn_proc 进程事件连接器</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://www.hyuuhit.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/libvirt/">libvirt</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/suricata/">suricata</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/vmware/" style="font-size: 15px;">vmware</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/06/08/screen-windows-auto-title/">gnu screen 自动修改窗口标题</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/06/02/stop-machine/">stop_machine 实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/05/05/static-key-jump-label/">static key & jump label</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/30/initcall/">initcall 机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/07/cn-proc-example/">cn_proc 进程事件连接器</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/04/executable-shared-library/">可执行的动态链接库</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/05/26/dirpro-bug-analysis/">一次无源码Linux内核模块bug分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/05/13/elrepo-not-for-production-use/">为什么生产环境服务器不应该使用ELRepo内核</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/04/29/memory-consistency-model-memory-barrier-and-sychronization/">内存一致性模型、内存屏障与同步</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/04/11/rcu-usage/">抢占式RCU与RCU使用</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">属乌鸦的.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>