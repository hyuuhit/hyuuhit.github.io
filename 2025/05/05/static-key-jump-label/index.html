<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="huyu's blog | Linux"><title>static key &amp; jump label | 属乌鸦的</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-129648993-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '85d80db9310fa34ab2f7d34beeff589b';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">static key &amp; jump label</h1><a id="logo" href="/.">属乌鸦的</a><p class="description">无知 &amp; 聒噪</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">static key &amp; jump label</h1><div class="post-meta">May 5, 2025</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#动机"><span class="toc-number">1.</span> <span class="toc-text">动机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方案"><span class="toc-number">2.</span> <span class="toc-text">方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jump-label"><span class="toc-number">3.</span> <span class="toc-text">jump label</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#API及实现"><span class="toc-number">4.</span> <span class="toc-text">API及实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#旧版API"><span class="toc-number">4.1.</span> <span class="toc-text">旧版API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#未启用jump-label时"><span class="toc-number">4.1.1.</span> <span class="toc-text">未启用jump label时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#已启用jump-label时"><span class="toc-number">4.1.2.</span> <span class="toc-text">已启用jump label时</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#分支代码"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">分支代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#jump-table-初始化"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">jump table 初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#分支控制"><span class="toc-number">4.1.2.3.</span> <span class="toc-text">分支控制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#新版API"><span class="toc-number">4.2.</span> <span class="toc-text">新版API</span></a></li></ol></li></ol></div></div><div class="post-content"><p>static keys通过gcc特性和代码补丁技术的支持，可以在性能敏感的快速路径内核代码中包含很少使用的特性，使得在该特性不开启的情况下，尽可能降低对正常代码分支运行性能的影响。比如分支预测和缓存交换的性能损失。一句话就是性能损耗小。</p>
<a id="more"></a>
<p><a href="https://docs.kernel.org/staging/static-keys.html" target="_blank" rel="noopener">static keys内核文档</a></p>
<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>起初，tracepoints是使用条件分支实现的。条件检查要求为每个tracepoint检查一个全局变量。虽然这种检查的开销很小，但是当缓存承受压力时，开销会增加（这些全局变量可能与其他要访问的内存数据共享cache line）。随着我们在内核中增加跟踪点的数量，这个开销可能会变得更大。此外，tracepoints通常处于休眠状态（未启用），不提供直接的内核功能。因此，尽可能减少它们的影响是很有意义的。尽管tracepoints是这项工作的最初动机，但其他内核代码路径同样能够利用static keys。</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>gcc（v4.5）增加了一个新的”asm goto”语句，允许在内联汇编语句中跳转到C代码label（也就是内联汇编中可以得到C代码label的地址）:<br><a href="https://gcc.gnu.org/ml/gcc-patches/2009-07/msg01556.html" target="_blank" rel="noopener">https://gcc.gnu.org/ml/gcc-patches/2009-07/msg01556.html</a></p>
<p>通过使用”asm goto”，可以在不需要检查内存的情况下，创建出新的分支，无论默认状态下这个分支有没有被启用。之后在运行时，可以为分支位置打补丁修改分支方向。</p>
<p>比如，如果有一个默认状态为禁用的简单分支</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (static_branch_unlikely(&amp;key))</span><br><span class="line">    printk(<span class="string">"I am the true branch\n"</span>);</span><br></pre></td></tr></table></figure>
<p>那么，默认状态下这句”printk”是不会被发射的（应该是指不会进到CPU流水线）。生成的代码会是在直线代码路径中的一个原子的”no-op”指令（x86上为5字节）。当这个分支被翻转，这个直线代码路径中的”no-op”指令会被修改为始终跳转到原直线路径之外另一个分支的一个jump指令。虽然修改分支方向成本很高，但是分支选择操作几乎没有损失。这就是static key这个优化的代价和优点。</p>
<p>这里使用的底层补丁机制被称为”jump label patching”，它为static kyes功能提供了基础。</p>
<h2 id="jump-label"><a href="#jump-label" class="headerlink" title="jump label"></a>jump label</h2><p>jump label 提供了一个使用自修改代码生成动态分支的接口。假设工具链和体系结构支持，如果我们通过<code>&quot;DEFINE_STATIC_KEY_FALSE(key)&quot;</code>定义了一个初始值为false的key，那么<code>&quot;if (static_branch_unlikely(&amp;key))&quot;</code>语句就是一个无条件分支（默认为false，true代码块被放置在直线路径之外）。类似地，我们可以通过<code>&quot;DEFINE_STATIC_KEY_TRUE(key)&quot;</code>定义一个初始值为true的key，并在相同的<code>&quot;if (static_branch_unlikely(&amp;key))&quot;</code>中使用它，在这种情况下，我们将生成一个无条件的分支到直线路径之外的true分支。初始值为true或false的key都可以在<code>static_branch_unlikely()</code>和<code>static_branch_likely()</code>语句中使用。</p>
<p>运行时可以使用<code>static_branch_enable()</code>将key设置为true，或使用<code>static_branch_disable()</code>将key设置为false，以改变分支目标。如果这些调用改变了分支方向，则会在运行时通过no-op -&gt; jump或jump -&gt; no-op的转换修改分支目标。比如，对于在语句<code>&quot;if (static_branch_unlikely(&amp;key))&quot;</code>中使用的初始化为false的key，如果将key设置为true，则需要打上一个jump补丁指向直线路径之外的true分支。</p>
<p>除了<code>static_branch_{enable，disable}</code>，我们还可以通过<code>static_branch_{inc，dec}</code>引用key的计数或分支方向。<br>因此，<code>static_branch_inc()</code>可以被认为是’make more true’，而<code>static_branch_dec()</code>可以被认为是’make more false’。</p>
<p>由于依赖于修改代码， 一定要认识到修改分支的函数操作是非常慢的，比如做整个机器的同步。当然，由于受影响的分支是无条件判断的，运行时的开销会非常低，尤其是在默认的关闭情况下，所有的影响就是一个nop指令空间。开启的情况将会修改为一个跳转到直线路径之外的jump指令。</p>
<p>当控制操作直接向用户空间暴露时，一个明智的做法是延迟操作，以避免会导致明显性能下降的高频代码修改。结构体<code>static_key_deferred</code>和函数<code>static_key_slow_dec_deferred</code>提供了这种延迟操作。</p>
<p>当缺少工具链和体系结构支持时，jump label会退化为一个简单的条件分支。</p>
<h2 id="API及实现"><a href="#API及实现" class="headerlink" title="API及实现"></a>API及实现</h2><p>目前static keys存在新旧两套API，底层原理是一样的，分别记录一下。</p>
<h3 id="旧版API"><a href="#旧版API" class="headerlink" title="旧版API"></a>旧版API</h3><p>参考内核版本：3.10.0-862.el7.x86_64</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个结构体的变量必须是全局变量，不能是栈上的局部变量，不能是运行时动态分配出来的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">static_key</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体变量初始化方式，使用两个宏，未初始化的就默认是STATIC_KEY_INIT_FALSE</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">static_key</span> <span class="title">false</span> = <span class="title">STATIC_KEY_INIT_FALSE</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">static_key</span> <span class="title">true</span> = <span class="title">STATIC_KEY_INIT_TRUE</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码路径中做无损失分支判断的语句如下</span></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">bool</span> <span class="title">static_key_false</span><span class="params">(struct static_key *key)</span></span>;</span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">bool</span> <span class="title">static_key_true</span><span class="params">(struct static_key *key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这个判断无论是否启用jump label，都只有一种实现。这个条件检查，需要做内存检查。</span></span><br><span class="line"><span class="comment">// 一般使用在控制路径中判断当前状态，选择是否要对static_key做inc或dec操作。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">static_key_enabled</span><span class="params">(struct static_key *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (atomic_read(&amp;key-&gt;enabled) &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改分支方向的语句如下</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">static_key_slow_inc</span><span class="params">(struct static_key *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">static_key_slow_dec</span><span class="params">(struct static_key *key)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>static_key_false</code>、<code>static_key_true</code>，这两个api用于分支判断。<br>返回值的语义是相同的，都表示当前<code>static_key</code>是启用还是关闭，返回true表示<code>static_key</code>启用(也就是enabled大于0)，返回false表示<code>static_key</code>关闭(也就是enabled等于0)。<br>不同之处在于影响了编译生成的代码布局。<code>static_key_false</code>会将false的代码分支置于直线路径，<code>static_key_true</code>会true的代码分支置于直线路径。</p>
<p>当然这都是正确使用的情况下，正确使用就是：</p>
<ul>
<li><code>static_key_false</code>应该与<code>STATIC_KEY_INIT_FALSE</code>一起使用</li>
<li><code>static_key_true</code>应该与<code>STATIC_KEY_INIT_TRUE</code>一起使用</li>
</ul>
<p>错配使用会有不良后果，下面会详细说明。</p>
<p>这些api中<code>static_key_false</code>和<code>static_key_true</code>的意义不是很容易理解，因此先借助未启用jump label时的实现理解一下这两个api</p>
<h4 id="未启用jump-label时"><a href="#未启用jump-label时" class="headerlink" title="未启用jump label时"></a>未启用jump label时</h4><p>从未启用jump label的api看，<code>static_key_{false,true}</code>的返回值逻辑是一样的，均为enabled大于0时返回true。返回值表示了<code>static_key</code>是否启用，也就是当前状态下应该执行的代码分支。通过<code>likely</code>和<code>unlikely</code>，也就是gcc内建函数<code>__builtin_expect</code>，指导编译器对生成的指令布局做优化。</p>
<ul>
<li><code>static_key_false</code>用于该<code>static_key</code>大概率是关闭（对应初始化为关闭）的情况，该api返回false对应的代码分支在编译生成的二进制代码中是直线路径的。对应的初始化宏<code>STATIC_KEY_INIT_FALSE</code>。</li>
<li><code>static_key_true</code>用于该<code>static_key</code>大概率是开启（对应初始化为开启）的情况，该api返回true对应的代码分支在编译生成的二进制代码中是直线路径的。对应的初始化宏<code>STATIC_KEY_INIT_TRUE</code>。</li>
</ul>
<p>对于同一个<code>static_key</code>，这两个api是不应当混用的，初始化的值应该与大概率的分支匹配。如果错配使用，由于二进制代码中条件判断还在，只是损失性能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未启用jump label时，static_key只是atomic_t的一个包装</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">static_key</span> &#123;</span></span><br><span class="line">    <span class="keyword">atomic_t</span> enabled;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">bool</span> <span class="title">static_key_false</span><span class="params">(struct static_key *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(atomic_read(&amp;key-&gt;enabled)) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">bool</span> <span class="title">static_key_true</span><span class="params">(struct static_key *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (likely(atomic_read(&amp;key-&gt;enabled)) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// static_key的inc和dec操作。也就是单纯的对于atomic_t变量的操作了</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">static_key_slow_inc</span><span class="params">(struct static_key *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    STATIC_KEY_CHECK_USE();</span><br><span class="line">    atomic_inc(&amp;key-&gt;enabled);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">static_key_slow_dec</span><span class="params">(struct static_key *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    STATIC_KEY_CHECK_USE();</span><br><span class="line">    atomic_dec(&amp;key-&gt;enabled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量初始化的宏也很好理解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATIC_KEY_INIT_TRUE ((struct static_key) \</span></span><br><span class="line">        &#123; .enabled = ATOMIC_INIT(<span class="number">1</span>) &#125;)</span><br><span class="line">#define STATIC_KEY_INIT_FALSE ((struct static_key) \</span><br><span class="line">        &#123; .enabled = ATOMIC_INIT(<span class="number">0</span>) &#125;)</span><br></pre></td></tr></table></figure>
<p>关于<code>likely</code>和<code>unlikely</code>的影响，可以对比<code>likely</code>和<code>unlikely</code>时以下代码的反汇编内容，不需要执行，这里不多介绍了。</p>
<p>编译: <code>gcc -O2 main.c</code><br>反汇编: <code>objdump -d a.out</code></p>
<figure class="highlight c"><figcaption><span>main.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> likely(x)  __builtin_expect(!!(x), 1)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> unlikely(x)    __builtin_expect(!!(x), 0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    i = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (likely(i != <span class="number">2</span>)) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i %d\n"</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="已启用jump-label时"><a href="#已启用jump-label时" class="headerlink" title="已启用jump label时"></a>已启用jump label时</h4><h5 id="分支代码"><a href="#分支代码" class="headerlink" title="分支代码"></a>分支代码</h5><p>启用jump label时，<code>static_key_false</code>和<code>static_key_true</code>实现上均通过<code>arch_static_branch</code>做分支选择。</p>
<p>这两个api的语义和使用场景，与未启用jump label时是一样的，可以参考上面。对于同一个<code>static_key</code>，这两个api是不应当混用的，初始化的值应该与大概率的分支匹配。</p>
<p><code>static_key</code>的默认值与enabled值，同时作用影响分支判断处使用nop还是jump。相同则使用nop，不同则使用jump。比如默认true当前true则使用nop，默认true当前false则使用jump。</p>
<ul>
<li><code>static_key_false</code>生成的代码中，nop固定对应的是<code>static_key</code>的false分支代码，jump对应true分支代码。</li>
<li><code>static_key_true</code>生成的代码中，nop固定对应的是<code>static_key</code>的true分支代码，jump对应false分支代码。</li>
</ul>
<p>因此如果分支判断api与初始化值错配使用，会导致运行路径与<code>static_key</code>的值相反。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启用jump label的static_key</span></span><br><span class="line"><span class="comment">// atomic_t类型成员依然存在</span></span><br><span class="line"><span class="comment">// 多了jump_entry类型指针，指向jump_entry数组，用于遍历该static_key对应的所有分支代码的位置，也就是需要将指令修改为nop或jump的位置。</span></span><br><span class="line"><span class="comment">// 多了static_key_mod类型指针，这是一个链表，用于记录已加载的内核模块中使用该static_key位置和情况。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">static_key</span> &#123;</span></span><br><span class="line">    <span class="keyword">atomic_t</span> enabled;</span><br><span class="line"><span class="comment">/* Set lsb bit to 1 if branch is default true, 0 ot */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">jump_entry</span> *<span class="title">entries</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MODULES</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">static_key_mod</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">bool</span> <span class="title">static_key_false</span><span class="params">(struct static_key *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arch_static_branch(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">bool</span> <span class="title">static_key_true</span><span class="params">(struct static_key *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !static_key_false(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* We should be using ATOMIC_INIT() for initializing .enabled, but</span></span><br><span class="line"><span class="comment">* the inclusion of atomic.h is problematic for inclusion of jump_label.h</span></span><br><span class="line"><span class="comment">* in 'low-level' headers. Thus, we are initializing .enabled with a</span></span><br><span class="line"><span class="comment">* raw value, but have added a BUILD_BUG_ON() to catch any issues in</span></span><br><span class="line"><span class="comment">* jump_label_init() see: kernel/jump_label.c.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATIC_KEY_INIT_TRUE ((struct static_key) \</span></span><br><span class="line">    &#123; .enabled = &#123; <span class="number">1</span> &#125;, .entries = (<span class="keyword">void</span> *)<span class="number">1</span> &#125;)</span><br><span class="line">#define STATIC_KEY_INIT_FALSE ((struct static_key) \</span><br><span class="line">    &#123; .enabled = &#123; <span class="number">0</span> &#125;, .entries = (<span class="keyword">void</span> *)<span class="number">0</span> &#125;)</span><br></pre></td></tr></table></figure>
<p><code>arch_static_branch</code>的实现如下，这里有一段使用了asm goto的内联汇编代码</p>
<ul>
<li>当前地址生成5字节的nop指令</li>
<li>切换到段__jump_table，向其中推送3个64位数<ul>
<li>5字节nop指令的地址</li>
<li>C代码中l_yes这个label的地址，这个地址对应了返回true的分支</li>
<li>key的值，也就是<code>static_key</code>结构体的地址</li>
</ul>
</li>
<li>从段__jump_table返回到之前的段</li>
</ul>
<p>这段内联汇编结束后，返回false。编译器会根据该函数永远返回false将false分支的代码优化到直线路径中。<br>因此，<code>static_key_false</code>返回false对应的代码分支会位于直线路径中，<code>static_key_true</code>返回true对应的代码分支会位于直线路径中，与未启用jump label的版本逻辑一致。</p>
<figure class="highlight c"><figcaption><span>arch_static_branch</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> asm_volatile_goto(x...) do &#123; asm goto(x); asm (<span class="meta-string">""</span>); &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里只关注X86_64下</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P6_NOP5 0x0f,0x1f,0x44,0x00,0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P6_NOP5_ATOMIC P6_NOP5</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> STATIC_KEY_INIT_NOP P6_NOP5_ATOMIC</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">bool</span> <span class="title">arch_static_branch</span><span class="params">(struct static_key *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    asm_volatile_goto(<span class="string">"1:"</span></span><br><span class="line">        <span class="string">".byte "</span> __stringify(STATIC_KEY_INIT_NOP) <span class="string">"\n\t"</span></span><br><span class="line">        <span class="string">".pushsection __jump_table,  \"aw\" \n\t"</span></span><br><span class="line">        _ASM_ALIGN <span class="string">"\n\t"</span></span><br><span class="line">        _ASM_PTR <span class="string">"1b, %l[l_yes], %c0 \n\t"</span></span><br><span class="line">        <span class="string">".popsection \n\t"</span></span><br><span class="line">        : :  <span class="string">"i"</span> (key) : : l_yes);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">l_yes:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一个对应的汇编版本，逻辑是一样的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.macro STATIC_JUMP target, key</span><br><span class="line">.Lstatic_jump_\@:</span><br><span class="line">    .byte STATIC_KEY_INIT_NOP</span><br><span class="line">    .pushsection __jump_table, <span class="string">"aw"</span></span><br><span class="line">    _ASM_ALIGN</span><br><span class="line">    _ASM_PTR    .Lstatic_jump_\@, \target, \key</span><br><span class="line">    .popsection</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>
<p>一个正确使用static_key_false的例子，第二个printk未在直线路径中。<br><img src="//blog-image.hyuuhit.com/2025/05/static_key_1.png" alt=""><br><img src="//blog-image.hyuuhit.com/2025/05/static_key_2.png" alt=""></p>
<p>一个正确使用static_key_true的例子，第二个printk在直线路径中。<br>static_key的entries成员最低比特位是1表示默认值为真，实际使用该指针时需要将最低比特位修改为0使用。<br><img src="//blog-image.hyuuhit.com/2025/05/static_key_3.png" alt=""><br><img src="//blog-image.hyuuhit.com/2025/05/static_key_4.png" alt=""></p>
<p>一个错误使用static_key_true与STATIC_KEY_INIT_FALSE的例子<br>可以看到log_key初始化是关闭的，且未经过翻转分支方向，保持着关闭状态。<br>但由于static_key_true的使用，第二个printk位于直线路径中，且由于5字节nop指令的原因，这第二个printk会被执行。这与log_key的状态是相反的。<br><img src="//blog-image.hyuuhit.com/2025/05/static_key_5.png" alt=""><br><img src="//blog-image.hyuuhit.com/2025/05/static_key_6.png" alt=""></p>
<h5 id="jump-table-初始化"><a href="#jump-table-初始化" class="headerlink" title="jump table 初始化"></a>jump table 初始化</h5><p>前面提到每个用到<code>arch_static_branch</code>函数的地方都向段<code>__jump_table</code>中推送了3个64位数，对应的结构体<code>jump_entry</code>如下</p>
<figure class="highlight c"><figcaption><span>jump_entry</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> u64 <span class="keyword">jump_label_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个jump_entry对应一处分支判断代码</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">jump_entry</span> &#123;</span></span><br><span class="line">    <span class="keyword">jump_label_t</span> code;     <span class="comment">// nop指令的地址，也就是翻转分支方向时需要修改为jump的地址</span></span><br><span class="line">    <span class="keyword">jump_label_t</span> target;   <span class="comment">// 另一个分支的地址，就是翻转分支方向时jump指令要跳转到的地址</span></span><br><span class="line">    <span class="keyword">jump_label_t</span> key;      <span class="comment">// static_key结构体的地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>链接器脚本头文件include/asm-generic/vmlinux.lds.h中将所有目标文件中<code>__jump_table</code>段的内容按链接顺序集合到段.data中，也就是存储了一个<code>jump_entry</code>类型结构体数组，并且定义了两个符号，<code>__start___jump_table</code>和<code>__stop___jump_table</code>，用于记录这个结构体数组的起始地址和结束地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这个数组可以称为jump_label table或者jump table，虽然没有这个符号 */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">jump_entry</span> __<span class="title">start___jump_table</span>[];</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">jump_entry</span> __<span class="title">stop___jump_table</span>[];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对jump table的任何操作都要在这个锁的保护下 */</span></span><br><span class="line"><span class="comment">/* mutex to protect coming/going of the the jump_label table */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_MUTEX</span><span class="params">(jump_label_mutex)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数<code>jump_label_init</code>在<code>start_kernel</code>中被调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">init <span class="title">jump_label_init</span><span class="params">(<span class="keyword">void</span>)</span>                                        </span></span><br><span class="line"><span class="function"></span>&#123;                                                                        </span><br><span class="line">    <span class="comment">// 这两个变量记录jump table的首尾地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">jump_entry</span> *<span class="title">iter_start</span> = __<span class="title">start___jump_table</span>;</span>                </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">jump_entry</span> *<span class="title">iter_stop</span> = __<span class="title">stop___jump_table</span>;</span>                  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">static_key</span> *<span class="title">key</span> = <span class="title">NULL</span>;</span>                                       </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">jump_entry</span> *<span class="title">iter</span>;</span>                                             </span><br><span class="line">                                                                         </span><br><span class="line">    <span class="comment">// 编译期检查</span></span><br><span class="line">    <span class="comment">/*                                                                   </span></span><br><span class="line"><span class="comment">     * Since we are initializing the static_key.enabled field with       </span></span><br><span class="line"><span class="comment">     * with the 'raw' int values (to avoid pulling in atomic.h) in       </span></span><br><span class="line"><span class="comment">     * jump_label.h, let's make sure that is safe. There are only two    </span></span><br><span class="line"><span class="comment">     * cases to check since we initialize to 0 or 1.                     </span></span><br><span class="line"><span class="comment">     */</span>                                                                  </span><br><span class="line">    BUILD_BUG_ON((<span class="keyword">int</span>)ATOMIC_INIT(<span class="number">0</span>) != <span class="number">0</span>);                              </span><br><span class="line">    BUILD_BUG_ON((<span class="keyword">int</span>)ATOMIC_INIT(<span class="number">1</span>) != <span class="number">1</span>);                              </span><br><span class="line">                                                                         </span><br><span class="line">    <span class="comment">// 对jump table任何操作都需要上锁jump_label_mutex</span></span><br><span class="line">    jump_label_lock();                                                   </span><br><span class="line">    <span class="comment">// 对jump table中的所有jump_entry结构体以static_key地址做排序。也就是将同一个static_key的所有jump_entry聚集起来</span></span><br><span class="line">    jump_label_sort_entries(iter_start, iter_stop);                      </span><br><span class="line">                                                                         </span><br><span class="line">    <span class="keyword">for</span> (iter = iter_start; iter &lt; iter_stop; iter++) &#123;                  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">static_key</span> *<span class="title">iterk</span>;</span>                                        </span><br><span class="line">                                                                         </span><br><span class="line">        iterk = (struct static_key *)(<span class="keyword">unsigned</span> <span class="keyword">long</span>)iter-&gt;key;           </span><br><span class="line">        <span class="comment">// jump_label_type函数获取分支处应该写入的指令类型，nop或jump</span></span><br><span class="line">        <span class="comment">// arch_jump_label_transform_static函数将分支处写入具体指令</span></span><br><span class="line">        arch_jump_label_transform_static(iter, jump_label_type(iterk));  </span><br><span class="line">        <span class="comment">// static_key的entries只需要写一次，iterk与key相同说明该static_key已经写过entries，对应的jump_entry数组在遍历中</span></span><br><span class="line">        <span class="keyword">if</span> (iterk == key)                                                </span><br><span class="line">            <span class="keyword">continue</span>;                                                    </span><br><span class="line">                                                                         </span><br><span class="line">        <span class="comment">// 遇到了新的static_key，说明遍历到了新的static_key对应的jump_entry数组了</span></span><br><span class="line">        key = iterk;                                                     </span><br><span class="line">        <span class="comment">/*                                                               </span></span><br><span class="line"><span class="comment">         * Set key-&gt;entries to iter, but preserve JUMP_LABEL_TRUE_BRANCH.</span></span><br><span class="line"><span class="comment">         */</span>                                                              </span><br><span class="line">        <span class="comment">// 使用entries记录该static_key对应的jump_entry数组的首地址。entries的最低比特位用于标示默认值，这个最低比特位原值依然保留。</span></span><br><span class="line">        *((<span class="keyword">unsigned</span> <span class="keyword">long</span> *)&amp;key-&gt;entries) += (<span class="keyword">unsigned</span> <span class="keyword">long</span>)iter;        </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MODULES                                                    </span></span><br><span class="line">        <span class="comment">// 初始化阶段，还没有其他内核模块加载进来，也就没有其他内核模块使用内核内置的static_key</span></span><br><span class="line">        key-&gt;next = <span class="literal">NULL</span>;                                                </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>                                                                   </span></span><br><span class="line">    &#125;                                                                    </span><br><span class="line">    <span class="comment">// 该变量用于在运行时检查并警告jump_label_init完成初始化前对static_key发起的操作。</span></span><br><span class="line">    static_key_initialized = <span class="literal">true</span>;                                       </span><br><span class="line">    jump_label_unlock();                                                 </span><br><span class="line">&#125;                                                                        </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">enum</span> jump_label_type <span class="title">jump_label_type</span><span class="params">(struct static_key *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;                                                                  </span><br><span class="line">    <span class="comment">// 获取static_key的默认分支，也就是初始化时的分支</span></span><br><span class="line">    <span class="keyword">bool</span> true_branch = jump_label_get_branch_default(key);         </span><br><span class="line">    <span class="comment">// 获取static_key成员enabled计数，大于0为true，等于0为false，这个是当前应该执行的代码分支</span></span><br><span class="line">    <span class="keyword">bool</span> state = static_key_enabled(key);                          </span><br><span class="line">                                                                   </span><br><span class="line">    <span class="comment">// 默认分支对应的是nop指令的直线路径，如果默认分支与当前应该执行的分支不同，说明需要将分支代码写为jump，也就是启用jump，执行非默认代码分支</span></span><br><span class="line">    <span class="keyword">if</span> ((!true_branch &amp;&amp; state) || (true_branch &amp;&amp; !state))        </span><br><span class="line">        <span class="keyword">return</span> JUMP_LABEL_ENABLE;                                  </span><br><span class="line">                                                                   </span><br><span class="line">    <span class="comment">// 默认分支与当前应该执行的分支相同，说明需要将分支代码写为nop，就是关闭jump，执行默认代码分支</span></span><br><span class="line">    <span class="keyword">return</span> JUMP_LABEL_DISABLE;                                     </span><br><span class="line">&#125;                                                                  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据传入的参数将对应分支位置写入nop或jump指令</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __jump_label_transform(struct jump_entry *entry,               </span><br><span class="line">                   <span class="keyword">enum</span> jump_label_type type,                              </span><br><span class="line">                   <span class="keyword">void</span> *(*poker)(<span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *, <span class="keyword">size_t</span>))           </span><br><span class="line">&#123;                                                                          </span><br><span class="line">    <span class="keyword">union</span> jump_code_union code;                                            </span><br><span class="line">                                                                           </span><br><span class="line">    <span class="keyword">if</span> (type == JUMP_LABEL_ENABLE) &#123;                                       </span><br><span class="line">        code.jump = <span class="number">0xe9</span>;                                                  </span><br><span class="line">        code.offset = entry-&gt;target -                                      </span><br><span class="line">                (entry-&gt;code + JUMP_LABEL_NOP_SIZE);                       </span><br><span class="line">    &#125; <span class="keyword">else</span>                                                                 </span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;code, ideal_nops[NOP_ATOMIC5], JUMP_LABEL_NOP_SIZE);       </span><br><span class="line">                                                                           </span><br><span class="line">    <span class="comment">/*                                                                     </span></span><br><span class="line"><span class="comment">     * Make text_poke_bp() a default fallback poker.                       </span></span><br><span class="line"><span class="comment">     *                                                                     </span></span><br><span class="line"><span class="comment">     * At the time the change is being done, just ignore whether we        </span></span><br><span class="line"><span class="comment">     * are doing nop -&gt; jump or jump -&gt; nop transition, and assume         </span></span><br><span class="line"><span class="comment">     * always nop being the 'currently valid' instruction                  </span></span><br><span class="line"><span class="comment">     *                                                                     </span></span><br><span class="line"><span class="comment">     */</span>                                                                    </span><br><span class="line">    <span class="keyword">if</span> (poker)                                                             </span><br><span class="line">        (*poker)((<span class="keyword">void</span> *)entry-&gt;code, &amp;code, JUMP_LABEL_NOP_SIZE);         </span><br><span class="line">    <span class="keyword">else</span>                                                                   </span><br><span class="line">        text_poke_bp((<span class="keyword">void</span> *)entry-&gt;code, &amp;code, JUMP_LABEL_NOP_SIZE,      </span><br><span class="line">                 (<span class="keyword">void</span> *)entry-&gt;code + JUMP_LABEL_NOP_SIZE);               </span><br><span class="line">&#125;                                                                          </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arch_jump_label_transform</span><span class="params">(struct jump_entry *entry,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">enum</span> jump_label_type type)</span>           </span></span><br><span class="line"><span class="function"></span>&#123;                                                       </span><br><span class="line">    get_online_cpus();                                  </span><br><span class="line">    mutex_lock(&amp;text_mutex);                            </span><br><span class="line">    __jump_label_transform(entry, type, <span class="literal">NULL</span>);          </span><br><span class="line">    mutex_unlock(&amp;text_mutex);                          </span><br><span class="line">    put_online_cpus();                                  </span><br><span class="line">&#125;                                                       </span><br><span class="line"></span><br><span class="line">__<span class="function">init_or_module <span class="keyword">void</span> <span class="title">arch_jump_label_transform_static</span><span class="params">(struct jump_entry *entry,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">enum</span> jump_label_type type)</span>                                </span></span><br><span class="line"><span class="function"></span>&#123;                                                                               </span><br><span class="line">    __jump_label_transform(entry, type, text_poke_early);                       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="分支控制"><a href="#分支控制" class="headerlink" title="分支控制"></a>分支控制</h5><p>static_key_slow_inc，这个api用于增加static_key的计数，计数可以累计，大于0时代码执行true分支。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">static_key_slow_inc</span><span class="params">(struct static_key *key)</span>             </span></span><br><span class="line"><span class="function"></span>&#123;                                                            </span><br><span class="line">    STATIC_KEY_CHECK_USE();</span><br><span class="line">    <span class="comment">// 返回非0，说明旧值非0，因此不需要翻转分支方向，且计数已经增加了。函数返回即可。                                  </span></span><br><span class="line">    <span class="keyword">if</span> (atomic_inc_not_zero(&amp;key-&gt;enabled))                  </span><br><span class="line">        <span class="keyword">return</span>;                                              </span><br><span class="line">    <span class="comment">// 上一步返回0，说明旧值为0，因此未增加计数。函数继续运行。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对jump table的所有操作都需要上锁</span></span><br><span class="line">    jump_label_lock();</span><br><span class="line">    <span class="comment">// 如果上锁后读取到的非0，说明执行间隙有其他路径已经改写了计数，操作了分支方向，因此本路径不需要再操作分支方向了。                                       </span></span><br><span class="line">    <span class="keyword">if</span> (atomic_read(&amp;key-&gt;enabled) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果默认分支是false，说明nop路径为false分支。当前enabled是0，说明当前是false分支，要从0变成1，就是要启用true分支，需要翻转分支方向，将分支处代码修改为jump，也就是启用jump</span></span><br><span class="line">        <span class="comment">// 如果默认分支是true，说明nop路径为true分支。当前enabled是0，说明当前是false分支，要从0变成1，就是要启用true分支，需要翻转分支方向，将分支代码修改为nop，也就是关闭jump</span></span><br><span class="line">        <span class="keyword">if</span> (!jump_label_get_branch_default(key))             </span><br><span class="line">            jump_label_update(key, JUMP_LABEL_ENABLE);       </span><br><span class="line">        <span class="keyword">else</span>                                                 </span><br><span class="line">            jump_label_update(key, JUMP_LABEL_DISABLE);      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为本次操作增加计数。                                                        </span></span><br><span class="line">    atomic_inc(&amp;key-&gt;enabled);                               </span><br><span class="line">    jump_label_unlock();                                     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __jump_label_update(struct static_key *key,                </span><br><span class="line">                struct jump_entry *entry,                              </span><br><span class="line">                struct jump_entry *stop, <span class="keyword">int</span> enable)                   </span><br><span class="line">&#123;                                                                      </span><br><span class="line">    <span class="comment">// 遍历有两个结束条件，1是遍历到了jump table的末尾，2是遍历到了其他static_key对应的jump_entry</span></span><br><span class="line">    <span class="keyword">for</span> (; (entry &lt; stop) &amp;&amp;                                           </span><br><span class="line">          (entry-&gt;key == (<span class="keyword">jump_label_t</span>)(<span class="keyword">unsigned</span> <span class="keyword">long</span>)key);            </span><br><span class="line">          entry++) &#123;                                                   </span><br><span class="line">        <span class="comment">/*                                                             </span></span><br><span class="line"><span class="comment">         * entry-&gt;code set to 0 invalidates module init text sections  </span></span><br><span class="line"><span class="comment">         * kernel_text_address() verifies we are not in core kernel    </span></span><br><span class="line"><span class="comment">         * init code, see jump_label_invalidate_module_init().         </span></span><br><span class="line"><span class="comment">         */</span>                                                            </span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;code) &#123;                                             </span><br><span class="line">            <span class="keyword">if</span> (kernel_text_address(entry-&gt;code))                      </span><br><span class="line">                arch_jump_label_transform(entry, enable);              </span><br><span class="line">            <span class="keyword">else</span>                                                       </span><br><span class="line">                WARN(<span class="number">1</span>, <span class="string">"can't patch jump_label at 0x%lx\n"</span>,           </span><br><span class="line">                     (<span class="keyword">unsigned</span> <span class="keyword">long</span>)entry-&gt;code);                      </span><br><span class="line">        &#125;                                                              </span><br><span class="line">    &#125;                                                                  </span><br><span class="line">&#125;                                                                      </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">jump_label_update</span><span class="params">(struct static_key *key, <span class="keyword">int</span> enable)</span>       </span></span><br><span class="line"><span class="function"></span>&#123;                                                                       </span><br><span class="line">    <span class="comment">// jump table的末尾地址，确定数组边界</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">jump_entry</span> *<span class="title">stop</span> = __<span class="title">stop___jump_table</span>;</span>                      </span><br><span class="line">    <span class="comment">// 拿到static_key的entries字段，也就是这个static_key对应的jump_entry数组的起始地址，返回地址的最低比特位已经清零了</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">jump_entry</span> *<span class="title">entry</span> = <span class="title">jump_label_get_entries</span>(<span class="title">key</span>);</span>             </span><br><span class="line">                                                                        </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MODULES                                                   </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">mod</span> = __<span class="title">module_address</span>((<span class="title">unsigned</span> <span class="title">long</span>)<span class="title">key</span>);</span>          </span><br><span class="line">                                                                        </span><br><span class="line">    __jump_label_mod_update(key, enable);                               </span><br><span class="line">                                                                        </span><br><span class="line">    <span class="keyword">if</span> (mod)                                                            </span><br><span class="line">        stop = mod-&gt;jump_entries + mod-&gt;num_jump_entries;               </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>                                                                  </span></span><br><span class="line">    <span class="comment">/* if there are no users, entry can be NULL */</span>                      </span><br><span class="line">    <span class="comment">// 检查这个static_key是有被使用的</span></span><br><span class="line">    <span class="keyword">if</span> (entry)                                                          </span><br><span class="line">        __jump_label_update(key, entry, stop, enable);                  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>static_key_slow_dec，这个api用于减少static_key的计数，计数可以累计，但是不应该小于0，大于0时代码执行true分支。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __static_key_slow_dec(struct static_key *key,               </span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> rate_limit, struct delayed_work *work)            </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 返回false说明计数减1后仍不为0，也未持有锁。因此不需要翻转分支方向。</span></span><br><span class="line">    <span class="comment">// 返回true说明计数减1后已经为0，且持有锁。需要操作分支方向了。</span></span><br><span class="line">    <span class="keyword">if</span> (!atomic_dec_and_mutex_lock(&amp;key-&gt;enabled, &amp;jump_label_mutex)) &#123;</span><br><span class="line">        WARN(atomic_read(&amp;key-&gt;enabled) &lt; <span class="number">0</span>,                            </span><br><span class="line">             <span class="string">"jump label: negative count!\n"</span>);                          </span><br><span class="line">        <span class="keyword">return</span>;                                                         </span><br><span class="line">    &#125;                                                                   </span><br><span class="line">                                                                        </span><br><span class="line">    <span class="keyword">if</span> (rate_limit) &#123;</span><br><span class="line">        <span class="comment">// rate_limit这个先不管了        </span></span><br><span class="line">        atomic_inc(&amp;key-&gt;enabled);                                      </span><br><span class="line">        schedule_delayed_work(work, rate_limit);                        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果默认分支是false，说明nop路径为false分支。当前enabled刚刚从1减到了0，说明需要从true分支变更为false分支，需要将分支处代码修改为nop，也就是关闭jump</span></span><br><span class="line">        <span class="comment">// 如果默认分支是true，说明nop路径为true分支。当前enabled刚刚从1减到了0，说明需要从true分支变更为false分支，需要将分支处代码修改为jump，也就是启用jump</span></span><br><span class="line">        <span class="keyword">if</span> (!jump_label_get_branch_default(key))                        </span><br><span class="line">            jump_label_update(key, JUMP_LABEL_DISABLE);                 </span><br><span class="line">        <span class="keyword">else</span>                                                            </span><br><span class="line">            jump_label_update(key, JUMP_LABEL_ENABLE);                  </span><br><span class="line">    &#125;                                                                   </span><br><span class="line">    jump_label_unlock();                                                </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">static_key_slow_dec</span><span class="params">(struct static_key *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;                                               </span><br><span class="line">    STATIC_KEY_CHECK_USE();                     </span><br><span class="line">    __static_key_slow_dec(key, <span class="number">0</span>, <span class="literal">NULL</span>);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="新版API"><a href="#新版API" class="headerlink" title="新版API"></a>新版API</h3><p>参考内核版本：4.18.0-193.el8.x86_64</p>
<p>新版本内核中，不推荐使用旧版api，包括</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">static_key</span> <span class="title">false</span> = <span class="title">STATIC_KEY_INIT_FALSE</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">static_key</span> <span class="title">true</span> = <span class="title">STATIC_KEY_INIT_TRUE</span>;</span></span><br><span class="line">static_key_true()</span><br><span class="line">static_key_false()</span><br></pre></td></tr></table></figure>
<p>推荐使用新版api，比如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_STATIC_KEY_TRUE(key);</span><br><span class="line">DEFINE_STATIC_KEY_FALSE(key);</span><br><span class="line">DEFINE_STATIC_KEY_ARRAY_TRUE(keys, count);</span><br><span class="line">DEFINE_STATIC_KEY_ARRAY_FALSE(keys, count);</span><br><span class="line">static_branch_likely()</span><br><span class="line">static_branch_unlikely()</span><br></pre></td></tr></table></figure>
<p>前面提到旧版的api中<code>static_key</code>成员enabled大于0时，代码的运行路径应该是<code>static_key_{false,true}</code>返回值为true的代码路径。<br>而且<code>static_key_false</code>需要与<code>STATIC_KEY_INIT_FALSE</code>一起使用，<code>static_key_true</code>需要与<code>STATIC_KEY_INIT_TRUE</code>一起使用，不能错配使用。<br>如果错配使用，在启用jump label时会发生代码运行路径与enabled值不符的情况。</p>
<p>新版api解决了这个问题。使用新版api时，无论初始化值是什么，<code>static_branch_{likely,unlikely}</code>返回true的代码路径均可以在enabled大于0时运行。</p>
<p>看一下新版api做了什么</p>
<p><code>static_key</code>结构体布局有了一点小变动，为了在没有外部模块引用该<code>static_key</code>时减少一个next指针的内存占用，如果有外部模块引用就额外分配一个<code>static_key_mod</code>结构体用来存储原始的entries，具体可以参考函数<code>jump_label_add_module</code>的实现，这个变动不影响对新版api的理解。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">static_key</span> &#123;</span></span><br><span class="line">    <span class="keyword">atomic_t</span> enabled;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Note:</span></span><br><span class="line"><span class="comment"> *   To make anonymous unions work with old compilers, the static</span></span><br><span class="line"><span class="comment"> *   initialization of them requires brackets. This creates a dependency</span></span><br><span class="line"><span class="comment"> *   on the order of the struct with the initializers. If any fields</span></span><br><span class="line"><span class="comment"> *   are added, STATIC_KEY_INIT_TRUE and STATIC_KEY_INIT_FALSE may need</span></span><br><span class="line"><span class="comment"> *   to be modified.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * bit 0 =&gt; 1 if key is initially true</span></span><br><span class="line"><span class="comment"> *      0 if initially false</span></span><br><span class="line"><span class="comment"> * bit 1 =&gt; 1 if points to struct static_key_mod</span></span><br><span class="line"><span class="comment"> *      0 if points to struct jump_entry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> type;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">jump_entry</span> *<span class="title">entries</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">static_key_mod</span> *<span class="title">next</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>重点是增加了两个包装的结构体类型，推荐的宏定义通过使用这两个结构体类型，可以在编译时识别到<code>static_key</code>初始化值的分支是true还是false，并记录到jump_entry的key成员最低比特位上用于运行时识别。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Two type wrappers around static_key, such that we can use compile time</span></span><br><span class="line"><span class="comment"> * type differentiation to emit the right code.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * All the below code is macros in order to play type games.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">static_key_true</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">static_key</span> <span class="title">key</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">static_key_false</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">static_key</span> <span class="title">key</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATIC_KEY_TRUE_INIT  (struct static_key_true) &#123; .key = STATIC_KEY_INIT_TRUE,  &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATIC_KEY_FALSE_INIT (struct static_key_false)&#123; .key = STATIC_KEY_INIT_FALSE, &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_STATIC_KEY_TRUE(name)    \</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">static_key_true</span> <span class="title">name</span> = <span class="title">STATIC_KEY_TRUE_INIT</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">#<span class="title">define</span> <span class="title">DEFINE_STATIC_KEY_FALSE</span>(<span class="title">name</span>)   \</span></span><br><span class="line"><span class="class">    <span class="title">struct</span> <span class="title">static_key_false</span> <span class="title">name</span> = <span class="title">STATIC_KEY_FALSE_INIT</span></span></span><br></pre></td></tr></table></figure>
<p>比如：</p>
<p>static_branch_likely</p>
<ul>
<li>使true分支代码块位于nop直线路径中，初始值为true时，初始执行true分支，分支位置填充nop</li>
<li>使true分支代码块位于nop直线路径中，初始值为false时，初始执行false分支，分支位置填充jump</li>
<li>同时为jump_entry的key成员最低比特位置1，用于标记该分支nop直线路径对应true分支</li>
</ul>
<p>static_branch_unlikely</p>
<ul>
<li>使true分支代码块位于jump路径中，初始值为true时，初始执行true分支，分支位置填充jump</li>
<li>使true分支代码块位于jump路径中，初始值为false时，初始执行false分支，分支位置填充nop</li>
<li>同时为jump_entry的key成员最低比特位置0，用于标记该分支nop直线路径对应false分支</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> static_branch_likely(x)                         \</span></span><br><span class="line">(&#123;                                      \</span><br><span class="line">    <span class="keyword">bool</span> branch;                                \</span><br><span class="line">    <span class="keyword">if</span> (__builtin_types_compatible_p(typeof(*x), struct static_key_true))   \</span><br><span class="line">        branch = !arch_static_branch(&amp;(x)-&gt;key, <span class="literal">true</span>);          \</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (__builtin_types_compatible_p(typeof(*x), struct static_key_false)) \</span><br><span class="line">        branch = !arch_static_branch_jump(&amp;(x)-&gt;key, <span class="literal">true</span>);     \</span><br><span class="line">    <span class="keyword">else</span>                                    \</span><br><span class="line">        branch = ____wrong_branch_error();              \</span><br><span class="line">    likely(branch);                             \</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> static_branch_unlikely(x)                       \</span></span><br><span class="line">(&#123;                                      \</span><br><span class="line">    <span class="keyword">bool</span> branch;                                \</span><br><span class="line">    <span class="keyword">if</span> (__builtin_types_compatible_p(typeof(*x), struct static_key_true))   \</span><br><span class="line">        branch = arch_static_branch_jump(&amp;(x)-&gt;key, <span class="literal">false</span>);     \</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (__builtin_types_compatible_p(typeof(*x), struct static_key_false)) \</span><br><span class="line">        branch = arch_static_branch(&amp;(x)-&gt;key, <span class="literal">false</span>);          \</span><br><span class="line">    <span class="keyword">else</span>                                    \</span><br><span class="line">        branch = ____wrong_branch_error();              \</span><br><span class="line">    unlikely(branch);                           \</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>jump_label_type</code>函数依然用于判断分支处应该使用nop还是jump，其实现方式也对应变更了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> static_key_enabled(x)                           \                     </span></span><br><span class="line">(&#123;                                      \                                     </span><br><span class="line">    <span class="keyword">if</span> (!__builtin_types_compatible_p(typeof(*x), struct static_key) &amp;&amp; \     </span><br><span class="line">        !__builtin_types_compatible_p(typeof(*x), struct static_key_true) &amp;&amp;\ </span><br><span class="line">        !__builtin_types_compatible_p(typeof(*x), struct static_key_false)) \ </span><br><span class="line">        ____wrong_branch_error();                   \                         </span><br><span class="line">    static_key_count((struct static_key *)x) &gt; <span class="number">0</span>;               \             </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">jump_entry_is_branch</span><span class="params">(<span class="keyword">const</span> struct jump_entry *entry)</span></span></span><br><span class="line"><span class="function"></span>&#123;                                                                      </span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>)entry-&gt;key &amp; <span class="number">1U</span>L;                            </span><br><span class="line">&#125;                                                                                                                                                  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">enum</span> jump_label_type <span class="title">jump_label_type</span><span class="params">(struct jump_entry *entry)</span></span></span><br><span class="line"><span class="function"></span>&#123;                                                                    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">static_key</span> *<span class="title">key</span> = <span class="title">jump_entry_key</span>(<span class="title">entry</span>);</span>                  </span><br><span class="line">    <span class="keyword">bool</span> enabled = static_key_enabled(key);                          </span><br><span class="line">    <span class="keyword">bool</span> branch = jump_entry_is_branch(entry);                       </span><br><span class="line">                                                                     </span><br><span class="line">    <span class="comment">/* See the comment in linux/jump_label.h */</span>                      </span><br><span class="line">    <span class="keyword">return</span> enabled ^ branch;                                         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>static_key_{false,true}</code>这两个旧api的实现也兼容了新的实现方式。逻辑与旧版实现一致。依然不支持与错配初始化值使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">bool</span> <span class="title">static_key_false</span><span class="params">(struct static_key *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arch_static_branch(key, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">bool</span> <span class="title">static_key_true</span><span class="params">(struct static_key *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !arch_static_branch(key, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有两组分支控制操作，区别在于是否支持计数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Advanced usage; refcount, branch is enabled when: count != 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> static_branch_inc(x)        static_key_slow_inc(&amp;(x)-&gt;key)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> static_branch_dec(x)        static_key_slow_dec(&amp;(x)-&gt;key)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> static_branch_inc_cpuslocked(x) static_key_slow_inc_cpuslocked(&amp;(x)-&gt;key)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> static_branch_dec_cpuslocked(x) static_key_slow_dec_cpuslocked(&amp;(x)-&gt;key)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Normal usage; boolean enable/disable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> static_branch_enable(x)         static_key_enable(&amp;(x)-&gt;key)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> static_branch_disable(x)        static_key_disable(&amp;(x)-&gt;key)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> static_branch_enable_cpuslocked(x)  static_key_enable_cpuslocked(&amp;(x)-&gt;key)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> static_branch_disable_cpuslocked(x) static_key_disable_cpuslocked(&amp;(x)-&gt;key)</span></span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/linux/">linux</a></div><div class="post-nav"><a class="pre" href="/2025/06/02/stop-machine/">stop_machine 实现</a><a class="next" href="/2025/04/30/initcall/">initcall 机制</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://www.hyuuhit.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/libvirt/">libvirt</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/suricata/">suricata</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/vmware/" style="font-size: 15px;">vmware</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/06/02/stop-machine/">stop_machine 实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/05/05/static-key-jump-label/">static key & jump label</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/30/initcall/">initcall 机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/07/cn-proc-example/">cn_proc 进程事件连接器</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/04/executable-shared-library/">可执行的动态链接库</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/05/26/dirpro-bug-analysis/">一次无源码Linux内核模块bug分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/05/13/elrepo-not-for-production-use/">为什么生产环境服务器不应该使用ELRepo内核</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/04/29/memory-consistency-model-memory-barrier-and-sychronization/">内存一致性模型、内存屏障与同步</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/04/11/rcu-usage/">抢占式RCU与RCU使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/09/16/tc-tbf-qdisc/">tc tbf qdisc 令牌桶过滤器限速队列</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">属乌鸦的.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>