<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="huyu's blog | Linux"><title>stop_machine 实现 | 属乌鸦的</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-129648993-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '85d80db9310fa34ab2f7d34beeff589b';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">stop_machine 实现</h1><a id="logo" href="/.">属乌鸦的</a><p class="description">无知 &amp; 聒噪</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">stop_machine 实现</h1><div class="post-meta">Jun 2, 2025</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#关系图"><span class="toc-number">1.</span> <span class="toc-text">关系图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#相关结构体及变量"><span class="toc-number">2.</span> <span class="toc-text">相关结构体及变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#migration线程初始化"><span class="toc-number">3.</span> <span class="toc-text">migration线程初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stop-machine调用"><span class="toc-number">4.</span> <span class="toc-text">stop_machine调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#回到migration线程"><span class="toc-number">5.</span> <span class="toc-text">回到migration线程</span></a></li></ol></div></div><div class="post-content"><p><code>stop_machine</code>用于停止整个机器。该调用会在每个CPU上调度一个内核线程，每个内核线程都会禁用中断，并在所有CPU都禁用中断状态下由一个或指定范围的CPU执行由参数传入的函数指针。函数指针执行时，所有的CPU都不会持有自旋锁或处于关闭抢占区域。</p>
<a id="more"></a>
<p>代码内核版本: 3.10.0-862.el7.x86_64。只关注配置了CONFIG_STOP_MACHINE及CONFIG_SMP的情况</p>
<p>内核线程部分可参考<a href="/2018/08/03/linux-kernel-thread/">Linux kernel thread 内核线程</a></p>
<h2 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h2><p><img src="//blog-image.hyuuhit.com/2025/06/stop_machine.jpg" alt="stop_machine"></p>
<h2 id="相关结构体及变量"><a href="#相关结构体及变量" class="headerlink" title="相关结构体及变量"></a>相关结构体及变量</h2><p><code>cpu_stopper</code>，percpu变量，也就是每个CPU有自己的一块内存，每个percpu变量在每块内存有固定的偏移地址。<br>比如<code>smp_hotplug_thread</code>结构体变量中成员<code>store</code>存储的就是<code>cpu_stopper.thread</code>的内存在每块percpu内存的偏移地址。</p>
<figure class="highlight c"><figcaption><span>cpu_stopper</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* the actual stopper, one per every possible cpu, enabled on online cpus */</span>   </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu_stopper</span> &#123;</span>                                                           </span><br><span class="line">    <span class="comment">// 每个cpu对应的内核线程，名字为"migration/序号"</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>  *<span class="title">thread</span>;</span>                                               </span><br><span class="line">                                                                               </span><br><span class="line">    <span class="keyword">spinlock_t</span>      lock;                                                      </span><br><span class="line">    <span class="keyword">bool</span>            enabled;    <span class="comment">/* is this stopper enabled? */</span>                 </span><br><span class="line">    <span class="comment">// 排队等待执行的work链表，由上面lock保护</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">works</span>;</span>      <span class="comment">/* list of pending works */</span>                </span><br><span class="line">                                                                               </span><br><span class="line">    <span class="comment">// stop_cpus使用该成员挂载到works链表，被stop_cpus_mutex保护</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu_stop_work</span>    <span class="title">stop_work</span>;</span>  <span class="comment">/* for stop_cpus */</span>                    </span><br><span class="line">&#125;;                                                                             </span><br><span class="line">                                                                               </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_PER_CPU</span><span class="params">(struct cpu_stopper, cpu_stopper)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>smp_hotplug_thread</code>这个结构体是一个CPU热插拔相关的线程描述，随着CPU热插拔而为每个CPU对应创建或销毁一个内核线程。<br>比如这里用到的migration线程，其他的比如ksoftirqd、watchdog等。<br>这里的各个回调函数在percpu线程各个阶段会被调用到。</p>
<figure class="highlight c"><figcaption><span>cpu_stop_threads</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">smp_hotplug_thread</span> <span class="title">cpu_stop_threads</span> = &#123;</span></span><br><span class="line">    .store          = &amp;cpu_stopper.thread,           </span><br><span class="line">    .thread_should_run  = cpu_stop_should_run,       </span><br><span class="line">    .thread_fn      = cpu_stopper_thread,            </span><br><span class="line">    .thread_comm        = <span class="string">"migration/%u"</span>,            </span><br><span class="line">    .create         = cpu_stop_create,               </span><br><span class="line">    .setup          = cpu_stop_unpark,               </span><br><span class="line">    .park           = cpu_stop_park,                 </span><br><span class="line">    .pre_unpark     = cpu_stop_unpark,               </span><br><span class="line">    .selfparking        = <span class="literal">true</span>,                      </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>stop_machine</code>参数中的fn、data、cpus设置进msdata的fn、data、active_cpus</p>
<figure class="highlight c"><figcaption><span>multi_stop_data变量名一般为msdata</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">multi_stop_data</span> &#123;</span>                                                   </span><br><span class="line">    <span class="keyword">int</span>         (*fn)(<span class="keyword">void</span> *);                                             </span><br><span class="line">    <span class="keyword">void</span>            *data;                                                 </span><br><span class="line">    <span class="comment">/* Like num_online_cpus(), but hotplug cpu uses us, so we need this. */</span></span><br><span class="line">    <span class="comment">// 记录需要停止的cpu数量，用于multi_stop_cpu中简单状态机每次状态更新后对thread_ack的重置</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        num_threads;                                       </span><br><span class="line">    <span class="comment">// active_cpus用掩码表示需要执行fn的cpu范围，这个与需要停止的cpu范围不同。</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span>    *<span class="title">active_cpus</span>;</span>                                  </span><br><span class="line">                                                                           </span><br><span class="line">    <span class="comment">// 状态机的当前状态</span></span><br><span class="line">    <span class="keyword">enum</span> multi_stop_state   state;                                         </span><br><span class="line">    <span class="comment">// 记录当前状态下剩余的cpu数量，最后一个度过当前状态的cpu负责更新状态和thread_ack重置</span></span><br><span class="line">    <span class="keyword">atomic_t</span>        thread_ack;                                            </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="migration线程初始化"><a href="#migration线程初始化" class="headerlink" title="migration线程初始化"></a>migration线程初始化</h2><p><code>stop_machine</code>相关的初始化由函数<code>cpu_stop_init</code>完成</p>
<figure class="highlight c"><figcaption><span>cpu_stop_init</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">cpu_stop_init</span><span class="params">(<span class="keyword">void</span>)</span>                             </span></span><br><span class="line"><span class="function"></span>&#123;                                                                 </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> cpu;                                             </span><br><span class="line">                                                                  </span><br><span class="line">    <span class="comment">// 遍历每个可能的CPU，为per_cpu变量cpu_stopper做初始化</span></span><br><span class="line">    for_each_possible_cpu(cpu) &#123;                                  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cpu_stopper</span> *<span class="title">stopper</span> = &amp;<span class="title">per_cpu</span>(<span class="title">cpu_stopper</span>, <span class="title">cpu</span>);</span></span><br><span class="line">                                                                  </span><br><span class="line">        spin_lock_init(&amp;stopper-&gt;lock);                           </span><br><span class="line">        INIT_LIST_HEAD(&amp;stopper-&gt;works);                          </span><br><span class="line">    &#125;                                                             </span><br><span class="line">    <span class="comment">// 注册percpu线程，并为每个CPU启动对应线程。后续出现CPU热插拔也会对应处理</span></span><br><span class="line">    BUG_ON(smpboot_register_percpu_thread(&amp;cpu_stop_threads));    </span><br><span class="line">    <span class="comment">// 标记stop_machine需要的percpu线程初始化完成</span></span><br><span class="line">    stop_machine_initialized = <span class="literal">true</span>;                              </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                     </span><br><span class="line">&#125;                                                                 </span><br><span class="line">early_initcall(cpu_stop_init);</span><br></pre></td></tr></table></figure>
<p>注册percpu线程并为每个CPU启动对应线程的具体实现</p>
<figure class="highlight c"><figcaption><span>smpboot_register_percpu_thread</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**                                                                                            </span></span><br><span class="line"><span class="comment">* smpboot_register_percpu_thread - Register a per_cpu thread related to hotplug               </span></span><br><span class="line"><span class="comment">* @plug_thread:    Hotplug thread descriptor                                                  </span></span><br><span class="line"><span class="comment">*                                                                                             </span></span><br><span class="line"><span class="comment">* Creates and starts the threads on all online cpus.                                          </span></span><br><span class="line"><span class="comment">*/</span>                                                                                            </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">smpboot_register_percpu_thread</span><span class="params">(struct smp_hotplug_thread *plug_thread)</span>                     </span></span><br><span class="line"><span class="function"></span>&#123;                                                                                              </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> cpu;                                                                          </span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;                                                                               </span><br><span class="line">                                                                                               </span><br><span class="line">    <span class="keyword">if</span> (!alloc_cpumask_var(&amp;plug_thread-&gt;cpumask, GFP_KERNEL))                                 </span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;                                                                        </span><br><span class="line">    cpumask_copy(plug_thread-&gt;cpumask, cpu_possible_mask);                                     </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暂时阻止CPU热插拔                 </span></span><br><span class="line">    get_online_cpus();                                                                         </span><br><span class="line">    mutex_lock(&amp;smpboot_threads_lock);                                                         </span><br><span class="line">    for_each_online_cpu(cpu) &#123;                                                                 </span><br><span class="line">        <span class="comment">// 启动该CPU对应的线程，task_struct实例地址通过上面提到的store写入对应位置</span></span><br><span class="line">        <span class="comment">// 这里面会设置该线程对应的kthread结构体成员标记KTHREAD_IS_PER_CPU，并记录其对应CPU序号</span></span><br><span class="line">        <span class="comment">// 如果create函数指针存在，调用该函数。这里该函数为cpu_stop_create</span></span><br><span class="line">        ret = __smpboot_create_thread(plug_thread, cpu);                                       </span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;                                                                             </span><br><span class="line">            smpboot_destroy_threads(plug_thread);                                              </span><br><span class="line">            <span class="keyword">goto</span> out;                                                                          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试执行pre_unpark回调函数。这里是cpu_stop_unpark了，就是给cpu_stopper成员enable设置为true</span></span><br><span class="line">        <span class="comment">// 调用kthread_unpark。这里会根据之前设置的KTHREAD_IS_PER_CPU和CPU序号给内核线程做CPU绑定，并清除park标记</span></span><br><span class="line">        <span class="comment">//   唤醒该线程，使其进入TASK_RUNNING状态，继续执行传入的函数指针参数，也就是函数smpboot_thread_fn</span></span><br><span class="line">        smpboot_unpark_thread(plug_thread, cpu);                                               </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将这个percpu线程描述加入链表hotplug_threads。这样CPU热插拔时就可以对这些percpu线程做对应操作。</span></span><br><span class="line">    list_add(&amp;plug_thread-&gt;<span class="built_in">list</span>, &amp;hotplug_threads);                                            </span><br><span class="line">out:                                                                                           </span><br><span class="line">    mutex_unlock(&amp;smpboot_threads_lock);</span><br><span class="line">    <span class="comment">// percpu线程操作结束，可以允许CPU热插拔了</span></span><br><span class="line">    put_online_cpus();                                                                         </span><br><span class="line">    <span class="keyword">return</span> ret;                                                                                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>__smpboot_create_thread</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __smpboot_create_thread(struct smp_hotplug_thread *ht, <span class="keyword">unsigned</span> <span class="keyword">int</span> cpu)        </span><br><span class="line">&#123;                                                                               </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> = *<span class="title">per_cpu_ptr</span>(<span class="title">ht</span>-&gt;<span class="title">store</span>, <span class="title">cpu</span>);</span>                     </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">smpboot_thread_data</span> *<span class="title">td</span>;</span>                                             </span><br><span class="line">                                                                                </span><br><span class="line">    <span class="keyword">if</span> (tsk)                                                                    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;                                                               </span><br><span class="line">                                                                                </span><br><span class="line">    td = kzalloc_node(<span class="keyword">sizeof</span>(*td), GFP_KERNEL, cpu_to_node(cpu));               </span><br><span class="line">    <span class="keyword">if</span> (!td)                                                                    </span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;                                                         </span><br><span class="line">    td-&gt;cpu = cpu;                                                              </span><br><span class="line">    td-&gt;ht = ht;                                                                </span><br><span class="line">                                                                               </span><br><span class="line">    <span class="comment">// 内部通过kthread_create_on_node创建出内核线程</span></span><br><span class="line">    <span class="comment">// 通过设置该线程对应的kthread结构体成员标记KTHREAD_IS_PER_CPU，并记录其对应CPU</span></span><br><span class="line">    <span class="comment">// 将内核线程设置为TASK_PARKED状态</span></span><br><span class="line">    <span class="comment">// 函数smpboot_thread_fn此时还没有开始执行</span></span><br><span class="line">    tsk = kthread_create_on_cpu(smpboot_thread_fn, td, cpu,                     </span><br><span class="line">                    ht-&gt;thread_comm);                                           </span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(tsk)) &#123;                                                          </span><br><span class="line">        kfree(td);                                                              </span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(tsk);                                                    </span><br><span class="line">    &#125;                                                                           </span><br><span class="line">    get_task_struct(tsk);                                                       </span><br><span class="line">    <span class="comment">// 线程的task_struct保存到相应位置</span></span><br><span class="line">    *per_cpu_ptr(ht-&gt;store, cpu) = tsk;                                         </span><br><span class="line">    <span class="comment">// 尝试执行create回调函数。这里该函数为cpu_stop_create。看起来好像是调度器相关的，不管了。</span></span><br><span class="line">    <span class="keyword">if</span> (ht-&gt;create) &#123;                                                           </span><br><span class="line">        <span class="comment">/*                                                                      </span></span><br><span class="line"><span class="comment">         * Make sure that the task has actually scheduled out                   </span></span><br><span class="line"><span class="comment">         * into park position, before calling the create                        </span></span><br><span class="line"><span class="comment">         * callback. At least the migration thread callback                     </span></span><br><span class="line"><span class="comment">         * requires that the task is off the runqueue.                          </span></span><br><span class="line"><span class="comment">         */</span>                                                                     </span><br><span class="line">        <span class="keyword">if</span> (!wait_task_inactive(tsk, TASK_PARKED))                              </span><br><span class="line">            WARN_ON(<span class="number">1</span>);                                                         </span><br><span class="line">        <span class="keyword">else</span>                                                                    </span><br><span class="line">            ht-&gt;create(cpu);                                                    </span><br><span class="line">    &#125;                                                                           </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                                   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>get_online_cpus</code>用于阻止<code>put_online_cpus</code>前的CPU热插拔操作。</p>
<figure class="highlight c"><figcaption><span>get_online_cpus</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_online_cpus</span><span class="params">(<span class="keyword">void</span>)</span>                   </span></span><br><span class="line"><span class="function"></span>&#123;                                            </span><br><span class="line">    <span class="comment">// 如果调用发生在原子上下文（不可调度）会打印栈信息做警告。主动尝试调度</span></span><br><span class="line">    might_sleep();                           </span><br><span class="line">    <span class="keyword">if</span> (cpu_hotplug.active_writer == current)</span><br><span class="line">        <span class="keyword">return</span>;                              </span><br><span class="line">    cpuhp_lock_acquire_read();               </span><br><span class="line">    mutex_lock(&amp;cpu_hotplug.lock);           </span><br><span class="line">    <span class="comment">// 增加引用计数，防止后续有CPU热插拔情况</span></span><br><span class="line">    cpu_hotplug.refcount++;                  </span><br><span class="line">    mutex_unlock(&amp;cpu_hotplug.lock);         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>smpboot_thread_fn</code>是一个循环，检查需要处理各种状态。需要执行percpu线程操作时，调用percpu线程描述结构的<code>thread_fn</code>回调函数</p>
<figure class="highlight c"><figcaption><span>smpboot_thread_fn</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**                                                               </span></span><br><span class="line"><span class="comment">* smpboot_thread_fn - percpu hotplug thread loop function        </span></span><br><span class="line"><span class="comment">* @data:   thread data pointer                                   </span></span><br><span class="line"><span class="comment">*                                                                </span></span><br><span class="line"><span class="comment">* Checks for thread stop and park conditions. Calls the necessary</span></span><br><span class="line"><span class="comment">* setup, cleanup, park and unpark functions for the registered   </span></span><br><span class="line"><span class="comment">* thread.                                                        </span></span><br><span class="line"><span class="comment">*                                                                </span></span><br><span class="line"><span class="comment">* Returns 1 when the thread should exit, 0 otherwise.            </span></span><br><span class="line"><span class="comment">*/</span>                                                               </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">smpboot_thread_fn</span><span class="params">(<span class="keyword">void</span> *data)</span>                          </span></span><br><span class="line"><span class="function"></span>&#123;                                                                 </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">smpboot_thread_data</span> *<span class="title">td</span> = <span class="title">data</span>;</span>                        </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">smp_hotplug_thread</span> *<span class="title">ht</span> = <span class="title">td</span>-&gt;<span class="title">ht</span>;</span>                       </span><br><span class="line">                                                                  </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;                                                   </span><br><span class="line">        set_current_state(TASK_INTERRUPTIBLE);                    </span><br><span class="line">        preempt_disable();                                        </span><br><span class="line">        <span class="keyword">if</span> (kthread_should_stop()) &#123;                              </span><br><span class="line">            __set_current_state(TASK_RUNNING);                    </span><br><span class="line">            preempt_enable();                                     </span><br><span class="line">            <span class="keyword">if</span> (ht-&gt;cleanup)                                      </span><br><span class="line">                ht-&gt;cleanup(td-&gt;cpu, cpu_online(td-&gt;cpu));        </span><br><span class="line">            kfree(td);                                            </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;                                             </span><br><span class="line">        &#125;                                                         </span><br><span class="line">                                                                  </span><br><span class="line">        <span class="keyword">if</span> (kthread_should_park()) &#123;                              </span><br><span class="line">            __set_current_state(TASK_RUNNING);                    </span><br><span class="line">            preempt_enable();                                     </span><br><span class="line">            <span class="keyword">if</span> (ht-&gt;park &amp;&amp; td-&gt;status == HP_THREAD_ACTIVE) &#123;     </span><br><span class="line">                BUG_ON(td-&gt;cpu != smp_processor_id());            </span><br><span class="line">                ht-&gt;park(td-&gt;cpu);                                </span><br><span class="line">                td-&gt;status = HP_THREAD_PARKED;                    </span><br><span class="line">            &#125;                                                     </span><br><span class="line">            kthread_parkme();                                     </span><br><span class="line">            <span class="comment">/* We might have been woken for stop */</span>               </span><br><span class="line">            <span class="keyword">continue</span>;                                             </span><br><span class="line">        &#125;                                                         </span><br><span class="line">                                                                  </span><br><span class="line">        BUG_ON(td-&gt;cpu != smp_processor_id());                    </span><br><span class="line">                                                   </span><br><span class="line">        <span class="comment">/* Check for state change setup */</span>         </span><br><span class="line">        <span class="keyword">switch</span> (td-&gt;status) &#123;                      </span><br><span class="line">        <span class="comment">// 初始为该状态</span></span><br><span class="line">        <span class="keyword">case</span> HP_THREAD_NONE:                       </span><br><span class="line">            __set_current_state(TASK_RUNNING);     </span><br><span class="line">            preempt_enable();                      </span><br><span class="line">            <span class="comment">// 这里cpu_stop_threads.setup为cpu_stop_unpark</span></span><br><span class="line">            <span class="keyword">if</span> (ht-&gt;setup)                         </span><br><span class="line">                ht-&gt;setup(td-&gt;cpu);                </span><br><span class="line">            td-&gt;status = HP_THREAD_ACTIVE;         </span><br><span class="line">            <span class="keyword">continue</span>;                              </span><br><span class="line">                                                   </span><br><span class="line">        <span class="keyword">case</span> HP_THREAD_PARKED:                     </span><br><span class="line">            __set_current_state(TASK_RUNNING);     </span><br><span class="line">            preempt_enable();                      </span><br><span class="line">            <span class="keyword">if</span> (ht-&gt;unpark)                        </span><br><span class="line">                ht-&gt;unpark(td-&gt;cpu);               </span><br><span class="line">            td-&gt;status = HP_THREAD_ACTIVE;         </span><br><span class="line">            <span class="keyword">continue</span>;                              </span><br><span class="line">        &#125;                                          </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里是HP_THREAD_ACTIVE状态了</span></span><br><span class="line">        <span class="comment">// cpu_stop_threads.thread_should_runw为cpu_stop_should_run</span></span><br><span class="line">        <span class="keyword">if</span> (!ht-&gt;thread_should_run(td-&gt;cpu)) &#123;     </span><br><span class="line">            <span class="comment">// 该CPU对应的cpu_stopper.works链表空，没活干，就以TASK_INTERRUPTIBLE状态调度走，不占据CPU</span></span><br><span class="line">            preempt_enable_no_resched();           </span><br><span class="line">            schedule();                            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                                   </span><br><span class="line">            <span class="comment">// 该CPU对应的cpu_stooper.works链表不为空，有活干</span></span><br><span class="line">            <span class="comment">// 更新为TASK_RUNNING转台。调用thread_fn回调函数，cpu_stop_threads.thread_fn为cpu_stopper_thread</span></span><br><span class="line">            __set_current_state(TASK_RUNNING);     </span><br><span class="line">            preempt_enable();                      </span><br><span class="line">            ht-&gt;thread_fn(td-&gt;cpu);                </span><br><span class="line">        &#125;                                          </span><br><span class="line">    &#125;                                              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="stop-machine调用"><a href="#stop-machine调用" class="headerlink" title="stop_machine调用"></a>stop_machine调用</h2><p>在每个CPU上调度一个内核线程，每个内核线程都会禁用中断。这样当函数指针参数fn运行时，任何CPU都不会持有spinlock或处于关闭抢占区域。</p>
<figure class="highlight c"><figcaption><span>stop_machine</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int stop_machine(int (*fn)(void *), void *data, const struct cpumask *cpus)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* No CPUs can come up or down during this. */</span></span><br><span class="line">    <span class="comment">// 暂时阻止CPU热插拔</span></span><br><span class="line">    get_online_cpus();</span><br><span class="line">    <span class="comment">// 不考虑CPU热插拔的stop_machine实现</span></span><br><span class="line">    ret = __stop_machine(fn, data, cpus);</span><br><span class="line">    <span class="comment">// 恢复CPU热插拔</span></span><br><span class="line">    put_online_cpus();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一些场景是已经调用过<code>get_online_cpus</code>的，因此单独封装了<code>__stop_machine</code>这个函数</p>
<figure class="highlight c"><figcaption><span>__stop_machine</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __stop_machine(<span class="keyword">int</span> (*fn)(<span class="keyword">void</span> *), <span class="keyword">void</span> *data, <span class="keyword">const</span> struct cpumask *cpus)</span><br><span class="line">&#123;                                                                            </span><br><span class="line">    <span class="comment">// 栈上的msdata，multi_cpu_stop函数会接收其指针作为参数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">multi_stop_data</span> <span class="title">msdata</span> = &#123;</span>                                        </span><br><span class="line">        .fn = fn,                                                            </span><br><span class="line">        .data = data,                                                        </span><br><span class="line">        .num_threads = num_online_cpus(),                                    </span><br><span class="line">        .active_cpus = cpus,                                                 </span><br><span class="line">    &#125;;                                                                       </span><br><span class="line">                                                                             </span><br><span class="line">    <span class="comment">// 如果在cpu_stop_init初始化完成之前，就是直接关中断执行fn。正常不会进入这里</span></span><br><span class="line">    <span class="keyword">if</span> (!stop_machine_initialized) &#123;                                         </span><br><span class="line">        <span class="comment">/*                                                                   </span></span><br><span class="line"><span class="comment">         * Handle the case where stop_machine() is called                    </span></span><br><span class="line"><span class="comment">         * early in boot before stop_machine() has been                      </span></span><br><span class="line"><span class="comment">         * initialized.                                                      </span></span><br><span class="line"><span class="comment">         */</span>                                                                  </span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;                                                 </span><br><span class="line">        <span class="keyword">int</span> ret;                                                             </span><br><span class="line">                                                                             </span><br><span class="line">        WARN_ON_ONCE(msdata.num_threads != <span class="number">1</span>);                               </span><br><span class="line">                                                                             </span><br><span class="line">        local_irq_save(flags);                                               </span><br><span class="line">        hard_irq_disable();                                                  </span><br><span class="line">        ret = (*fn)(data);                                                   </span><br><span class="line">        local_irq_restore(flags);                                            </span><br><span class="line">                                                                             </span><br><span class="line">        <span class="keyword">return</span> ret;                                                          </span><br><span class="line">    &#125;                                                                        </span><br><span class="line">                                                                             </span><br><span class="line">    <span class="comment">/* Set the initial state and stop all online cpus. */</span>                    </span><br><span class="line">    <span class="comment">// 初始化msdata状态机相关</span></span><br><span class="line">    set_state(&amp;msdata, MULTI_STOP_PREPARE);                                  </span><br><span class="line">    <span class="comment">// stop_cpus参数cpu_online_mask。停止所有在线的cpu的其他工作，调用函数multi_cpu_stop，函数参数为msdata</span></span><br><span class="line">    <span class="keyword">return</span> stop_cpus(cpu_online_mask, multi_cpu_stop, &amp;msdata);              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>multi_stop_state</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This controls the threads on each CPU. */</span></span><br><span class="line"><span class="keyword">enum</span> multi_stop_state &#123;                      </span><br><span class="line">    <span class="comment">/* Dummy starting state for thread. */</span>   </span><br><span class="line">    MULTI_STOP_NONE,                         </span><br><span class="line">    <span class="comment">/* Awaiting everyone to be scheduled. */</span></span><br><span class="line">    MULTI_STOP_PREPARE,                      </span><br><span class="line">    <span class="comment">/* Disable interrupts. */</span>                </span><br><span class="line">    MULTI_STOP_DISABLE_IRQ,                  </span><br><span class="line">    <span class="comment">/* Run the function */</span>                   </span><br><span class="line">    MULTI_STOP_RUN,                          </span><br><span class="line">    <span class="comment">/* Exit */</span>                               </span><br><span class="line">    MULTI_STOP_EXIT,                         </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>stop_cpus</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stop_cpus</span><span class="params">(<span class="keyword">const</span> struct cpumask *cpumask, <span class="keyword">cpu_stop_fn_t</span> fn, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;                                                                         </span><br><span class="line">    <span class="keyword">int</span> ret;                                                              </span><br><span class="line">                                                                          </span><br><span class="line">    <span class="comment">/* static works are used, process one request at a time */</span>            </span><br><span class="line">    <span class="comment">// 同一时间只允许有一个stop_cpus运行</span></span><br><span class="line">    <span class="comment">// 因为这里面调用的函数queue_stop_cpus_work用到了cpu_stopper.stop_work</span></span><br><span class="line">    <span class="comment">// 将其插入了cpu_stopper.works链表，在运行完成前，stop_work这个成员不能被重复使用。</span></span><br><span class="line">    mutex_lock(&amp;stop_cpus_mutex);                                         </span><br><span class="line">    ret = __stop_cpus(cpumask, fn, arg);                                  </span><br><span class="line">    mutex_unlock(&amp;stop_cpus_mutex);                                       </span><br><span class="line">    <span class="keyword">return</span> ret;                                                           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>__stop_cpus</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __stop_cpus(<span class="keyword">const</span> struct cpumask *cpumask,     </span><br><span class="line">               <span class="keyword">cpu_stop_fn_t</span> fn, <span class="keyword">void</span> *arg)               </span><br><span class="line">&#123;                                                         </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu_stop_done</span> <span class="title">done</span>;</span>                            </span><br><span class="line">                                                          </span><br><span class="line">    <span class="comment">// 初始化栈上变量，包括待执行cpu的计数和completion结构</span></span><br><span class="line">    cpu_stop_init_done(&amp;done, cpumask_weight(cpumask));   </span><br><span class="line">    <span class="comment">// 遍历需要停止的cpu，设置其cpu_stopper.stop_work，插入待执行链表cpu_stopper.works</span></span><br><span class="line">    queue_stop_cpus_work(cpumask, fn, arg, &amp;done);        </span><br><span class="line">    <span class="comment">// 等待completion</span></span><br><span class="line">    wait_for_completion(&amp;done.completion);                </span><br><span class="line">    <span class="keyword">return</span> done.executed ? done.ret : -ENOENT;            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>queue_stop_cpus_work</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">queue_stop_cpus_work</span><span class="params">(<span class="keyword">const</span> struct cpumask *cpumask,  </span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">cpu_stop_fn_t</span> fn, <span class="keyword">void</span> *arg,                    </span></span></span><br><span class="line"><span class="function"><span class="params">                 struct cpu_stop_done *done)</span>                     </span></span><br><span class="line"><span class="function"></span>&#123;                                                                </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu_stop_work</span> *<span class="title">work</span>;</span>                                  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> cpu;                                            </span><br><span class="line">                                                                 </span><br><span class="line">    <span class="comment">/*                                                           </span></span><br><span class="line"><span class="comment">     * Disable preemption while queueing to avoid getting        </span></span><br><span class="line"><span class="comment">     * preempted by a stopper which might wait for other stoppers</span></span><br><span class="line"><span class="comment">     * to enter @fn which can lead to deadlock.                  </span></span><br><span class="line"><span class="comment">     */</span>                                                          </span><br><span class="line">    <span class="comment">// 在向每个需要停止的cpu发送排队任务前关闭抢占，为了避免任务发送完之前当前上下文被抢占导致已经开始执行任务的cpu死锁等待。</span></span><br><span class="line">    <span class="comment">// 对percpu的自旋锁按顺序对每个cpu上锁，应该是为了确保有多个排队任务时，在所有cpu上排队任务的顺序相同。</span></span><br><span class="line">    lg_global_lock(&amp;stop_cpus_lock);                             </span><br><span class="line">    for_each_cpu(cpu, cpumask) &#123;                                 </span><br><span class="line">        work = &amp;per_cpu(cpu_stopper.stop_work, cpu);             </span><br><span class="line">        work-&gt;fn = fn;                                           </span><br><span class="line">        work-&gt;arg = arg;                                         </span><br><span class="line">        work-&gt;done = done;                                       </span><br><span class="line">        cpu_stop_queue_work(cpu, work);                          </span><br><span class="line">    &#125;                                                            </span><br><span class="line">    lg_global_unlock(&amp;stop_cpus_lock);                           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="回到migration线程"><a href="#回到migration线程" class="headerlink" title="回到migration线程"></a>回到migration线程</h2><p>有活干的时候，migration线程会由<code>smpboot_thread_fn</code>调用<code>cpu_stop_threads.thread_fn</code>，也就是<code>cpu_stopper_thread</code></p>
<figure class="highlight c"><figcaption><span>cpu_stopper_thread</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cpu_stopper_thread</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu)</span>                         </span></span><br><span class="line"><span class="function"></span>&#123;                                                                        </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu_stopper</span> *<span class="title">stopper</span> = &amp;<span class="title">per_cpu</span>(<span class="title">cpu_stopper</span>, <span class="title">cpu</span>);</span>            </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu_stop_work</span> *<span class="title">work</span>;</span>                                          </span><br><span class="line">    <span class="keyword">int</span> ret;                                                             </span><br><span class="line">                                                                         </span><br><span class="line">repeat:                                                                  </span><br><span class="line">    work = <span class="literal">NULL</span>;                                                         </span><br><span class="line">    <span class="comment">// 链表不为空时，从cpu_stopper.works链表取第一个</span></span><br><span class="line">    spin_lock_irq(&amp;stopper-&gt;lock);                                       </span><br><span class="line">    <span class="keyword">if</span> (!list_empty(&amp;stopper-&gt;works)) &#123;                                  </span><br><span class="line">        work = list_first_entry(&amp;stopper-&gt;works,                         </span><br><span class="line">                    struct cpu_stop_work, <span class="built_in">list</span>);                         </span><br><span class="line">        list_del_init(&amp;work-&gt;<span class="built_in">list</span>);                                      </span><br><span class="line">    &#125;                                                                    </span><br><span class="line">    spin_unlock_irq(&amp;stopper-&gt;lock);                                     </span><br><span class="line">                                                                         </span><br><span class="line">    <span class="keyword">if</span> (work) &#123;                                                          </span><br><span class="line">        <span class="keyword">cpu_stop_fn_t</span> fn = work-&gt;fn;                                     </span><br><span class="line">        <span class="keyword">void</span> *arg = work-&gt;arg;                                           </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cpu_stop_done</span> *<span class="title">done</span> = <span class="title">work</span>-&gt;<span class="title">done</span>;</span>                         </span><br><span class="line">        <span class="keyword">char</span> ksym_buf[KSYM_NAME_LEN] __maybe_unused;                     </span><br><span class="line">                                                                         </span><br><span class="line">        <span class="comment">/* cpu stop callbacks are not allowed to sleep */</span>               </span><br><span class="line">        preempt_disable();                                               </span><br><span class="line">                                                                         </span><br><span class="line">        <span class="comment">// 关抢占情况下执行fn，这里是__stop_machine中设置的multi_cpu_stop，参数是栈上的msdata</span></span><br><span class="line">        ret = fn(arg);                                                   </span><br><span class="line">        <span class="keyword">if</span> (ret)                                                         </span><br><span class="line">            done-&gt;ret = ret;                                             </span><br><span class="line">                                                                         </span><br><span class="line">        <span class="comment">/* restore preemption and check it's still balanced */</span>           </span><br><span class="line">        preempt_enable();                                                </span><br><span class="line">        WARN_ONCE(preempt_count(),                                       </span><br><span class="line">              <span class="string">"cpu_stop: %s(%p) leaked preempt count\n"</span>,                 </span><br><span class="line">              kallsyms_lookup((<span class="keyword">unsigned</span> <span class="keyword">long</span>)fn, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,       </span><br><span class="line">                      ksym_buf), arg);                                   </span><br><span class="line">                                                                         </span><br><span class="line">        cpu_stop_signal_done(done, <span class="literal">true</span>);                                </span><br><span class="line">        <span class="keyword">goto</span> repeat;                                                     </span><br><span class="line">    &#125;                                                                    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>stop_machine</code>参数中的fn由<code>multi_cpu_stop</code>调用，处于禁用中断状态，整个机器停止在<code>multi_cpu_stop</code>函数中。</p>
<p><code>multi_cpu_stop</code>返回后，<code>cpu_stopper_thread</code>中最后调用<code>cpu_stop_signal_done</code>的migration线程会激活completion，等待的<code>stop_machine</code>调用线程被唤醒并返回。</p>
<figure class="highlight c"><figcaption><span>multi_cpu_stop</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is the cpu_stop function which stops the CPU. */</span>                  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">multi_cpu_stop</span><span class="params">(<span class="keyword">void</span> *data)</span>                                     </span></span><br><span class="line"><span class="function"></span>&#123;                                                                         </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">multi_stop_data</span> *<span class="title">msdata</span> = <span class="title">data</span>;</span>                                </span><br><span class="line">    <span class="keyword">enum</span> multi_stop_state curstate = MULTI_STOP_NONE;                     </span><br><span class="line">    <span class="keyword">int</span> cpu = smp_processor_id(), err = <span class="number">0</span>;                                </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;                                                  </span><br><span class="line">    <span class="keyword">bool</span> is_active;                                                       </span><br><span class="line">                                                                          </span><br><span class="line">    <span class="comment">/*                                                                    </span></span><br><span class="line"><span class="comment">     * When called from stop_machine_from_inactive_cpu(), irq might       </span></span><br><span class="line"><span class="comment">     * already be disabled.  Save the state and restore it on exit.       </span></span><br><span class="line"><span class="comment">     */</span>                                                                   </span><br><span class="line">    local_save_flags(flags);                                              </span><br><span class="line">                                                                          </span><br><span class="line">    <span class="comment">// 选择哪些cpu执行函数msdata-&gt;fn</span></span><br><span class="line">    <span class="comment">// active_cpus为NULL，则只有第一个在线cpu执行fn。不为NULL则掩码内所有cpu执行fn</span></span><br><span class="line">    <span class="comment">// 由stop_machine接收的参数决定</span></span><br><span class="line">    <span class="keyword">if</span> (!msdata-&gt;active_cpus)                                             </span><br><span class="line">        is_active = cpu == cpumask_first(cpu_online_mask);                </span><br><span class="line">    <span class="keyword">else</span>                                                                  </span><br><span class="line">        is_active = cpumask_test_cpu(cpu, msdata-&gt;active_cpus);           </span><br><span class="line">                                                                          </span><br><span class="line">    <span class="comment">/* Simple state machine */</span>                                            </span><br><span class="line">    <span class="comment">// 一个简单的状态机，用于同步所有需要停止的cpu的工作阶段。</span></span><br><span class="line">    <span class="comment">// 所有需要停止的cpu都经历过一个状态后，才会进入下一个状态，由最后一个计数的cpu做msdata的状态变更。</span></span><br><span class="line">    <span class="comment">// 先是进入准备状态</span></span><br><span class="line">    <span class="comment">// 关闭中断状态，每个进入此状态的cpu关闭中断</span></span><br><span class="line">    <span class="comment">// 任务执行状态，根据前面判定的is_active决定当前cpu是否执行函数fn，stop_machine参数中的函数</span></span><br><span class="line">    <span class="comment">// 最后是退出状态</span></span><br><span class="line">    <span class="keyword">do</span> &#123;                                                                  </span><br><span class="line">        <span class="comment">/* Chill out and ensure we re-read multi_stop_state. */</span>           </span><br><span class="line">        cpu_relax();                                                      </span><br><span class="line">        <span class="keyword">if</span> (msdata-&gt;state != curstate) &#123;                                  </span><br><span class="line">            curstate = msdata-&gt;state;                                     </span><br><span class="line">            <span class="keyword">switch</span> (curstate) &#123;                                           </span><br><span class="line">            <span class="keyword">case</span> MULTI_STOP_DISABLE_IRQ:                                  </span><br><span class="line">                local_irq_disable();                                      </span><br><span class="line">                hard_irq_disable();                                       </span><br><span class="line">                <span class="keyword">break</span>;                                                    </span><br><span class="line">            <span class="keyword">case</span> MULTI_STOP_RUN:                                          </span><br><span class="line">                <span class="keyword">if</span> (is_active)                                            </span><br><span class="line">                    err = msdata-&gt;fn(msdata-&gt;data);                       </span><br><span class="line">                <span class="keyword">break</span>;                                                    </span><br><span class="line">            <span class="keyword">default</span>:                                                      </span><br><span class="line">                <span class="keyword">break</span>;                                                    </span><br><span class="line">            &#125;                                                             </span><br><span class="line">            <span class="comment">// 计数和状态切换</span></span><br><span class="line">            ack_state(msdata);                                            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curstate &gt; MULTI_STOP_PREPARE) &#123;                       </span><br><span class="line">            <span class="comment">/*                                                            </span></span><br><span class="line"><span class="comment">             * At this stage all other CPUs we depend on must spin        </span></span><br><span class="line"><span class="comment">             * in the same loop. Any reason for hard-lockup should        </span></span><br><span class="line"><span class="comment">             * be detected and reported on their side.                    </span></span><br><span class="line"><span class="comment">             */</span>                                                           </span><br><span class="line">            touch_nmi_watchdog();                                         </span><br><span class="line">        &#125;                                                                 </span><br><span class="line">    &#125; <span class="keyword">while</span> (curstate != MULTI_STOP_EXIT);                                </span><br><span class="line">                                                                          </span><br><span class="line">    local_irq_restore(flags);                                             </span><br><span class="line">    <span class="keyword">return</span> err;                                                           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/linux/">linux</a></div><div class="post-nav"><a class="next" href="/2025/05/05/static-key-jump-label/">static key &amp; jump label</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://www.hyuuhit.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/libvirt/">libvirt</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/suricata/">suricata</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/vmware/" style="font-size: 15px;">vmware</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/06/02/stop-machine/">stop_machine 实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/05/05/static-key-jump-label/">static key & jump label</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/30/initcall/">initcall 机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/07/cn-proc-example/">cn_proc 进程事件连接器</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/04/executable-shared-library/">可执行的动态链接库</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/05/26/dirpro-bug-analysis/">一次无源码Linux内核模块bug分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/05/13/elrepo-not-for-production-use/">为什么生产环境服务器不应该使用ELRepo内核</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/04/29/memory-consistency-model-memory-barrier-and-sychronization/">内存一致性模型、内存屏障与同步</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/04/11/rcu-usage/">抢占式RCU与RCU使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/09/16/tc-tbf-qdisc/">tc tbf qdisc 令牌桶过滤器限速队列</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">属乌鸦的.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>