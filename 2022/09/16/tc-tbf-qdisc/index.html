<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="hu yu's blog | Android | 服务端"><title>tc tbf qdisc | 属乌鸦的</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-129648993-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '85d80db9310fa34ab2f7d34beeff589b';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">tc tbf qdisc</h1><a id="logo" href="/.">属乌鸦的</a><p class="description">无知 &amp; 聒噪</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">tc tbf qdisc</h1><div class="post-meta">Sep 16, 2022</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#传输参数"><span class="toc-number">1.</span> <span class="toc-text">传输参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCA-TBF-PARMS"><span class="toc-number">1.1.</span> <span class="toc-text">TCA_TBF_PARMS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCA-TBF-RTAB-TCA-TBF-PTAB"><span class="toc-number">1.2.</span> <span class="toc-text">TCA_TBF_RTAB/TCA_TBF_PTAB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCA-TBF-RATE64-TCA-TBF-PRATE64"><span class="toc-number">1.3.</span> <span class="toc-text">TCA_TBF_RATE64/TCA_TBF_PRATE64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCA-TBF-BURST"><span class="toc-number">1.4.</span> <span class="toc-text">TCA_TBF_BURST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCA-TBF-PBURST"><span class="toc-number">1.5.</span> <span class="toc-text">TCA_TBF_PBURST</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内核实现"><span class="toc-number">2.</span> <span class="toc-text">内核实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#配置-tbf-change"><span class="toc-number">2.1.</span> <span class="toc-text">配置 tbf_change</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#入队列-tbf-enqueue"><span class="toc-number">2.2.</span> <span class="toc-text">入队列 tbf_enqueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#出队列-tbf-dequeue"><span class="toc-number">2.3.</span> <span class="toc-text">出队列 tbf_dequeue</span></a></li></ol></li></ol></div></div><div class="post-content"><p>本文记录tc tbf qdisc使用netlink与内核通信的参数格式及其数据含义与tc命令中tbf相关实现与内核中相关实现。</p>
<a id="more"></a>
<p>tc命令中tbf qdisc实现位于iproute2项目文件iproute2/tc/q_tbf.c</p>
<p>内核中实现位于文件net/sched/sch_tbf.c</p>
<p>参考内核版本：4.18.0-193.el8.x86_64</p>
<h2 id="传输参数"><a href="#传输参数" class="headerlink" title="传输参数"></a>传输参数</h2><p>tbf qdic使用netlink与内核交互的传输参数类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;                   </span><br><span class="line">    TCA_TBF_UNSPEC,      </span><br><span class="line">    TCA_TBF_PARMS,       </span><br><span class="line">    TCA_TBF_RTAB,        </span><br><span class="line">    TCA_TBF_PTAB,        </span><br><span class="line">    TCA_TBF_RATE64,      </span><br><span class="line">    TCA_TBF_PRATE64,     </span><br><span class="line">    TCA_TBF_BURST,       </span><br><span class="line">    TCA_TBF_PBURST,      </span><br><span class="line">    TCA_TBF_PAD,         </span><br><span class="line">    __TCA_TBF_MAX,       </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="TCA-TBF-PARMS"><a href="#TCA-TBF-PARMS" class="headerlink" title="TCA_TBF_PARMS"></a>TCA_TBF_PARMS</h3><p>TCA_TBF_PARMS对应的数据结构为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tc_tbf_qopt</span> &#123;</span>              </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tc_ratespec</span> <span class="title">rate</span>;</span>      <span class="comment">// 限速速率相关</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tc_ratespec</span> <span class="title">peakrate</span>;</span>  <span class="comment">// 峰值限速速率。因为累积的token，也就是buffer的存在，会有突发数据，单纯的rate无法限制该突发。</span></span><br><span class="line">                                  <span class="comment">// 因此使用peakrate进一步限制突发速率</span></span><br><span class="line"></span><br><span class="line">    __u32       limit;            <span class="comment">// 数据包队列可以缓存的最大字节数。</span></span><br><span class="line">                                  <span class="comment">// tc命令行参数中latency也是作用于该参数，因为发送速率限制的原因，缓存最大字节数与最大延迟时间直接相关</span></span><br><span class="line"></span><br><span class="line">    __u32       buffer;           <span class="comment">// 该数据结构中buffer存储的是队列中允许累积的最大token数所对应的ticks值。</span></span><br><span class="line">                                  <span class="comment">// 这个ticks是一个虚拟的概念，与内核的时钟tick不同</span></span><br><span class="line">                                  <span class="comment">// 这个值也会经过换算体现为允许突发的数据字节数，突发字节数需要不小于设备实际mtu。</span></span><br><span class="line"></span><br><span class="line">    __u32       mtu;              <span class="comment">// minburst，这个可以看作peakrate所对应的buffer，也就是peakrate的突发，意义相同。如果mtu设置小于设备实际mtu，会发生数据包无法发送的问题，直接被丢弃。</span></span><br><span class="line">                                  <span class="comment">// 一般mtu设置小于buffer，peakrate大于rate，达到削峰效果。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tc_ratespec</span> &#123;</span>                                </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>   cell_log;</span><br><span class="line">    __u8        linklayer; <span class="comment">/* lower 4 bits */</span>     <span class="comment">// 链路层类型。3种值TC_LINKLAYER_UNAWARE、TC_LINKLAYER_ETHERNET、TC_LINKLAYER_ATM</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  overhead;                     <span class="comment">// 数据包在链路传播需要额外占用的字节数。</span></span><br><span class="line">    <span class="keyword">short</span>       cell_align;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  mpu;                          <span class="comment">// 数据包最小尺寸字节数。比如以太网是64字节，小于该尺寸的数据包也会被填充到该尺寸再发送到链路中，这个跟冲突检测有关。但是没有看懂怎么使用的该字段……</span></span><br><span class="line">    __u32       rate;                             <span class="comment">// 限速速率。如果限速每秒字节数小于1&lt;&lt;32，也就是不超过32位，使用该字段。否则该字段置~0U（也就是所有位置1），并使用TCA_TBF_RATE64及TCA_TBF_PRATE64。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里提到的<code>tc_tbf.qopt.buffer</code>和<code>tc_tbf_qopt.mtu</code>存储的是虚拟ticks数，但是tc命令输入参数是字节数，换算过程如下：</p>
<ol>
<li>将字节数size转换为发送所需要的时间，<code>size / rate * USEC_PER_SEC</code>，得到发送size字节需要的微秒数time，这里<code>USEC_PER_SEC</code>在iproute2项目中实际使用的宏为TIME_UNITS_PER_SEC</li>
<li>计算微秒数time对应的ticks数，<code>time * tick_in_usec</code></li>
</ol>
<p>其中<code>tick_in_usec</code>在函数<code>tc_core_init</code>中被预先计算出了，这个函数中对读取值存入的变量命名会引起误解，因此下面使用内核代码说明。<br>读取/proc/net/psched文件，该文件输出4个值，实现为内核代码中函数<code>psched_show</code>，位于文件net/sched/sch_api.c</p>
<ul>
<li>第一个值为NSEC_PER_USEC，一微秒包含多少纳秒，值为1000</li>
<li>第二个值为PSCHED_TICKS2NS(1)，该宏实现为左移6位。一个tick包含多少纳秒，这里的tick为模拟的假tick，只用于数据包调度整形使用，最终值为64</li>
<li>第三个值写死为1000000。</li>
<li>第四个值应该与时钟分辨率有关，tc用不到，不管了</li>
</ul>
<p><code>tick_in_usec</code>的计算方式为 <code>值1 / 值2 * 值3 / TIME_UNITS_PER_SEC</code><br>由于值3与TIME_UNITS_PER_SEC相等，<code>time_in_usec</code>最终即为一微秒包含的ticks数</p>
<h3 id="TCA-TBF-RTAB-TCA-TBF-PTAB"><a href="#TCA-TBF-RTAB-TCA-TBF-PTAB" class="headerlink" title="TCA_TBF_RTAB/TCA_TBF_PTAB"></a>TCA_TBF_RTAB/TCA_TBF_PTAB</h3><p>这两个目前的内核中已经不再使用。本意应该是加速通过数据包字节数换算需要的token数（其实就是时间纳秒数），以避免使用除法。现有内核使用乘法与偏移加速该换算</p>
<h3 id="TCA-TBF-RATE64-TCA-TBF-PRATE64"><a href="#TCA-TBF-RATE64-TCA-TBF-PRATE64" class="headerlink" title="TCA_TBF_RATE64/TCA_TBF_PRATE64"></a>TCA_TBF_RATE64/TCA_TBF_PRATE64</h3><p>当限速每秒字节数大于等于1&lt;&lt;32，也就是超过32位表示时，使用这两个参数，不再使用tc_ratespec.rate字段</p>
<h3 id="TCA-TBF-BURST"><a href="#TCA-TBF-BURST" class="headerlink" title="TCA_TBF_BURST"></a>TCA_TBF_BURST</h3><p>这里对应的也是tc_tbf_qopt.buffer，但是这里存储的是字节数，而不是虚拟tick数。</p>
<h3 id="TCA-TBF-PBURST"><a href="#TCA-TBF-PBURST" class="headerlink" title="TCA_TBF_PBURST"></a>TCA_TBF_PBURST</h3><p>这里对应的也是tc_tbf_qopt.mtu，但是这里存储的是字节数，而不是虚拟tick数</p>
<h2 id="内核实现"><a href="#内核实现" class="headerlink" title="内核实现"></a>内核实现</h2><h3 id="配置-tbf-change"><a href="#配置-tbf-change" class="headerlink" title="配置 tbf_change"></a>配置 tbf_change</h3><p>内核使用数据结构<code>tbf_sched_data</code>保存配置参数，内核源码中该结构的注释记录了tbf的计算原理，这里不重复了<br>这个结构中有些成员记录的是字节数，有些是时间，但是这里的时间又不是传输中使用的虚拟ticks，而是经过换算后的实际的纳秒数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tbf_sched_data</span> &#123;</span>                                                     </span><br><span class="line">    <span class="comment">/* Parameters */</span>                                                            </span><br><span class="line">    u32     limit;      <span class="comment">/* Maximal length of backlog: bytes */</span></span><br><span class="line">                        <span class="comment">/* 对应传输进来的limit，数据队列字节数。生效于qdisc成员包含的bfifo队列中 */</span></span><br><span class="line"></span><br><span class="line">    u32     max_size;   <span class="comment">/* 突发数据字节数，实际运行时便于比较。取buffer和mtu对应的字节数的较小值。如果数据包尺寸超过该值将会直接丢弃 */</span>  </span><br><span class="line"></span><br><span class="line">    s64     buffer;     <span class="comment">/* Token bucket depth/rate: MUST BE &gt;= MTU/B */</span></span><br><span class="line">                        <span class="comment">/* rate对应突发数据限额对应的纳秒数 */</span> </span><br><span class="line"></span><br><span class="line">    s64     mtu;        <span class="comment">/* prate对应的突发数据限额对应的纳秒数 */</span>  </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">psched_ratecfg</span> <span class="title">rate</span>;</span>                                             </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">psched_ratecfg</span> <span class="title">peak</span>;</span>                                             </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Variables */</span>                                                             </span><br><span class="line">    s64 tokens;         <span class="comment">/* Current number of B tokens */</span>                    </span><br><span class="line">    s64 ptokens;        <span class="comment">/* Current number of P tokens */</span>                    </span><br><span class="line">    s64 t_c;            <span class="comment">/* Time check-point */</span>                              </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Qdisc</span>    *<span class="title">qdisc</span>;</span>     <span class="comment">/* Inner qdisc, default - bfifo queue */</span>                   </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qdisc_watchdog</span> <span class="title">watchdog</span>;</span> <span class="comment">/* Watchdog timer */</span>                    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">psched_ratecfg</span> &#123;</span>                            </span><br><span class="line">    u64 rate_bytes_ps; <span class="comment">/* bytes per second */</span>      </span><br><span class="line">    u32 mult;          <span class="comment">/* 用于加速计算字节数到纳秒数的计算 */</span>                           </span><br><span class="line">    u16 overhead;      <span class="comment">/* 见上文 */</span></span><br><span class="line">    u8  linklayer;     <span class="comment">/* 见上文 */</span>                            </span><br><span class="line">    u8  shift;         <span class="comment">/* 用于加速计算字节数到纳秒数的计算 */</span>                        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用函数<code>psched_ratecfg_precompute</code>保存及计算限速速率及用于加速字节数到对应时间长度的算法参数，存储到结构体<code>psched_ratecfg</code>中，overhead、linklayer均在这里被保存</p>
<ul>
<li>普通的计算方式为<code>time_in_ns = (NSEC_PER_SEC * len) / rate_bps</code></li>
<li>加速的计算方式为<code>time_in_ns = (len * mult) &gt;&gt; shift</code></li>
</ul>
<h3 id="入队列-tbf-enqueue"><a href="#入队列-tbf-enqueue" class="headerlink" title="入队列 tbf_enqueue"></a>入队列 tbf_enqueue</h3><p>入队列出队列都比较简单，简略记录一下</p>
<p>对于外发数据包来说，<code>__dev_queue_xmit</code>中调用函数<code>qdisc_pkt_len_init</code>初始化了<code>qdisc_skb_cb(skb)-&gt;pkt_len = skb-&gt;len</code></p>
<ul>
<li>入队列时获取该长度，与max_size比较，并综合判断gso相关字段</li>
<li>符合条件会调用<code>qdisc_enqueue</code><ul>
<li>调用<code>qdisc_calculate_pkt_len</code>，尝试使用Qdisc-&gt;stab更新<code>qdisc_skb_cb(skb)-&gt;pkt_len</code>。没有看到stab哪里初始化的，就当不存在吧</li>
<li>调用Qdisc.enqueue函数指针，这里应该是<code>bfifo_enqueue</code>函数。判断数据包队列是否会超出limit，不超出则入队列</li>
</ul>
</li>
<li>更新统计信息</li>
</ul>
<h3 id="出队列-tbf-dequeue"><a href="#出队列-tbf-dequeue" class="headerlink" title="出队列 tbf_dequeue"></a>出队列 tbf_dequeue</h3><ul>
<li>获取队列首包</li>
<li><code>qdisc_pkt_len(skb)</code>获取数据包长度</li>
<li>获取当前时间纳秒值</li>
<li>当前时间纳秒值与上次检查点时间纳秒值做减法，并与<code>tbf_sched_data.buffer</code>做比较、取较小值赋值给toks。含义是取得当前累积的token数量，该数量不能超过突发量。可以看到token数量等价于纳秒值</li>
<li>如果有配置峰值速率，获取峰值ptoks，注意这里mtu相当于峰值限速的buffer，因此ptoks不能大于mtu。ptoks减掉当前数据包长度需要消耗的纳秒值（这里使用了overhead及linklayer）</li>
<li>限制toks同样不能大于buffer</li>
<li>toks减去当前数据包需要消耗的纳秒值（这里使用了overhead及linklayer）</li>
<li>如果toks与ptoks都大于0，说明当前资源满足发送该数据包<ul>
<li>更新检查点为当前时间</li>
<li>更新tbf_sched_data的tokens与ptokens成员</li>
<li>更新统计信息</li>
<li>返回skb</li>
</ul>
</li>
<li>如果不满足发包要求<ul>
<li>设置定时器</li>
<li>更新超限速统计信息</li>
</ul>
</li>
</ul>
</div><div class="tags"><a href="/tags/linux/">linux</a></div><div class="post-nav"><a class="pre" href="/2024/04/11/rcu-usage/">RCU 使用</a><a class="next" href="/2022/08/08/function-call-stack/">gdb查看寄存器及内存数据与函数调用栈分析</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://www.hyuuhit.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/libvirt/">libvirt</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/suricata/">suricata</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/vmware/" style="font-size: 15px;">vmware</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2024/04/11/rcu-usage/">RCU 使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/09/16/tc-tbf-qdisc/">tc tbf qdisc</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/08/function-call-stack/">gdb查看寄存器及内存数据与函数调用栈分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/16/libpcap-cutoff-captured-packet/">libpcap在libvirt虚拟化环境下捕获数据包不完整的一种情况分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/27/bash-audit/">一种简单的bash审计方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/20/bash-invocation/">bash 调用方式与配置文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/17/uriparser/">uriparser 解析处理URI</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/06/noblock-rabbitmq-c/">rabbitmq-c 非阻塞订阅</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/20/libyaml/">libyaml 解析配置文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/23/netns/">Linux network namespace 简单解读</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">属乌鸦的.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>