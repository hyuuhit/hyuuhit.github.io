<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="huyu's blog | Linux"><title>tc tbf qdisc 令牌桶过滤器限速队列 | 属乌鸦的</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-129648993-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '85d80db9310fa34ab2f7d34beeff589b';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">tc tbf qdisc 令牌桶过滤器限速队列</h1><a id="logo" href="/.">属乌鸦的</a><p class="description">无知 &amp; 聒噪</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">tc tbf qdisc 令牌桶过滤器限速队列</h1><div class="post-meta">Sep 16, 2022</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#tc-tbf-命令参数"><span class="toc-number">1.</span> <span class="toc-text">tc tbf 命令参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#传输参数"><span class="toc-number">2.</span> <span class="toc-text">传输参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCA-TBF-PARMS"><span class="toc-number">2.1.</span> <span class="toc-text">TCA_TBF_PARMS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCA-TBF-RTAB-TCA-TBF-PTAB"><span class="toc-number">2.2.</span> <span class="toc-text">TCA_TBF_RTAB/TCA_TBF_PTAB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCA-TBF-RATE64-TCA-TBF-PRATE64"><span class="toc-number">2.3.</span> <span class="toc-text">TCA_TBF_RATE64/TCA_TBF_PRATE64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCA-TBF-BURST"><span class="toc-number">2.4.</span> <span class="toc-text">TCA_TBF_BURST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCA-TBF-PBURST"><span class="toc-number">2.5.</span> <span class="toc-text">TCA_TBF_PBURST</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内核实现"><span class="toc-number">3.</span> <span class="toc-text">内核实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#配置-tbf-change"><span class="toc-number">3.1.</span> <span class="toc-text">配置 tbf_change</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#入队列-tbf-enqueue"><span class="toc-number">3.2.</span> <span class="toc-text">入队列 tbf_enqueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#出队列-tbf-dequeue"><span class="toc-number">3.3.</span> <span class="toc-text">出队列 tbf_dequeue</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#旧版本BUG"><span class="toc-number">4.</span> <span class="toc-text">旧版本BUG</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9rc1之前"><span class="toc-number">4.1.</span> <span class="toc-text">3.9rc1之前</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#max-size"><span class="toc-number">4.1.1.</span> <span class="toc-text">max_size</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#例1"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">例1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#例2"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">例2</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#enqueue-dequeue"><span class="toc-number">4.1.2.</span> <span class="toc-text">enqueue/dequeue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9rc1"><span class="toc-number">4.2.</span> <span class="toc-text">3.9rc1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-13rc4"><span class="toc-number">4.3.</span> <span class="toc-text">3.13rc4</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-14rc1"><span class="toc-number">4.4.</span> <span class="toc-text">3.14rc1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BUG规避"><span class="toc-number">4.5.</span> <span class="toc-text">BUG规避</span></a></li></ol></li></ol></div></div><div class="post-content"><p>本文记录tc tbf qdisc使用netlink与内核通信的参数格式、数据含义、tc命令中tbf相关实现与内核中相关实现。增加老版本内核中tbf队列bug分析</p>
<a id="more"></a>
<p>tc命令中tbf qdisc实现位于iproute2项目文件iproute2/tc/q_tbf.c</p>
<p>内核中实现位于文件net/sched/sch_tbf.c</p>
<p>参考内核版本：4.18.0-193.el8.x86_64</p>
<h2 id="tc-tbf-命令参数"><a href="#tc-tbf-命令参数" class="headerlink" title="tc tbf 命令参数"></a>tc tbf 命令参数</h2><ul>
<li>rate<br>限速速率，输入根据单位不同可以是字节每秒也可以是比特每秒</li>
<li>burst、buffer、maxburst<br>也可以是burst/cell形式输入，cell用于配合rtab使用，cell只在旧版本内核有使用，当前已经不再使用<br>令牌桶累积最大令牌量对应的可以传输的数据量，允许突发的最大数据量。根据单位不同可以是字节也可以是比特</li>
<li>limit<br>缓冲区可以缓存的最大数据量，根据单位不同可以是字节也可以比特，k、m、g之间乘1024，接收输入后先转换为字节</li>
<li>latency<br>缓冲区可以缓存数据包的最大延迟时间，与limit互相冲突，接收输入后会用于计算出来limit</li>
<li>peakrate<br>在burst范围内的突发数据无法限制到rate速率。因此可以增加配置peakrate和mtu对突发的数据做进一步的流量整形限速</li>
<li>mtu、minburst<br>也可以是mtu/cell形式输入，cell用于配合ptab使用，cell只在旧版本内核有使用，当前已经不再使用</li>
<li>mpu<br>数据包最小尺寸字节数。比如以太网是64字节，小于该尺寸的数据包也会被填充到该尺寸再发送到链路中</li>
<li>overhead<br>数据包在链路传播需要额外占用的字节数</li>
<li>linklayer<br>指定链路层类型，输入可以是ethernet、atm、adsl</li>
</ul>
<h2 id="传输参数"><a href="#传输参数" class="headerlink" title="传输参数"></a>传输参数</h2><p>tbf qdic使用netlink与内核交互的传输参数类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;                   </span><br><span class="line">    TCA_TBF_UNSPEC,      </span><br><span class="line">    TCA_TBF_PARMS,       </span><br><span class="line">    TCA_TBF_RTAB,        </span><br><span class="line">    TCA_TBF_PTAB,        </span><br><span class="line">    TCA_TBF_RATE64,      </span><br><span class="line">    TCA_TBF_PRATE64,     </span><br><span class="line">    TCA_TBF_BURST,       </span><br><span class="line">    TCA_TBF_PBURST,      </span><br><span class="line">    TCA_TBF_PAD,         </span><br><span class="line">    __TCA_TBF_MAX,       </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="TCA-TBF-PARMS"><a href="#TCA-TBF-PARMS" class="headerlink" title="TCA_TBF_PARMS"></a>TCA_TBF_PARMS</h3><p>TCA_TBF_PARMS对应的数据结构为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tc_tbf_qopt</span> &#123;</span>              </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tc_ratespec</span> <span class="title">rate</span>;</span>      <span class="comment">// 限速速率相关</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tc_ratespec</span> <span class="title">peakrate</span>;</span>  <span class="comment">// 峰值限速速率。因为累积的token，也就是buffer的存在，会有突发数据，单纯的rate无法限制该突发。</span></span><br><span class="line">                                  <span class="comment">// 因此使用peakrate进一步限制突发速率</span></span><br><span class="line"></span><br><span class="line">    __u32       limit;            <span class="comment">// 数据包队列可以缓存的最大字节数。</span></span><br><span class="line">                                  <span class="comment">// tc命令行参数中latency也是作用于该参数，因为发送速率限制的原因，缓存最大字节数与最大延迟时间直接相关</span></span><br><span class="line"></span><br><span class="line">    __u32       buffer;           <span class="comment">// 该数据结构中buffer存储的是令牌桶允许累积的最大token数</span></span><br><span class="line">                                  <span class="comment">// tc命令在计算这个数值时，会先将整形的字节数转换为double再计算除法，由于double精度损失和最终再转换为整形的损失，传输的这个数值会比理论值小。</span></span><br><span class="line">                                  <span class="comment">// 这个值也会经过换算体现为允许突发的数据字节数，突发字节数需要不小于设备实际mtu。</span></span><br><span class="line"></span><br><span class="line">    __u32       mtu;              <span class="comment">// minburst，这个可以看作peakrate所对应的buffer，也就是peakrate的突发，意义相同。如果mtu设置小于设备实际mtu，会发生数据包无法发送的问题，直接被丢弃。</span></span><br><span class="line">                                  <span class="comment">// tc命令在计算这个数值时，情况与buffer一样，传输的数值会比理论值小。</span></span><br><span class="line">                                  <span class="comment">// 一般mtu设置小于buffer，peakrate大于rate，达到削峰效果。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tc_ratespec</span> &#123;</span>                                </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>   cell_log;                     <span class="comment">// cell的2的对数。比如cell为128，既每128字节长度作为一个粒度，则cell_log为7</span></span><br><span class="line">                                                  <span class="comment">// 采用对数是为了使用较小的数组保存更多的尺寸对应的传输所需token</span></span><br><span class="line">                                                  <span class="comment">// 匹配rtab、ptab使用，只在旧版本内核有使用</span></span><br><span class="line"></span><br><span class="line">    __u8        linklayer; <span class="comment">/* lower 4 bits */</span>     <span class="comment">// 链路层类型。3种值TC_LINKLAYER_UNAWARE、TC_LINKLAYER_ETHERNET、TC_LINKLAYER_ATM</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  overhead;                     <span class="comment">// 数据包在链路传播需要额外占用的字节数。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">short</span>       cell_align;                       <span class="comment">// tc工具固定设置为-1，与cell_log配合计算字节到所需token的转换</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  mpu;                          <span class="comment">// 数据包最小尺寸字节数。比如以太网是64字节，小于该尺寸的数据包也会被填充到该尺寸再发送到链路中</span></span><br><span class="line">                                                  <span class="comment">// 这个用于内核接收配置时做链路层类型检测</span></span><br><span class="line"></span><br><span class="line">    __u32       rate;                             <span class="comment">// 限速速率。如果限速每秒字节数小于1&lt;&lt;32，也就是不超过32位，使用该字段。否则该字段置~0U（也就是所有位置1），并使用TCA_TBF_RATE64及TCA_TBF_PRATE64。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里提到的<code>tc_tbf_qopt.buffer</code>和<code>tc_tbf_qopt.mtu</code>存储的是token数，但是tc命令输入参数是字节数，换算过程如下：</p>
<ol>
<li>将字节数size转换为发送所需要的时间，<code>size / rate * USEC_PER_SEC</code>，得到发送size字节需要的微秒数time，这里<code>USEC_PER_SEC</code>在iproute2项目中实际使用的宏为TIME_UNITS_PER_SEC</li>
<li>计算微秒数time对应的token，<code>time * tick_in_usec</code></li>
</ol>
<p>其中<code>tick_in_usec</code>在函数<code>tc_core_init</code>中被预先计算出了，这个函数中对读取值存入的变量命名会引起误解，因此下面使用内核代码说明。<br>读取/proc/net/psched文件，该文件输出4个值，实现为内核代码中函数<code>psched_show</code>，位于文件net/sched/sch_api.c</p>
<ul>
<li>第一个值为NSEC_PER_USEC，一微秒包含多少纳秒，值为1000</li>
<li>第二个值为PSCHED_TICKS2NS(1)，该宏实现为左移6位。一个tick包含多少纳秒，这里的tick为模拟的假tick，可以理解为token，只用于数据包调度整形使用，最终值为64</li>
<li>第三个值写死为1000000。</li>
<li>第四个值应该与时钟分辨率有关，tc用不到，不管了</li>
</ul>
<p><code>tick_in_usec</code>的计算方式为 <code>值1 / 值2 * 值3 / TIME_UNITS_PER_SEC</code><br>由于值3与TIME_UNITS_PER_SEC相等，<code>tick_in_usec</code>最终即为一微秒包含的token数，1000/64=15.625</p>
<h3 id="TCA-TBF-RTAB-TCA-TBF-PTAB"><a href="#TCA-TBF-RTAB-TCA-TBF-PTAB" class="headerlink" title="TCA_TBF_RTAB/TCA_TBF_PTAB"></a>TCA_TBF_RTAB/TCA_TBF_PTAB</h3><p>这两个在当前的内核中已经不再使用。后面<a href="#旧版本BUG">旧版本BUG</a>章节记录了内核版本变更过程中出现过的该表格有关的bug。</p>
<p>u32类型256项数组，tc工具中生成，由cell_log和rate确定</p>
<p>rtab/ptab的生成函数如下</p>
<ul>
<li>计算rtab时，cell_log为buffer对应的cell的2为底的对数，未配置cell时为-1，mtu为peakrate对应的mtu，如果没有配置peakrate则传入mtu为0。</li>
<li>计算ptab时，cell_log为mtu对应的cell的2为底的对数，未配置cell时为-1，mtu为peakrate对应的mtu。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tc_calc_rtable</span><span class="params">(struct tc_ratespec *r, __u32 *rtab,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> cell_log, <span class="keyword">unsigned</span> <span class="keyword">int</span> mtu,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">enum</span> link_layer linklayer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bps = r-&gt;rate;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mpu = r-&gt;mpu;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果未配置mtu，默认设置为2047，它影响的是cell_log的计算，如果cell_log配置过，传入mtu没有作用</span></span><br><span class="line">    <span class="keyword">if</span> (mtu == <span class="number">0</span>)</span><br><span class="line">        mtu = <span class="number">2047</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果未配置cell_log，计算出一个合适的值，标准是mtu右移cell_log，刚刚不大于数组最大索引255</span></span><br><span class="line">    <span class="comment">// 这样size不超过mtu尺寸的数据包，size &gt;&gt; cell_log不会大于255，可以落在rtab中</span></span><br><span class="line">    <span class="keyword">if</span> (cell_log &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cell_log = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((mtu &gt;&gt; cell_log) &gt; <span class="number">255</span>)</span><br><span class="line">            cell_log++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以cell_log为7为例，rtab[0]对应128字节所需token，rtab[1]对应256字节所需token</span></span><br><span class="line">    <span class="comment">// rtab[i]存储了 (s+1)&lt;&lt;cell_log 字节传输所需的token</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">        sz = tc_adjust_size((i + <span class="number">1</span>) &lt;&lt; cell_log, mpu, linklayer);</span><br><span class="line">        <span class="comment">// 尺寸和速率计算出所需token</span></span><br><span class="line">        rtab[i] = tc_calc_xmittime(bps, sz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r-&gt;cell_align =  <span class="number">-1</span>;</span><br><span class="line">    r-&gt;cell_log = cell_log;</span><br><span class="line">    r-&gt;linklayer = (linklayer &amp; TC_LINKLAYER_MASK);</span><br><span class="line">    <span class="keyword">return</span> cell_log;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TCA-TBF-RATE64-TCA-TBF-PRATE64"><a href="#TCA-TBF-RATE64-TCA-TBF-PRATE64" class="headerlink" title="TCA_TBF_RATE64/TCA_TBF_PRATE64"></a>TCA_TBF_RATE64/TCA_TBF_PRATE64</h3><p>当限速每秒字节数大于等于1&lt;&lt;32，也就是超过32位表示时，使用这两个参数，不再使用tc_ratespec.rate字段</p>
<h3 id="TCA-TBF-BURST"><a href="#TCA-TBF-BURST" class="headerlink" title="TCA_TBF_BURST"></a>TCA_TBF_BURST</h3><p>这里对应的也是tc_tbf_qopt.buffer，但是这里存储的是字节数，而不是token数</p>
<h3 id="TCA-TBF-PBURST"><a href="#TCA-TBF-PBURST" class="headerlink" title="TCA_TBF_PBURST"></a>TCA_TBF_PBURST</h3><p>这里对应的也是tc_tbf_qopt.mtu，但是这里存储的是字节数，而不是token数</p>
<h2 id="内核实现"><a href="#内核实现" class="headerlink" title="内核实现"></a>内核实现</h2><h3 id="配置-tbf-change"><a href="#配置-tbf-change" class="headerlink" title="配置 tbf_change"></a>配置 tbf_change</h3><p>内核使用数据结构<code>tbf_sched_data</code>保存配置参数，内核源码中该结构的注释记录了tbf的计算原理，这里不重复了<br>这个结构中有些成员记录的是字节数，有些是时间，但是这里的时间又不是传输中使用的token数，而是经过换算后的纳秒数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tbf_sched_data</span> &#123;</span>                                                     </span><br><span class="line">    <span class="comment">/* Parameters */</span>                                                            </span><br><span class="line">    u32     limit;      <span class="comment">/* Maximal length of backlog: bytes */</span></span><br><span class="line">                        <span class="comment">/* 对应传输进来的limit，数据队列字节数。生效于qdisc成员包含的bfifo队列中 */</span></span><br><span class="line"></span><br><span class="line">    u32     max_size;   <span class="comment">/* 突发数据字节数，实际运行时便于比较。取buffer和mtu对应的字节数的较小值 */</span></span><br><span class="line">                        <span class="comment">/* enqueue时使用，如果数据包尺寸超过该值将会尝试gso分片或丢弃 */</span></span><br><span class="line"></span><br><span class="line">    s64     buffer;     <span class="comment">/* Token bucket depth/rate: MUST BE &gt;= MTU/B */</span></span><br><span class="line">                        <span class="comment">/* rate对应突发数据限额对应的纳秒数，dequeue时使用 */</span></span><br><span class="line"></span><br><span class="line">    s64     mtu;        <span class="comment">/* prate对应的突发数据限额对应的纳秒数，dequeue时使用 */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">psched_ratecfg</span> <span class="title">rate</span>;</span>                                             </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">psched_ratecfg</span> <span class="title">peak</span>;</span>                                             </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Variables */</span>                                                             </span><br><span class="line">    s64 tokens;         <span class="comment">/* Current number of B tokens */</span>                    </span><br><span class="line">    s64 ptokens;        <span class="comment">/* Current number of P tokens */</span>                    </span><br><span class="line">    s64 t_c;            <span class="comment">/* Time check-point */</span>                              </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Qdisc</span>    *<span class="title">qdisc</span>;</span>     <span class="comment">/* Inner qdisc, default - bfifo queue */</span>                   </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qdisc_watchdog</span> <span class="title">watchdog</span>;</span> <span class="comment">/* Watchdog timer */</span>                    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">psched_ratecfg</span> &#123;</span>                            </span><br><span class="line">    u64 rate_bytes_ps; <span class="comment">/* bytes per second */</span>      </span><br><span class="line">    u32 mult;          <span class="comment">/* 用于加速计算字节数到纳秒数的计算 */</span>                           </span><br><span class="line">    u16 overhead;      <span class="comment">/* 见上文 */</span></span><br><span class="line">    u8  linklayer;     <span class="comment">/* 见上文 */</span>                            </span><br><span class="line">    u8  shift;         <span class="comment">/* 用于加速计算字节数到纳秒数的计算 */</span>                        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用函数<code>psched_ratecfg_precompute</code>保存及计算限速速率及用于加速字节数到对应时间长度的算法参数，存储到结构体<code>psched_ratecfg</code>中，overhead、linklayer均在这里被保存</p>
<ul>
<li>普通的计算方式为<code>time_in_ns = (NSEC_PER_SEC * len) / rate_bps</code></li>
<li>加速的计算方式为<code>time_in_ns = (len * mult) &gt;&gt; shift</code></li>
</ul>
<p>mult和shift计算方式的原因，<code>(len * mult) &gt;&gt; shift</code>计算得到的<code>time_in_ns</code>会比理论值小一点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">psched_ratecfg_precompute</span><span class="params">(struct psched_ratecfg *r,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> struct tc_ratespec *conf,</span></span></span><br><span class="line"><span class="function"><span class="params">        u64 rate64)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(r, <span class="number">0</span>, <span class="keyword">sizeof</span>(*r));</span><br><span class="line">    r-&gt;overhead = conf-&gt;overhead;</span><br><span class="line">    r-&gt;rate_bytes_ps = <span class="keyword">max_t</span>(u64, conf-&gt;rate, rate64);</span><br><span class="line">    r-&gt;linklayer = (conf-&gt;linklayer &amp; TC_LINKLAYER_MASK);</span><br><span class="line">    r-&gt;mult = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The deal here is to replace a divide by a reciprocal one</span></span><br><span class="line"><span class="comment">     * in fast path (a reciprocal divide is a multiply and a shift)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Normal formula would be :</span></span><br><span class="line"><span class="comment">     *  time_in_ns = (NSEC_PER_SEC * len) / rate_bps</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * We compute mult/shift to use instead :</span></span><br><span class="line"><span class="comment">     *  time_in_ns = (len * mult) &gt;&gt; shift;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * We try to get the highest possible mult value for accuracy,</span></span><br><span class="line"><span class="comment">     * but have to make sure no overflows will ever happen.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;rate_bytes_ps &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        u64 factor = NSEC_PER_SEC;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            r-&gt;mult = div64_u64(factor, r-&gt;rate_bytes_ps);</span><br><span class="line">            <span class="keyword">if</span> (r-&gt;mult &amp; (<span class="number">1U</span> &lt;&lt; <span class="number">31</span>) || factor &amp; (<span class="number">1U</span>LL &lt;&lt; <span class="number">63</span>))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            factor &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            r-&gt;shift++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="入队列-tbf-enqueue"><a href="#入队列-tbf-enqueue" class="headerlink" title="入队列 tbf_enqueue"></a>入队列 tbf_enqueue</h3><p>入队列出队列都比较简单，简略记录一下</p>
<p>对于外发数据包来说，<code>__dev_queue_xmit</code>中调用函数<code>qdisc_pkt_len_init</code>初始化了<code>qdisc_skb_cb(skb)-&gt;pkt_len = skb-&gt;len</code></p>
<ul>
<li>入队列时获取该长度，与max_size比较，并综合判断gso相关字段</li>
<li>符合条件会调用<code>qdisc_enqueue</code><ul>
<li>调用<code>qdisc_calculate_pkt_len</code>，尝试使用Qdisc-&gt;stab更新<code>qdisc_skb_cb(skb)-&gt;pkt_len</code>。没有看到stab哪里初始化的，就当不存在吧</li>
<li>调用Qdisc.enqueue函数指针，这里应该是<code>bfifo_enqueue</code>函数。判断数据包队列是否会超出limit，不超出则入队列</li>
</ul>
</li>
<li>如果<code>qdisc_enqueue</code>失败<ul>
<li>根据返回码判断是否需要计数drop数值，Qdisc.qstats.drops字段表示丢包数</li>
</ul>
</li>
<li>如果<code>qdisc_enqueue</code>成功<ul>
<li>更新统计信息，Qdisc.qstats.backlog表示队列中字节数，Qdisc.q.qlen表示队列中数据包数</li>
</ul>
</li>
</ul>
<h3 id="出队列-tbf-dequeue"><a href="#出队列-tbf-dequeue" class="headerlink" title="出队列 tbf_dequeue"></a>出队列 tbf_dequeue</h3><ul>
<li>获取队列首包</li>
<li><code>qdisc_pkt_len(skb)</code>获取数据包长度</li>
<li>获取当前时间纳秒值</li>
<li>当前时间纳秒值与上次检查点时间纳秒值做减法，并与<code>tbf_sched_data.buffer</code>做比较、取较小值赋值给toks。含义是取得当前新累积的令牌数量，这里令牌使用了纳秒代替，该数量不能超过突发量。</li>
<li>如果有配置峰值速率，之前剩余q-&gt;ptokens加toks获取可用峰值ptoks，注意这里mtu相当于峰值限速的buffer，因此ptoks不能大于mtu。ptoks减掉当前数据包长度需要消耗的纳秒值（这里使用了overhead及linklayer）</li>
<li>q-&gt;tokens加toks获取当前可用toks，限制toks不能大于buffer</li>
<li>toks减去当前数据包需要消耗的纳秒值（这里使用了overhead及linklayer）</li>
<li>如果toks与ptoks都大于0，说明当前资源满足发送该数据包<ul>
<li>更新检查点为当前时间</li>
<li>更新tbf_sched_data的tokens与ptokens成员</li>
<li>更新统计信息，Qdisc.qstats.backlog，Qdisc.q.qlen，Qdisc.bstats.bytes队列发出的字节数，Qdisc.bstats.packets队列发出的包数</li>
<li>返回skb</li>
</ul>
</li>
<li>如果不满足发包要求<ul>
<li>设置定时器</li>
<li>更新超限速统计信息，Qdisc.qstats.overlimits表示超出限速没有成功从队列取出数据包的次数，数据包只是暂时保留在队列中。这个数值会出现超过发出包数的情况</li>
</ul>
</li>
</ul>
<h2 id="旧版本BUG"><a href="#旧版本BUG" class="headerlink" title="旧版本BUG"></a>旧版本BUG</h2><h3 id="3-9rc1之前"><a href="#3-9rc1之前" class="headerlink" title="3.9rc1之前"></a>3.9rc1之前</h3><p>内核收到的buffer和mtu为token值，rate为字节数，rtab、ptab为tc计算生成。内核对以上数据均为原值原单位保存。</p>
<h4 id="max-size"><a href="#max-size" class="headerlink" title="max_size"></a>max_size</h4><p>在旧版本内核中，使用<a href="#TCA-TBF-RTAB-TCA-TBF-PTAB">rtab和ptab</a>计算max_size，位于<code>tbf_change</code>函数中，可以看到这里将buffer和mtu的token值通过rtab、ptab换算回了字节数(该cell对应最大字节数-1)，并取两个的较小值。由于cell颗粒度的原因，这个max_size可能比buffer和mtu对应的理论字节数大。</p>
<figure class="highlight c"><figcaption><span>max_size计算</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; <span class="number">256</span>; n++)</span><br><span class="line">    <span class="keyword">if</span> (rtab-&gt;data[n] &gt; qopt-&gt;buffer)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">max_size = (n &lt;&lt; qopt-&gt;rate.cell_log) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (ptab) &#123;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; <span class="number">256</span>; n++)</span><br><span class="line">        <span class="keyword">if</span> (ptab-&gt;data[n] &gt; qopt-&gt;mtu)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    size = (n &lt;&lt; qopt-&gt;peakrate.cell_log) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; max_size)</span><br><span class="line">        max_size = size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以先假设未配置peakrate，那么只考虑rtab</p>
<ul>
<li>选择最小的rtab[s] &gt; qopt-&gt;buffer，若遍历结束也未符合，则s取到256</li>
<li>max_size = s &lt;&lt; cell_log - 1</li>
<li>上面rtab[s]值对应的是(s+1) &lt;&lt; cell_log字节传输所需的token</li>
<li>max_size相当于选择了前一个cell的最大字节数-1</li>
<li>这个选择方式下，前一个cell，也就是rtab[s-1]小于等于qopt-&gt;buffer这个token值。</li>
<li>如果刚好是等于，那么max_size+1的传输时间就等于buffer，而这个buffer的token值是经历过精度损失的，也就是说可能存在一个范围的字节数的传输时间都等于这个buffer。</li>
</ul>
<h5 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h5><ul>
<li>以rate 500mbit（62500000字节每秒），cell值128为例，cell_log=7，</li>
<li>rtab[240]的值对应的是241 &lt;&lt; 7（也就是30848字节）传输所需的7703token</li>
<li>由于计算所需token时double精度原因，[30813, 30874]字节范围内buffer计算均为7703</li>
<li>也就是说，tc命令配置的buffer在[30813，30874]范围内时，max_size均为30847</li>
<li>在dequeue时，[30721,30848]范围内，查找对应token时都会落在rtab[240]中。</li>
</ul>
<h5 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h5><ul>
<li>以rate100mbit（12500000字节每秒），cell值8为例，cell_log=3（未配置cell和mtu时默认值）</li>
<li>rtab[200]的值对应的是201&lt;&lt;3（也就是1608字节）传输所需的2000token</li>
<li>由于计算所需token时double精度原因，[1600, 1612]字节范围内buffer计算均为2000</li>
<li>也就是说，tc命令配置的buffer在[1600，1612]范围内时，max_size均为1607</li>
<li>在dequeue时，[1601,1608]范围内，查找对应token时都会落在rtab[200]中。</li>
</ul>
<h4 id="enqueue-dequeue"><a href="#enqueue-dequeue" class="headerlink" title="enqueue/dequeue"></a>enqueue/dequeue</h4><p>enqueue时检查数据包不大于max_size，超过做drop处理</p>
<p>dequeue时通过rtab查找传输数据包需要的token，与当前可用的token比较，当前可用的token被限制不超过buffer，max_size尺寸需要的token不会超过buffer</p>
<figure class="highlight c"><figcaption><span>dequeue时将字节转换为传输需要的token</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> u32 <span class="title">qdisc_l2t</span><span class="params">(struct qdisc_rate_table* rtab, <span class="keyword">unsigned</span> <span class="keyword">int</span> pktlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> slot = pktlen + rtab-&gt;rate.cell_align + rtab-&gt;rate.overhead;</span><br><span class="line">    <span class="keyword">if</span> (slot &lt; <span class="number">0</span>)</span><br><span class="line">        slot = <span class="number">0</span>;</span><br><span class="line">    slot &gt;&gt;= rtab-&gt;rate.cell_log;</span><br><span class="line">    <span class="keyword">if</span> (slot &gt; <span class="number">255</span>)</span><br><span class="line">        <span class="keyword">return</span> rtab-&gt;data[<span class="number">255</span>]*(slot &gt;&gt; <span class="number">8</span>) + rtab-&gt;data[slot &amp; <span class="number">0xFF</span>];</span><br><span class="line">    <span class="keyword">return</span> rtab-&gt;data[slot];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一系列流程是可以正确工作的</p>
<h3 id="3-9rc1"><a href="#3-9rc1" class="headerlink" title="3.9rc1"></a>3.9rc1</h3><p>3.9rc1开始包含了这个提交<a href="https://github.com/torvalds/linux/commit/b757c9336d63f94c6b57532bb4e8651d8b28786f" target="_blank" rel="noopener">b757c93 tbf: improved accuracy at high rates</a></p>
<p>也导致了bug的出现。centos7.2 3.10.0-327.el7.x86_64内核含有该bug</p>
<p>这个提交没有变更内核中max_size计算逻辑，依然通过遍历rtab并与buffer的token值对比确定</p>
<p>但是</p>
<ul>
<li>内核保存的配置buffer和mtu都由token转换到了纳秒</li>
<li>dequeue时不再查rtab表，而是通过(size * mult) &gt;&gt; shift计算传输数据包所需纳秒，<a href="#配置-tbf-change">方式参考</a>，这种方式计算字节到纳秒的转换，精度损失很低</li>
</ul>
<p>以<a href="#例1">例1数据</a></p>
<ul>
<li>max_size为30847，buffer对应token值7703，对应纳秒值492992</li>
<li>30813字节的数据包可以enqueue，dequeue时计算传输所需纳秒(30813 * 2147483648) &gt;&gt; 27 = 493008，超过了buffer的纳秒值，会导致dequeue失败，阻塞在队列头，该队列就无法正常发送数据包了。</li>
</ul>
<p>以<a href="#例2">例2数据</a></p>
<ul>
<li>max_size为1607，buffer对应token值2000，对应纳秒值128000</li>
<li>1601字节的数据包可以enqueue，dequeue时计算传输所需纳秒(1601 * 2684354560) &gt;&gt; 25 = 128080，超过了buffer的纳秒值，会导致dequeue失败，阻塞在队列头，该队列就无法正常发送数据包了。</li>
</ul>
<p>因为在一些情况下，buffer对应的token值可以等于rtab中一个槽位的token值，max_size就对应了这个cell所代表的最大字节数，但是token是有精度损失的，也就是说这个token实际对应的是更小的字节数，将buffer转换为纳秒后，这个纳秒也对应的也是相比max_size更小的字节数。当一个比这个字节数大又不超过max_size的数据包enqueue以后，在dequeue时计算出的传输所需纳秒数就会检查到比buffer的纳秒数更大，导致dequeue失败。<br>以上是以buffer为例，mtu的影响也是同buffer一样的。</p>
<h3 id="3-13rc4"><a href="#3-13rc4" class="headerlink" title="3.13rc4"></a>3.13rc4</h3><p>3.13rc4开始包含了这个提交<a href="https://github.com/torvalds/linux/commit/cc106e441a63bec3b1cb72948df82ea15945c449" target="_blank" rel="noopener">cc106e4 net: sched: tbf: fix the calculation of max_size</a></p>
<p>这个提交修复了上面的bug。centos7.5 3.10.0-862.el7.x86_64内核修复了该bug。7.3和7.4未检查验证</p>
<p>该提交先将token值的buffer和mtu转换为纳秒值的buffer和mtu，再使用纳秒值和限速速率计算出max_size。<br>这样dequeue时通过字节数计算得到的纳秒数就可以匹配buffer和mtu的纳秒数了。<br>这里开始rtab、ptab不再有作用了。</p>
<h3 id="3-14rc1"><a href="#3-14rc1" class="headerlink" title="3.14rc1"></a>3.14rc1</h3><p>3.14rc1开始包含了这个提交<a href="https://github.com/torvalds/linux/commit/2e04ad424b03661ec8239acd52146497eb33be1c" target="_blank" rel="noopener">2e04ad4 sch_tbf: add TBF_BURST/TBF_PBURST attribute</a></p>
<p>加了TCA_TBF_BURST/TCA_TBF_PBURST这两个参数，直接传递buffer和mtu的字节数。<br>当新增的参数存在时，用于确定max_size，内核保存的buffer和mtu纳秒值由新增的字节单位参数计算得到。<br>这时使用tc命令配置tbf时，可以精确生效字节单位配置。<br>但是截止2024年7月，linux内核tbf_dump时依然未输出这两个参数，v6.10.0版本iproute2项目中tc命令也未读取这两个参数，两者都只使用了旧版本的token值的buffer和mtu。导致展示配置时与内核保存的实际配置有偏差。</p>
<h3 id="BUG规避"><a href="#BUG规避" class="headerlink" title="BUG规避"></a>BUG规避</h3><p>对比存在bug的内核，bug的触发，是由于计算出的max_size相对buffer对应的字节数大了，导致dequeue检查失败。<br>max_size的计算受buffer和cell_log共同影响，只要确保max_size绝对小于buffer对应的字节数就可以规避bug。<br>因此，配置合适的buffer和cell_log就可以确保bug不会发生。</p>
<p>比如<a href="#例1">例1数据</a>中，buffer设置30813，cell_log为7时，max_size为30847，bug可能触发。<br>修改cell_log为6，buffer不变，max_size变为16383。(16383 * 2147483648) &gt;&gt; 27 = 262128，远小于buffer的纳秒值492992，bug不会触发。</p>
<p>比如<a href="#例2">例2数据</a>中，buffer设置1601，cell_log默认为3时，max_size为1607，bug可能触发。<br>修改buffer设置为3200，cell_log手动指定为3，max_size变为2047。(2047 * 2684354560) &gt;&gt; 25 = 163760，远小于buffer的纳秒值256000，bug不会触发。</p>
<p>如果以修改cell_log规避，可以使用如下方式确定合适的cell_log。原方式计算出cell_log后，以该cell_log计算临时rtab和max_size，并计算该max_size的token，该token应该是不大于buffer的token的，如果刚好相等则cell_log减1，再重复回到计算临时rtab和max_size。循环该过程，直到临时max_size的token小于buffer的token，这时的cell_log就是可用的。这个循环不超过2次就可以达成目标。</p>
<p>mtu和其cell_log同理</p>
<p>实际业务中，简单起见，可以考虑固定buffer，使用调整过的cell_log，比如65535字节buffer，其cell指定为128(cell_log为7)，则bug不会触发。</p>
</div><div class="tags"><a href="/tags/linux/">linux</a></div><div class="post-nav"><a class="pre" href="/2024/04/11/rcu-usage/">抢占式RCU与RCU使用</a><a class="next" href="/2022/08/08/function-call-stack/">gdb查看寄存器及内存数据与函数调用栈分析</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://www.hyuuhit.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/libvirt/">libvirt</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/suricata/">suricata</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/vmware/" style="font-size: 15px;">vmware</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/06/08/screen-windows-auto-title/">gnu screen 自动修改窗口标题</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/06/02/stop-machine/">stop_machine 实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/05/05/static-key-jump-label/">static key & jump label</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/30/initcall/">initcall 机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/07/cn-proc-example/">cn_proc 进程事件连接器</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/04/executable-shared-library/">可执行的动态链接库</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/05/26/dirpro-bug-analysis/">一次无源码Linux内核模块bug分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/05/13/elrepo-not-for-production-use/">为什么生产环境服务器不应该使用ELRepo内核</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/04/29/memory-consistency-model-memory-barrier-and-sychronization/">内存一致性模型、内存屏障与同步</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/04/11/rcu-usage/">抢占式RCU与RCU使用</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">属乌鸦的.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>